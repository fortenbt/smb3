; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:33.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

Sound_Engine_Begin:
	LDA #$ff	 ; 
	STA FRAMECTR_CTL ; Resets the frame counter clock (sync sound hardware), disables IRQ generation

	LDA Sound_QPause
	BNE SndPause	 ; If a "pause/resume" was requested, jump to SndPause
	LDA SndCur_Pause
	BNE PRG028_A04F	 	; If playing the pause sound, jump to PRG028_A04F
	LDA Sound_IsPaused	
	BNE PRG028_A08F	 	; If sound is currently paused, jump to PRG028_A08F (allows processing of pause sound)

	JMP Sound_Process	; Otherwise, jump to normal sound processing routine!

SndPause:	; $A017
	STA SndCur_Pause	 ; Store it into the "hold" variable
	STA Sound_IsPaused	 ; Mark sound as paused
	CMP #$02	 ; Is the request actually to RESUME sound?
	BNE PRG028_A033	 ; If not, go to PRG028_A033

	; Want to RESUME sound, not pause!
	LDA #$00
	STA Sound_IsPaused	 ; Clear IsPaused
	STA SndCur_Pause	 ; Clear the pause sound hold
	STA PAPU_EN	 ; Disable all channels
	LDA #$0f	 ;  
	STA PAPU_EN	 ; Enable all channels
	BNE Sound_Process	 ; (Technically always) jump to Sound_Process

PRG028_A033:
	; Want to PAUSE sound
	LDA #$00
	STA PAPU_EN	; Disable all sound channels

	; Clear other sound counters
	STA SndCur_Player	; Kill player sound
	STA SndCur_Level1	; Kill level 1 sound
	STA SndCur_Level2	; Kill level 2 sound
	LDA #$0f	
	STA PAPU_EN	; Enable all sound channels
	LDA #$2a	
	STA SFX_Counter1 ; SFX_Counter1 = $2A

PRG028_A04B:
	LDA #$68	 ; Play note 104 (high bing)
	BNE PRG028_A060	 ; (Technically always) jump to PRG028_A060

PRG028_A04F:
	LDA SFX_Counter1
	CMP #$24
	BEQ PRG028_A05E	 ; If SFX_Counter1 is at $24, jump to PRG028_A05E (play a low bing)
	CMP #$1e
	BEQ PRG028_A04B	 ; If SFX_Counter1 is at $1E, jump to PRG028_A04B (play another high bing)
	CMP #$18
	BNE PRG028_A067	 ; If SFX_Counter1 is at $18, jump to PRG028_A067 (otherwise, just decrement)

PRG028_A05E:
	LDA #96		; Play note 96 (low bing)

PRG028_A060:
	LDX #$84	 ; Goes to PAPU_CTL1
	LDY #$7f	 ; Goes to PAPU_RAMP1
	JSR Sound_Sq1_NoteOn

PRG028_A067:
	DEC SFX_Counter1 ; SFX_Counter1--
	BNE PRG028_A08F	 ; If not zero yet, go to PRG028_A08F

	; Pause sound over!
	LDA #$00	 ; 
	STA PAPU_EN	 ; Disable all sound channels
	LDA #$00	 ; 
	STA SndCur_Pause	 ; Stop the pause sound hold
	BEQ PRG028_A08F	 ; (technically always) go to PRG028_A08F

Sound_Process:
	; Queue + Play all sounds in...
	JSR Sound_PlayLevel2	 ; Level 2
	JSR Sound_PlayPlayer	 ; Player
	JSR Sound_PlayLevel1	 ; Level 1
	JSR Sound_PlayMapSounds	 ; Map sounds
	JSR Sound_PlayMusic	 ; Music
PRG028_A087:
	; Clear any music queues
	LDA #$00	 
	STA Sound_QMusic2
	STA Sound_QMusic1

PRG028_A08F:

	; Clear all sound queues
	LDA #$00
	STA Sound_QPlayer
	STA Sound_QLevel1
	STA Sound_QLevel2
	STA Sound_QMap
	STA Sound_QPause
	RTS		 ; Return

Sound_PlayMapSounds:
	LDA Sound_QMap
	BNE MapSound_Queued	 ; If a map sound has been queued, jump to MapSound_Queued
	LDA SndCur_Map
	BNE MapSound_Playing	 ; If a map sound is already playing, jump to MapSound_Playing

	; Nothing to do!
	RTS		 ; Return

MapSound_Queued:
	CMP #SND_MAPENTERLEVEL
	BNE PRG028_A0BD	 ; If not playing Map Entering Level sound, go to PRG028_A0BD

	; Entering level sound only:
	LDX #$00	 ; 
	STX SndCur_Music2	 ; Halt any playing BGM
	STX PAPU_EN	 ; Disable all sound channels
	LDX #$0f	 ; 
	STX PAPU_EN	 ; Enable all sound channels

PRG028_A0BD:
	STA SndCur_Map ; Lock in this sound as playing!

	; Sound_Unused7FF = 0 (but never used again...)
	LDY #$00
	STY Sound_Unused7FF

	; The map sounds are issued by bit ($01, $02, $04, $08, etc.)
	; this loop converts it to a Y value of 1-8
	; Basically you earn a prioritization system; lowest sound plays first!
PRG028_A0C5:
	INY		 ; Y++
	LSR A		 ; Sound >> 1 ... -> Carry
	BCC PRG028_A0C5	 ; Waiting for that bit...!

	LDA Sound_Map_LUT-1,Y	; Unfortunately the index is one off, so we have to access the LUT one prior
	TAY		 	; Y = first byte for this sound from LUT

	; Y is now an offset gleaned from the first 8 bytes of this table...
	LDA Sound_Map_LUT,Y	; A = Offset to sound
	STA <Sound_Map_Off	; Store offset to Sound_Map_Off

	LDA Sound_Map_LUT+1,Y	; Offset for the second track of the sound
	STA Sound_Map_Off2	; Store offset to Sound_Map_Off2

	LDA #$01	 ; 
	STA Sound_Map_Len	 ; Sound_Map_Len = 1, so it updates immediately
	STA Sound_Map_Len2	 ; Sound_Map_Len2 = 1, so it updates immediately

MapSound_Playing:
	DEC Sound_Map_Len	 ; Sound_Map_Len--
	BNE PRG028_A136	 ; If Sound_Map_Len > 0, jump to PRG028_A136

	; Sound_Map_Len = 0 ...
	LDY <Sound_Map_Off	; Y = Sound_Map_Off
	INC <Sound_Map_Off	; Sound_Map_Off++
	LDA SndMap_Data,Y 	; Get next byte of sound data

	BEQ MapSound_Stop 	; If it's $00, sound over!  Jump to MapSound_Stop
	BPL MapSound_PlayFreqL	; $00 - $7f injects a new byte into PAPU_FT1 (low byte frequency)
	BNE MapSound_SetLen	; $80 - $ff, MapSound_SetLen

MapSound_Stop:
	LDA #$08	 ; 
	STA PAPU_EN	 ; Only noise channel left enabled
	LDA #$0f	 ; 
	STA PAPU_EN	 ; All channels enabled
	LDA #$00	 ; 
	STA SndCur_Map ; Release hold, no longer playing a sound
	RTS		 ; Return

MapSound_SetLen:
	JSR AND7F	 	; Just keep the lower 7 bits
	STA Sound_Map_LHold	; Use this as the new length value for any following bytes
	LDY <Sound_Map_Off	; Y = offset into sound data
	INC <Sound_Map_Off	; Sound_Map_Off++
	LDA SndMap_Data,Y	; Get the next (presumably not rest!) byte


MapSound_PlayFreqL:
	STA PAPU_FT1	 ; Byte goes directly into frequency register
	LDA SndCur_Map ; Get the hold value
	BPL PRG028_A120	 ; If $80 not set, jump to PRG028_A120

	LDA #$0e	 ; 
	STA PAPU_CT1	 ; Fairly high frequency, short length
	LDX #%10011111	 ; Square 1's CTL settings: Max volume, envelope decay disabled, 50% duty cycle
	BNE PRG028_A127	 ; (technically always) jump to PRG028_A127

PRG028_A120:
	LDA #$08	 ; 
	STA PAPU_CT1	 ; Short length
	LDX #%10010111	 ; Square 1's CTL settings: Half volume, envelope decay disabled, 50% duty cycle

PRG028_A127:
	LDY #$7f	 ; Ramp settings: Everything except actually enabling the ramp!
	JSR Sound1_XCTL_YRAMP
 
	LDA Sound_Map_LHold	 ; Get the current length hold value
	STA Sound_Map_Len	 ; Reset the length counter with this value!
	LDA #$00	 	 ; 
	STA <Sound_Map_EntrV	 ; Start at index 0 for volume ramping (sound $04, level enter, ONLY!)

PRG028_A136:
	LDA SndCur_Map ; Get current map sound we're playing
	CMP #$04	 ; 
	BNE PRG028_A147	 ; If it's NOT $04 (entering level) jump to PRG028_A147

	; $04 (entering level) specific...
	; The volume is ramped down as the sound plays!
	INC <Sound_Map_EntrV	 ; Sound_Map_EntrV++
	LDY <Sound_Map_EntrV	 ; Y = Sound_Map_EntrV
	LDA SndMap_Entr_VolData-1,Y	 ; because they incremented the pointer FIRST, I have to subtract 1 from the LUT address!
	STA PAPU_CTL1	 ; Set the new volume!

PRG028_A147:
	; For any sound...

	LDY Sound_Map_Off2	; Y = Sound_Map_Off2
	BEQ PRG028_A19B	 	; If Sound_Map_Off2 = 0, jump to PRG028_A19B (do nothing; an offset of zero disables the track)

	DEC Sound_Map_Len2	; Sound_Map_Len2--
	BNE PRG028_A18F	 	; If not zero, jump to PRG028_A18F

	LDY Sound_Map_Off2	; Y = Sound_Map_Off2 (again)
	INC Sound_Map_Off2	; Sound_Map_Off2++

	LDA SndMap_Data,Y 	; Get this byte of sound data
	BPL MapSound_Play2FreqL	; If it is $00-$7f, jump to BPL MapSound_Play2FreqL

	; Otherwise this is a length setting
	JSR AND7F		; & $7F
	STA Sound_Map_L2Hld	; Use this as the new length for following bytes
	LDY Sound_Map_Off2	; Y = Sound_Map_Off2
	INC Sound_Map_Off2	; Sound_Map_Off2++
	LDA SndMap_Data,Y	; Get the next (presumably note!) byte 

MapSound_Play2FreqL:
	CMP #$7e	 ; 
	BNE PRG028_A176	 ; Is the next byte $7e? If not, jump to PRG028_A176
	LDA #%00010000	 ; 
	STA PAPU_CTL2	 ; Disables envelope decay, but that's it
	BNE PRG028_A185	 ; (technically always) jump to PRG028_A185

PRG028_A176:
	; Every other byte...
	STA PAPU_FT2

	LDX #$08	 ; 
	STX PAPU_CT2	 ; Short length
	LDX #%01010101	 ; Square 2's CTL settings: 33% volume, envelope decay disabled, 25% duty cycle
	LDY #$7f	 ; Ramp settings: Everything except actually enabling the ramp!
	JSR Sound2_XCTL_YRAMP

PRG028_A185:
	LDA Sound_Map_L2Hld	 ; Get the current length hold value
	STA Sound_Map_Len2	 ; Reset the length counter with this value!

	; Sound_Map_EntV2 = 0
	LDA #$00
	STA <Sound_Map_EntV2

PRG028_A18F:
	INC <Sound_Map_EntV2	 ; Sound_Map_EntV2++

	LDY <Sound_Map_EntV2	; Y = Sound_Map_EntV2

	LDA SndMap_Entr_VolData-1,Y
	ORA #$50	 ; Envelope decay disable + 25% duty cycle
	STA PAPU_CTL2	 ; Set the register

PRG028_A19B:
	RTS		 ; Return

SndMap_Entr_VolData:
	; This ramps down the volume during the "level enter" sound
	.byte $97, $96, $96, $95, $95, $95, $94, $94, $94, $93, $93, $92, $92, $91, $91, $91


AND7F:	; This seems like a ridiculous subroutine!
	AND #$7f
	RTS		 ; Return

MSHO .func \1-Sound_Map_LUT	; "Map Sound Header Offset"
Sound_Map_LUT:
	; These are offsets from here to the respective SFX data headers
	.byte MSHO(SndMapH_Entrance),	MSHO(SndMapH_Move)
	.byte MSHO(SndMapH_Enter),	MSHO(SndMapH_Flip)
	.byte MSHO(SndMapH_Bonus),	MSHO(SndMapH_Unused)
	.byte MSHO(SndMapH_Unused),	MSHO(SndMapH_Deny)


MSO .func \1-SndMap_Data
	;	Offset1, Offset2
	; Offset1 specifies a first track played on Square 1 at 50% duty cycle
	; Offset2 specifies a second track played on Square 2 at 25% duty cycle, only used by the level entry sound...
SndMapH_Entrance:	.byte MSO(SndMap_Data_WEnt),	$00 ; $01: World begin starry entrance sound
SndMapH_Move:		.byte MSO(SndMap_Data_Move),	$00 ; $02: Path move
SndMapH_Enter:		.byte MSO(SndMap_Data_Entr),	MSO(SndMap_Data_Entr2) ; $04: Enter level
SndMapH_Flip:		.byte MSO(SndMap_Data_Flip),	$00 ; $08: Flip inventory
SndMapH_Bonus:		.byte MSO(SndMap_Data_Bonus),	$00 ; $10: Bonus appears
SndMapH_Deny:		.byte MSO(SndMap_Data_Deny), 	$00 ; $80: Denied
SndMapH_Unused:		.byte MSO(SndMap_Data_Unused),	$00 ; $20/$40: ?? unused ?


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Format of Map sound data:
; $00:		Ends sound
; $01-$7F:	Sets PAPU_FT1 to this value (lower = higher pitch)
; $80-$FF:	Removing the high bit, this sets the length of following values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SndMap_Data:
SndMap_Data_WEnt:
	.byte $83, $35, $32, $2F, $2C, $2A, $28, $25, $23, $21, $1F, $1D, $1C, $1A, $18, $16
SndMap_Data_Unused: 
	.byte $00	; NOTE: This is SndMap_Data_WEnt's terminator!

	; NOTE: The SndMap_Data_Entr $04 sound is expected to be synced with volume values
	; specified in the table SndMap_Entr_VolData!
SndMap_Data_Entr:
	.byte $84, $12, $15, $19, $1F, $23, $2A, $32, $3F, $47, $54, $64, $8A, $7F, $00

	; "Second track" of entry sound, played on Square 2, only map sound to do this...
SndMap_Data_Entr2:
	.byte $82, $7E, $84, $12, $15, $19, $1F, $23, $2A, $32, $3F, $47, $54, $64, $8A, $7F, $00

SndMap_Data_Flip:
	.byte $85, $6A, $5F, $87, $47, $00

SndMap_Data_Move:
	.byte $85, $2A, $8A, $23, $00

SndMap_Data_Bonus:
	.byte $85, $54, $47, $3F, $35, $8A, $2A, $00

SndMap_Data_Deny:
	.byte $88, $14, $14, $8A, $14, $00

; End of "Map" sounds
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Bytes sent to PAPU_CTL1 for the swim sound
SwimCTL1_LUT:
	.byte $9F, $9B, $98, $96, $95, $94, $92, $90, $90, $9A, $97, $95, $93, $92


PRG028_A21D:
	; Pipe sound comes here
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$08	 
	STA SFX_Counter1 ; SFX_Counter1 = 8
	BNE PRG028_A22F	 ; (technically always) jump to PRG028_A22F

PRG028_A227:
	; SFX_Counter1 has gone to zero...
	LSR Sound_QPlayer	; Sound_QPlayer >>= 1
	BCS PRG028_A22F	 	; If another bit present (?), jump to PRG028_A22F (seems like a dumb place to go with SFX_Counter1 = 0)
	JMP PlayerSnd_Stop	 	; Otherwise, hop to PlayerSnd_Stop

PRG028_A22F:
	DEC SFX_Counter1 ; SFX_Counter1--
	LDA SFX_Counter1 ; A =  SFX_Counter1
	BEQ PRG028_A23F	 ; If SFX_Counter1 = 0, jump to PRG028_A23F
	CMP #$04	 ; 
	BNE PRG028_A24D	 ; If SFX_Counter1 <> 4, jump to PRG028_A24D (do nothing)
	LDA #110	 ; Note 110
	BNE PRG028_A246	 ; (technically always) jump to PRG028_A246

PRG028_A23F:
	; SFX_Counter1 = 8
	LDA #$08
	STA SFX_Counter1

	LDA #$72

PRG028_A246:
	LDX #%10110100	 ; PAPU_CTL1 - volume 8, envelope decay disabled, looping enable, 50% duty 
	LDY #$7f	 ; PAPU_RAMP - Everything but the ramp enable!
	JSR Sound_Sq1_NoteOn

PRG028_A24D:
	RTS		 ; Return

PlayerSnd_Frog:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #66		 ; Slightly higher note, otherwise same as PlayerSnd_Jump
	BNE PRG028_A25A	 ; Jump (technically always) to PRG028_A25A

PlayerSnd_Jump:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #52		 ; Note 52

PRG028_A25A:
	LDX #%10000010	 ; PAPU_CTL1  - 50% duty, envelope decay rate 2
	LDY #%10100111	 ; PAPU_RAMP1 - Max shift amount, rate update 2, enable sweep
	JSR Sound_Sq1_NoteOn	 ; Play sound!

	LDA #$28
	STA SFX_Counter1 ; Load SFX_Counter1 = $28; when this expires, sound ends!

PlayerSnd_FrogCont:
	LDA SFX_Counter1 ; A = SFX_Counter1
	CMP #$25	 ; 
	BNE PRG028_A273	 ; If SFX_Counter1 <> $25, go to PRG028_A273

	; When SFX_Counter1 reaches $25...
	LDX #%01011111	 ; PAPU_CTL1  - max decay rate (and disabled), 25% duty
	LDY #%11110110	 ; PAPU_RAMP1 - slower right shift, max sweep rate, and enabled
	BNE PRG028_A27B	 ; (technically always) jump to PRG028_A27B

PRG028_A273:
	; SFX_Counter1 <> $25...
	CMP #$20	 ; 
	BNE PRG028_A2A6	 ; If SFX_Counter1 <> $20, go to PRG028_A2A6

	; When SFX_Counter1 reaches $20...
	LDX #%01001000	 ; PAPU_CTL1  - volume 0, decay disabled, 25% duty
	LDY #%10111100	 ; PAPU_RAMP1 - shift amount 4, decrease wavelength, sweep update 3, sweep enable

PRG028_A27B:
	JSR Sound1_XCTL_YRAMP
	BNE PRG028_A2A6	 ; (technically always) jump to PRG028_A2A6

PlayerSnd_Fire:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #5 	 	; SFX_Counter1 will be 5
	LDY #%10011001	 ; PPU_RAMP1 - right shift minimal, decrease wavelength, sweep rate 1, enable sweep
	BNE PRG028_A290	 ; Jump (technically always) to PRG028_A290

PlayerSnd_Bump:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #10		 ; SFX_Counter1 will be 5
	LDY #%10010011	 ; PPU_RAMP1 - right shift 3, increase wavelength, sweep update 1, enable sweep

PRG028_A290:
	LDX #%10011110	 ; PAPU_CTL1 - volume 14, decay disabled, 50% duty
	STA SFX_Counter1

	LDA #38		 ; Note 38
	JSR Sound_Sq1_NoteOn	 ; Play sound!

PlayerSnd_FirBmpCont:
	LDA SFX_Counter1
	CMP #$06	
	BNE PRG028_A2A6	 ; If SFX_Counter1 <> 6, go to PRG028_A2A6

	; SFX_Counter1 = 6...
	LDA #%10111011	 ; 
	STA PAPU_RAMP1	 ; right shift 3, decrease wavelength, sweep rate 3, enable sweep

PRG028_A2A6:
	BNE PRG028_A325	 ; A <> 0, jump to PRG028_A325

PRG028_A2A8:
	; SFX_Counter1 = 0 is the only point you get down here...
	; or from Sound_QPlayer = $40 (unused)
	JMP PRG028_A227	 ; Jump to  PRG028_A227

Sound_PlayPlayer:
	LDY Sound_QPlayer ; Get sound queue for Player sounds
	BEQ PRG028_A2D0	 ; If 0, nothing's queued; go to PRG028_A2D0

	BMI PlayerSnd_Frog 	; If sound $80 frog jump, go to PlayerSnd_Frog

	; Since the input is a bit value ($01, $02, $04, ...), this will
	; decode it by continuously shifting to the right until we hit
	; a bit; this also incidentally provides a simple priority system.

	LSR Sound_QPlayer
	BCS PlayerSnd_Jump 	; If sound $01 (SND_PLAYERJUMP), go to PlayerSnd_Jump
	LSR Sound_QPlayer
	BCS PlayerSnd_Bump 	; If sound $02 (SND_PLAYERBUMP), go to PlayerSnd_Bump
	LSR Sound_QPlayer
	BCS PlayerSnd_Swim 	; If sound $04 (SND_PLAYERSWIM), go to PlayerSnd_Swim
	LSR Sound_QPlayer
	BCS PlayerSnd_Kick 	; If sound $08 (SND_PLAYERKICK), go to PlayerSnd_Kick
	LSR Sound_QPlayer
	BCS PlayerSnd_Pipe 	; If sound $10 (SND_PLAYERPIPE), go to PlayerSnd_Pipe
	LSR Sound_QPlayer
	BCS PlayerSnd_Fire 	; If sound $20 (SND_PLAYERFIRE), go to PlayerSnd_Fire

PRG028_A2D0:
	LDA SndCur_Player
	BEQ PRG028_A2E9	 ; If no sound playing, jump to PRG028_A2E9

	BMI PlayerSnd_FrogCont	 ; If sound $80 (SND_PLAYERFROG), go to PlayerSnd_FrogCont
	LSR A		 ; 
	BCS PlayerSnd_JumpCont	 ; If sound $01 (SND_PLAYERJUMP), go to PlayerSnd_JumpCont
	LSR A		 ;
	BCS PlayerSnd_FirBmpCont ; If sound $02 (SND_PLAYERBUMP), go to PlayerSnd_FirBmpCont
	LSR A		 ; 
	BCS PlayerSnd_SwimCont	 ; If sound $04 (SND_PLAYERSWIM), go to PlayerSnd_SwimCont	
	LSR A		 ; 
	BCS PlayerSnd_KickCont	 ; If sound $08 (SND_PLAYERKICK), go to PlayerSnd_KickCont
	LSR A		 ; 
	BCS PlayerSnd_PipeCont	 ; If sound $10 (SND_PLAYERPIPE), go to PlayerSnd_PipeCont
	LSR A		 ; 
	BCS PlayerSnd_FirBmpCont ; If sound $20 (SND_PLAYERFIRE), go to PlayerSnd_FirBmpCont

PRG028_A2E9:
	LDA SndCur_Player
	CMP #SND_PLAYERPOWER
	BEQ PRG028_A2A8	 	; If SndCur_Player = SND_PLAYERPOWER, go to PRG028_A2A8

	LSR Sound_QPlayer	; 
	BCS PRG028_A2FC	 	; If SND_PLAYERJUMP (??) go to PRG028_A2FC (I don't think this will ever happen)
	RTS		 ; Return

PlayerSnd_Pipe:
	JMP PlayerSnd_Pipe2

PlayerSnd_PipeCont:
	JMP PlayerSnd_PipeCont2

PRG028_A2FC:
	JMP PRG028_A21D	 ; Jump to PRG028_A21D

PlayerSnd_JumpCont:	; jump update comes here
	JMP PlayerSnd_FrogCont

PlayerSnd_Swim:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$0e	 
	STA SFX_Counter1 ; SFX_Counter1 = $0e
	LDY #$9c	 ; PAPU_RAMP1 
	LDX #$9e	 ; PAPU_CTL1
	LDA #66		 ; Note 66
	JSR Sound_Sq1_NoteOn	 

PlayerSnd_SwimCont:
	LDY SFX_Counter1 
	LDA SwimCTL1_LUT-1,Y	; SFX_Counter1 is used as an index into SwimCTL1_LUT; we subtract 1 because SFX_Counter1 must be at least 1
	STA PAPU_CTL1	 	; Store next swim CTL1 command
	CPY #$06	 ; 
	BNE PRG028_A325	 ; If SFX_Counter1 <> 6, jump to PRG028_A325
	LDA #$9e	 ;
	STA PAPU_FT1	 ; Update PAPU_FT1

PRG028_A325:
	BNE PlayerSnd_CounterUpd	 ; (technically always) jump to PlayerSnd_CounterUpd

PlayerSnd_Kick:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$0e	 ; 
	LDY #$cb	 ; PAPU_RAMP1
	LDX #$9f	 ; PAPU_CTL1
	STA SFX_Counter1 ; SFX_Counter1 = $0E
	LDA #68		 ; Note 68
	JSR Sound_Sq1_NoteOn	 ; Play sound!
	BNE PlayerSnd_CounterUpd

PlayerSnd_KickCont:
	LDY SFX_Counter1
	CPY #$08	 ; 
	BNE PRG028_A34A	 ; If SFX_Counter1 <> 8, go to PRG028_A34A
	LDA #$a0	 ; 
	STA PAPU_FT1	 ; Update register
	LDA #$9f	 ; 
	BNE PRG028_A34C	 ; (technically always) jump to PRG028_A34C

PRG028_A34A:
	LDA #$90	 

PRG028_A34C:
	STA PAPU_CTL1

PlayerSnd_CounterUpd:
	DEC SFX_Counter1 ; SFX_Counter1--
	BNE PRG028_A363	 ; If SFX_Counter1 <> 0, go to PRG028_A363 (do nothing)

	; Counter has dropped to zero!
PlayerSnd_Stop:
	LDX #$00	 	;
	STX SndCur_Player	; Clear Player sound hold
	LDX #$1e	 	; 
	STX PAPU_EN	 	; Disable square wave 1
	LDX #$1f
	STX PAPU_EN	 	; Enable every channel (ORANGE - except dmc??! we fixed this)

PRG028_A363:
	RTS		 ; Return

PlayerSnd_Pipe2:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$2f		
	STA SFX_Counter1	; SFX_Counter1 = $2F

PlayerSnd_PipeCont2:
	LDA SFX_Counter1	 
	LSR A		 ; 
	BCS PRG028_A382	 ; If SFX_Counter1 & 1, jump to PRG028_A382
	LSR A		 ; 
	BCS PRG028_A382	 ; If SFX_Counter1 & 2, jump to PRG028_A382
	AND #$02	 ; 
	BEQ PRG028_A382	 ; If !(SFX_Counter1 & 8), jump to PRG028_A382
	LDY #$91	 ; PAPU_RAMP1
	LDX #$9a	 ; PAPU_CTL1
	LDA #104	 ; Note 104
	JSR Sound_Sq1_NoteOn

PRG028_A382:
	JMP PlayerSnd_CounterUpd

	; the "1-up" sound
SndLev1_1upData:
	.byte $23, $2F, $35, $2A, $47, $54

	; the "power up" sound
SndLev1_PUpData:
	.byte $6A, $74, $6A, $64, $5C, $52, $5C, $52
	.byte $4C, $44, $66, $70, $66, $60, $58, $4E, $58, $4E, $48, $40, $56, $60, $56, $50
	.byte $48, $3E, $48, $3E, $38, $30, $30

SndLev1_PUpRiseData:
	.byte $7E, $3E, $40, $32, $7E, $40, $42, $34, $7E
	.byte $42, $44, $36, $7E, $44, $46, $38, $7E, $46, $48, $3A, $7E, $48, $4A, $3C, $7E
	.byte $4A, $4C, $3E, $7E, $4C, $4E

SndLev1_Coin2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$35	 ; SFX_Counter2 value
	LDX #$8d	 ; PAPU_CTL2
	BNE PRG028_A3D9	 ; (technically always) jump to PRG028_A3D9

SndLev1_Text2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$06	 ; SFX_Counter2 value
	LDX #$98	 ; PAPU_CTL2

PRG028_A3D9:
	STA SFX_Counter2
	LDY #$7f	 ; PAPU_RAMP2
	LDA #94		 ; Note 94
	JSR Sound_Sq2_NoteOn	 

SndLev1_Coin_Cont2:
	LDA SFX_Counter2
	CMP #$30	 
	BNE PRG028_A3EF	 ; If SFX_Counter2 <> $30, jump to PRG028_A3EF

	LDA #$54
	STA PAPU_FT2

PRG028_A3EF:
	BNE SndLev1_PUp_Cont2	 ; $A3EF 

SndLev1_Boom:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$20	  
	STA SFX_Counter2	  
	LDY #$94	  
	LDA #$1c	  
	BNE PRG028_A40C	 ; (technically always) jump to PRG028_A40C

SndLev1_Boom_Cont2:
	LDA SFX_Counter2	  
	CMP #$18	  
	BNE SndLev1_PUp_Cont2	  
	LDY #$93	  
	LDA #$34	  
	LDX #$9f	  
PRG028_A40C:
	JMP PRG028_A425	  

SndLev1_PUp:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$36	 
	STA SFX_Counter2	 ; SFX_Counter2 = $36

SndLev1_PUp_Cont:
	LDA SFX_Counter2
	LSR A		
	BCS SndLev1_PUp_Cont2	 ; If SFX_Counter2 & 1, jump to SndLev1_PUp_Cont2
	TAY		 ; Y = A
	LDA SndLev1_PUpData-1,Y	; As in other parts of sound code, -1 because SFX_Counter2 must be > 0
	LDX #$5d	 ; PAPU_CTL2
	LDY #$7f	 ; PAPU_RAMP2

PRG028_A425:
	JSR Sound_Sq2_NoteOn

SndLev1_PUp_Cont2:
	DEC SFX_Counter2
	BNE PRG028_A43C	 ; If SFX_Counter2 <> 0, jump to PRG028_A43C (RTS)

PRG028_A42D:

	; SndCur_Level1 = 0
	LDX #$00
	STX SndCur_Level1

	; Disable and re-enable square 2
	LDX #$0d
	STX PAPU_EN
	LDX #$0f
	STX PAPU_EN

PRG028_A43C:
	RTS		 ; Return

SndLev1_PUpRise:
	JMP SndLev1_PUpRise2

SndLev1_Coin:
	JMP SndLev1_Coin2

SndLev1_VineRise:
	JMP SndLev1_VineRise2

SndLev1_SuitLost:
	JMP SndLev1_SuitLost2

Sound_PlayLevel1:
	LDA SndCur_Level1
	AND #$40	 ; 
	BNE SndLev1_1upCont	 ; If currently playing level 1 sound is $40 1-up, jump to SndLev1_1up (overrides any new sounds!)

	LDY Sound_QLevel1
	BEQ PRG028_A47A	 ; If no Level 1 sound is queued, jump to PRG028_A47A

	BMI SndLev1_SuitLost	 ; If sound $80 (SND_LEVELPOOF) sound, jump to SndLev1_SuitLost

	; Since the input is a bit value ($01, $02, $04, ...), this will
	; decode it by continuously shifting to the right until we hit
	; a bit; this also incidentally provides a simple priority system.

	LSR Sound_QLevel1
	BCS SndLev1_Coin	 ; If sound $01 (SND_LEVELCOIN), jump to SndLev1_Coin
	LSR Sound_QLevel1
	BCS SndLev1_PUpRise	 ; If sound $02 (SND_LEVELRISE), jump to SndLev1_PUpRise
	LSR Sound_QLevel1
	BCS SndLev1_VineRise	 ; If sound $04 (SND_LEVELVINE), jump to SndLev1_VineRise
	LSR Sound_QLevel1
	BCS SndLev1_Boom	 ; If sound $08 (SND_LEVELBABOOM), jump to SndLev1_Boom
	LSR Sound_QLevel1
	BCS SndLev1_Text	 ; If sound $10 (SND_LEVELBLIP), jump to SndLev1_Text
	LSR Sound_QLevel1
	BCS SndLev1_PUp	 ; If sound $20 (SND_LEVELPOWER), jump to SndLev1_PUp
	LSR Sound_QLevel1
	BCS SndLev1_1up	 ; If sound $40 (SND_LEVEL1UP), jump to SndLev1_1up

PRG028_A47A:
	LDA SndCur_Level1
	BEQ PRG028_A496	 ; If no sound is playing, jump to PRG028_A496 (Do nothing)

	BMI SndLev1_SuitLost_Cont	 ; If sound (SND_LEVELPOOF) "lost suit" sound, jump to SndLev1_SuitLost_Cont
	LSR A		 
	BCS SndLev1_Coin_Cont	 ; If sound $01 (SND_LEVELCOIN), jump to SndLev1_Coin_Cont
	LSR A		
	BCS SndLev1_PUpRise_Cont	 ; If sound $02 (SND_LEVELRISE), jump to SndLev1_PUpRise_Cont
	LSR A		 
	BCS SndLev1_PUpRise_Cont	 ; If sound $04 (SND_LEVELVINE), jump to SndLev1_PUpRise_Cont
	LSR A		
	BCS SndLev1_Boom_Cont	 ; If sound $08 (SND_LEVELBABOOM), jump to SndLev1_Boom_Cont
	LSR A		
	BCS SndLev1_Text_Cont	 ; If sound $10 (SND_LEVELBLIP), jump to SndLev1_Text_Cont
	LSR A		 
	BCS SndLev1_PUp_Cont	 ; If sound $20 (SND_LEVELPOWER), jump to SndLev1_PUp_Cont
	LSR A		 
	BCS SndLev1_1upCont	 ; If sound $40 (SND_LEVEL1UP), jump to SndLev1_1upCont

PRG028_A496:
	RTS		 ; Return

SndLev1_SuitLost_Cont: 
	JMP SndLev1_SuitLost_Cont2

SndLev1_Text:
	JMP SndLev1_Text2

SndLev1_Coin_Cont:
SndLev1_Text_Cont:
	JMP SndLev1_Coin_Cont2

SndLev1_Boom_Cont:
	JMP SndLev1_Boom_Cont2

SndLev1_PUp_1up:
	JMP SndLev1_PUp_Cont2

SndLev1_1up:
	STY SndCur_Level1	 ; Store what level 1 sound we're playing
	LDA #$30
	STA SFX_Counter2	 ; SFX_Counter2 = $30

SndLev1_1upCont:
	LDA SFX_Counter2
	LDX #$03

PRG028_A4B3:	
	LSR A		 
	BCS SndLev1_PUp_1up	 ; If SFX_Counter2 & 1, jump to SndLev1_PUp_1up
	DEX		 ; X--
	BNE PRG028_A4B3	 ; If X > 0, loop

	TAY		 	; Y = A
	LDA SndLev1_1upData-1,Y	; As in other parts of sound code, -1 because SFX_Counter2 must be > 0
	STA PAPU_FT2	 	; Store this into PAPU_FT2

	LDX #$82	 	; PAPU_CTL2
	LDY #$7f	 	; PAPU_RAMP2
	JSR Sound2_XCTL_YRAMP	

	; PAPU_CT2 = 8
	LDA #$08
	STA PAPU_CT2

	JMP SndLev1_PUp_Cont2	 ; Jump to SndLev1_PUp_Cont2

SndLev1_PUpRise2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing

	LDA #$10
	BNE PRG028_A4DB	 ; Jump (technically always) to PRG028_A4DB

SndLev1_VineRise2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$20

PRG028_A4DB:
	STA SFX_Counter2	 ; Set SFX_Counter2

	LDA #$7f
	STA PAPU_RAMP2	 ;  [NES] Audio -> Square 2

	; SFX_Counter3 = 0
	LDA #$00
	STA SFX_Counter3

SndLev1_PUpRise_Cont:
	INC SFX_Counter3 ; SFX_Counter3++

	LDA SFX_Counter3
	LSR A	
	TAY		 ; Y = SFX_Counter3 >> 1
	CPY SFX_Counter2
	BEQ PRG028_A501	 ; If SFX_Counter3 / 2 = SFX_Counter2, jump to PRG028_A501 (PRG028_A42D)

	LDA #$9d
	STA PAPU_CTL2	 ;  [NES] Audio -> Square 2

	LDA SndLev1_PUpRiseData-1,Y	 ; As in other parts of sound code, -1 because SFX_Counter2 must be > 0
	JSR Sound_Sq2_NoteOn_NoPAPURAMP

	RTS		 ; Return

PRG028_A501:
	JMP PRG028_A42D	 ; Jump to PRG028_A42D

PRG028_A504:
	JMP PRG028_A47A	 ; Jump to PRG028_A47A

SndLev1_SuitLost2:
	LDY Sound_QLevel1
	CPY #SND_LEVELPOOF
	BNE PRG028_A512	 ; If this is not the "poof" sound, jump to PRG028_A512
 
	; "Poof" sound effect
	LDA #(SndLev1_DataPoof - SndLev1_Data)
	BNE PRG028_A529	 ; Jump (technically always) to PRG028_A529

PRG028_A512:
	CPY #SND_LEVELUNK
	BNE PRG028_A51A	 ; If not unknown / lost sound, jump to PRG028_A51A

	; Unknown / lost sound
	LDA #(SndLev1_DataUnk - SndLev1_Data)
	BEQ PRG028_A529	 ; Jump (technically always) to PRG028_A529

PRG028_A51A:
	CPY #SND_LEVELSHOE
	BNE PRG028_A522	 ; If not these sounds, jump to PRG028_A522

	; Lost shoe sound
	LDA #(SndLev1_DataLostShoe - SndLev1_Data)
	BNE PRG028_A529	 ; Jump (technically always) to PRG028_A529

PRG028_A522:
	LDA SndCur_Level1
	BNE PRG028_A504	 ; If any level 1 sounds are playing, jump to PRG028_A504

	; Tail wag
	LDA #(SndLev1_DataLongWag - SndLev1_Data)

PRG028_A529:
	STA SFX_Counter2	 ; Set SFX_Counter2 appropriately

	; Filter out sound selection
	TYA
	AND #(SND_LEVELPOOF | SND_LEVELTAILWAG | SND_LEVELSHOE)
	STY SndCur_Level1

SndLev1_SuitLost_Cont2:
	INC SFX_Counter2	 ; SFX_Counter2++

	LDY SFX_Counter2	 ; Y = SFX_Counter2

	LDA SndLev1_Data-1,Y	 ; Get data
	BEQ PRG028_A553	 ; If data = 0, jump to PRG028_A553
	BPL PRG028_A544	 ; If data > 0, jump to PRG028_A544

	; data < 0...

	; Store value -> SFX_Counter3
	;;STA SFX_Counter3
	JSR SFX_Counter3_Hook
	BNE SndLev1_SuitLost_Cont2	 ; Jump (technically always) to SndLev1_SuitLost_Cont2

PRG028_A544:
	LDX #$7f
	STX PAPU_RAMP2	 ;  [NES] Audio -> Square 2
	;JSR SoundEffect_Ramp2Hook
	;NOP
	;NOP

	LDX SFX_Counter3
	STX PAPU_CTL2	 ;  [NES] Audio -> Square 2

	JSR Sound_Sq2_NoteOn_NoPAPURAMP

	RTS		 ; Return

PRG028_A553:
	; SFX_Counter2 = 0
	LDA #$00
	STA SFX_Counter2

	JMP PRG028_A42D	 ; Jump to PRG028_A42D


SndLev1_Data:
SndLev1_DataUnk:
	.byte $9F, $30, $34, $36, $38, $9F, $3A, $3C, $3E, $40, $9A, $3A, $3C, $3E, $40, $9C ; $A55B - $A56A
	.byte $3A, $3C, $3E, $40, $96, $3A, $3C, $3E, $40, $98, $3A, $3C, $3E, $40, $00

SndLev1_DataPoof:
	.byte $9F
	.byte $2E, $2A, $26, $22, $9D, $2E, $2A, $7E, $7E, $9F, $30, $2E, $2A, $28, $9D, $30 ; $A57B - $A58A
	.byte $2E, $7E, $7E, $9F, $38, $34, $32, $30, $9D, $38, $34, $32, $30, $9A, $38, $34 ; $A58B - $A59A
	.byte $32, $30, $9C, $38, $34, $32, $30, $97, $38, $34, $32, $30, $98, $38, $34, $32 ; $A59B - $A5AA
	.byte $30, $94, $38, $34, $32, $30, $00

SndLev1_DataLostShoe:
	;.byte $9F, $42, $40, $7E, $7E, $9F, $46, $48, $7E ; $A5AB - $A5BA
	;.byte $7E, $9A, $4A, $4E, $50, $52, $96, $4E, $52, $54, $56, $00
	.byte $9A, $44, $D9, $42, $D7, $40, $D6, $3E
	.byte $9A, $46, $D9, $44, $D7, $42, $D6, $40
	.byte $9A, $48, $D9, $46, $D7, $44, $D6, $42, $00

SndLev1_DataLongWag:
	.byte $90, $7E, $7E, $97 ; $A5BB - $A5CA
	.byte $4C, $4E, $90, $7E, $7E, $95, $52, $54, $56, $58, $94, $52, $54, $56, $58, $93 ; $A5CB - $A5DA
	.byte $52, $54, $56, $58, $00

SndLev2_MarchData:
	.byte $55, $81, $AA, $02, $74, $B7, $A5, $04, $92, $A9, $08 ; $A5DB - $A5EA
	.byte $69, $58, $4A

SndLev2_BoomerangData:
	.byte $11, $61, $21, $51, $81, $21, $61, $A2, $23, $64, $A5, $76

SndLev2_SkidNFreq:
	.byte $01, $0E, $0E, $0D, $0B, $06, $0C, $0F, $0A, $09, $03, $0D, $08, $0D, $06

SndLev2_SkidTFreq:
	.byte $0C, $47, $49

SndLev2_Skid:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = 6
	LDA #$02
	STA SFX_Counter4

SndLev2_SkidCont:
	LDA SFX_Counter4
	TAY		 ; Y = SFX_Counter4

	LDA SndLev2_SkidTFreq,Y
	STA PAPU_TFREQ1	 ; [NES] Audio -> Triangle

	LDA #$18
	STA PAPU_TCR1	 ; [NES] Audio -> Triangle
	STA PAPU_TFREQ2	 ; [NES] Audio -> Triangle
	BNE PRG028_A64C	 ; Jump (technically always) to PRG028_A64C

SndLev2_Crumble:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $20
	LDA #$20
	STA SFX_Counter4

SndLev2_CrumbleCont:
	LDA SFX_Counter4
	LSR A	
	BCC PRG028_A64C	 ; Every other tick, jump to PRG028_A64C

	TAY		 ; SFX_Counter4 / 2 -> 'Y'
	LDX SndLev2_SkidNFreq,Y	 ; Get noise frequency
	LDA SndLev2_SkidNCtl,Y	 ; Get noise CTL value

PRG028_A641:

	; Set both
	STA PAPU_NCTL1
	STX PAPU_NFREQ1

	LDA #$18
	STA PAPU_NFREQ2	 ; [NES] Audio -> Noise Frequency reg #2

PRG028_A64C:
	DEC SFX_Counter4 ; SFX_Counter4--
	BNE PRG028_A660	 ; If SFX_Counter4 <> 0, jump to PRG028_A660 (RTS)

	LDA #$f0
	STA PAPU_NCTL1	 ; [NES] Audio -> Noise control reg
	LDA #$00
	STA PAPU_TCR1	 ; [NES] Audio -> Triangle

	; SndCur_Level2 = 0
	LDA #$00
	STA SndCur_Level2

PRG028_A660:
	RTS		 ; Return

Sound_PlayLevel2: 
	LDA SndCur_Level2
	CMP #SND_LEVELAIRSHIP
	BNE PRG028_A66B	 ; If this is not the airship sound, jump to PRG028_A66B

	JMP SndLev2_AirshipCont	 ; Jump to SndLev2_AirshipCont

PRG028_A66B:

	; This is here because sounds $20 and $40 are undefined;
	; if they were to be defined, this could sit down below...
	LDA SndCur_Level2
	BMI SndLev2_SkidCont	 ; If sound $80 (SND_LEVELSKID) is currently playing, jump to SndLev2_SkidCont (overrides queue)

	LDY Sound_QLevel2
	BEQ PRG028_A690	 ; If no level 2 sound is queued, jump to PRG028_A690

	BMI SndLev2_Skid	 ; If sound $80 (SND_LEVELSKID), jump to SndLev2_Skid

	; Since the input is a bit value ($01, $02, $04, ...), this will
	; decode it by continuously shifting to the right until we hit
	; a bit; this also incidentally provides a simple priority system.

	LSR Sound_QLevel2
	BCS SndLev2_Crumble	 ; If sound $01 (SND_LEVELCRUMBLE), jump to SndLev2_Crumble
	LSR Sound_QLevel2
	BCS SndLev2_Flame	 ; If sound $02 (SND_LEVELFLAME), jump to SndLev2_Flame
	LSR Sound_QLevel2
	BCS SndLev2_Boomerang	 ; If sound $04 (SND_BOOMERANG), jump to SndLev2_Boomerang
	LSR Sound_QLevel2
	BCS SndLev2_Airship	 ; If sound $08 (SND_LEVELAIRSHIP), jump to SndLev2_Airship
	LSR Sound_QLevel2
	BCS SndLev2_March	 ; If sound $10 (SND_LEVELMARCH), jump to SndLev2_March

	; NOTE: Level 2 set sounds $20 and $40 are undefined!


PRG028_A690:

	; No sound is queued...

	LDA SndCur_Level2
	BEQ PRG028_A6A4	 ; If no sound is playing, jump to PRG028_A6A4 (RTS)
	LSR A
	BCS SndLev2_CrumbleCont	 ; If sound $01 (SND_LEVELCRUMBLE), jump to SndLev2_CrumbleCont
	LSR A
	BCS SndLev2_FlameCont	 ; If sound $02 (SND_LEVELFLAME), jump to SndLev2_FlameCont
	LSR A
	BCS SndLev2_BoomerangCont	 ; If sound $04 (SND_BOOMERANG), jump to SndLev2_BoomerangCont
	LSR A
	BCS SndLev2_AirshipCont	 ; If sound $08 (SND_LEVELAIRSHIP), jump to SndLev2_AirshipCont
	LSR A
	BCS SndLev2_MarchCont	 ; If sound $10 (SND_LEVELMARCH), jump to SndLev2_MarchCont

PRG028_A6A4:
	RTS		 ; Return

SndLev2_Flame:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $40
	LDA #$40
	STA SFX_Counter4

SndLev2_FlameCont:
	LDA SFX_Counter4
	LSR A
	TAY		 ; Y = SFX_Counter4 / 2

	LDX #$0f	 ; X = $F
	LDA PRG028_A709-1,Y

PRG028_A6B7:
	BNE PRG028_A641	 ; If data <> 0, jump to PRG028_A641

SndLev2_March:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $E
	LDA #$0e
	STA SFX_Counter4

SndLev2_MarchCont:
	LDA SFX_Counter4
	TAY		 ; Y = SFX_Counter4

	; Lower 4 bits OR'd with $10 -> 'X'
	LDA SndLev2_MarchData,Y
	AND #$0f
	ORA #$10
	TAX

	; Upper 4 bits shifted down, OR'd with $10
	LDA SndLev2_MarchData,Y
	LSR A
	LSR A
	LSR A
	LSR A
	ORA #$10

PRG028_A6D6:
	BNE PRG028_A6B7	 ; Jump (technically always) to PRG028_A6B7

SndLev2_Boomerang:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $C
	LDA #$0c
	STA SFX_Counter4

SndLev2_BoomerangCont:
	LDA SFX_Counter4
	TAY		 ; Y = SFX_Counter4

	; Lower 4 bits OR'd with $10 -> 'X'
	LDA SndLev2_BoomerangData,Y
	AND #$0f
	ORA #$10
	TAX

	; Upper 4 bits shifted down, OR'd with $10
	LDA SndLev2_BoomerangData,Y
	LSR A
	LSR A
	LSR A
	LSR A
	ORA #$10

PRG028_A6F5:
	BNE PRG028_A6D6	 ; Jump (technically always) to PRG028_A6D6

SndLev2_Airship:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $40
	LDA #$40
	STA SFX_Counter4

SndLev2_AirshipCont:
	LDA SFX_Counter4
	LSR A
	LSR A
	TAX		 ; X = SFX_Counter4 >> 2

	ORA #$10	 ; Value OR'd with $10
	BNE PRG028_A6F5	 ; Jump (technically always) to PRG028_A6F5


PRG028_A709:
	.byte $15, $16, $16, $17, $17, $18, $19, $19, $1A, $1A, $1C, $1D, $1D, $1E, $1E, $1F ; $A709 - $A718
	.byte $1F, $1F, $1F, $1E, $1D, $1C, $1E, $1F, $1F, $1E, $1D, $1C, $1A, $18, $16, $14 ; $A719 - $A728

SndLev2_SkidNCtl:
	.byte $15, $16, $16, $17, $17, $18, $19, $19, $1A, $1A, $1C, $1D, $1D, $1E, $1E, $1F ; SndLev2_SkidNCtl - $A738
	.byte $A5, $8B, $C9, $03, $F0, $10, $C0


	; Each segment header is 7 bytes long:
MusSeg .macro
   .word \1	; Music Rests table pointer
   .word \2	; Address of music segment data (all tracks this segment, offsets to follow, except implied Square 2 zero)
   .word \3	; Triangle track pointer ($00 means disabled)
   .byte \4	; Square 1 track starting offset (cannot be disabled)
   .word \5	; Noise track pointer (hi [2nd] byte zero means disabled)
   .word \6	; DCM track pointer (hi [2nd] byte zero means disabled)
   .endm	; Square 2 cannot be disabled and always starts at offset $00

M12ASH .func \1-Music_Set1_Set2A_Headers	; "Music Set 1/2A Segment Header Offset"

Music_Set1_Set2A_IndexOffs:
	; Index 0 - 7 are Set 1 songs, accessed by bit weight
	.byte M12ASH(MS1_01SegHedr), M12ASH(MS1_02SegHedr), M12ASH(MS1_04SegHedr), M12ASH(MS1_08SegHedr)	; Index $00-$03
	.byte M12ASH(MS1_10SegHedr), M12ASH(PooOrb_Hdr), M12ASH(MS1_40SegHedr), M12ASH(MS1_80SegHedr)	; Index $04-$07

	; 8+ are Set 2A
	; $08 - $11 are Mother - Polyanna (Overworld)
	.byte M12ASH(MotherHedr1)	; $08
	.byte M12ASH(MotherHedr2)
	.byte M12ASH(MotherHedr1)
	.byte M12ASH(MotherHedr2)
	.byte M12ASH(MotherHedr3)
	.byte M12ASH(MotherHedr4)
	.byte M12ASH(MotherHedr5)
	.byte M12ASH(MotherHedr6)
	.byte M12ASH(MotherHedr7)
	.byte M12ASH(MotherHedr8)	; $11


Music_Set1_Set2A_Headers:

MS1_01SegHedr:			;MusSeg Music_RestH_LUT, M12ASegData14, $0026, $11, $0000, M12ASegData14PCM
						;	  sq1, tri, nse, dpcm
MS1_02SegHedr:			;MusSeg Music_RestH_LUT, M12ASegData18, $0020, $12, $0000, $0000
; Boss victory
MS1_04SegHedr:			;MusSeg Music_RestH_LUT, M12ASegData15, $0021, $11, $0000, M12ASegData15PCM
						MusSeg PooOrb_R, PooOrb, $0000, $00, $0000, PooOrbPCM
MS1_08SegHedr:			;MusSeg Music_RestH_LUT, M12ASegData19, $004D, $27, $0000, $0000
MS1_10SegHedr:			;MusSeg Music_RestH_LUT, M12ASegData24, $006F, $4C, $0000, M12ASegData24PCM
PooOrb_Hdr:				MusSeg PooOrb_R, PooOrb, $0000, $00, $0000, PooOrbPCM
MS1_40SegHedr:			;MusSeg Music_RestH_LUT, M12ASegData13, $0035, $18, $0000, $0000

; MS1_80SegHedr is the "stop music" request; have to look into this
; a little bit more to figure out how it works
MS1_80SegHedr:	.byte $60
		.word M12ASegData17		; Just lands at a $00 stop
		.byte $00			; Incomplete header??

MotherHedr1:	MusSeg Mother_R1, Mother_1, Mother_Tri1, $0B, Mother_Nse1, Mother_PCM1
MotherHedr2:	MusSeg Mother_R2, Mother_2, Mother_Tri2, $0B, Mother_Nse2, Mother_PCM2
MotherHedr3:	MusSeg Mother_R3, Mother_3, Mother_Tri3, $0D, Mother_Nse3, Mother_PCM3
MotherHedr4:	MusSeg Mother_R4, Mother_4, Mother_Tri4, $0C, Mother_Nse4, Mother_PCM4
MotherHedr5:	MusSeg Mother_R5, Mother_5, Mother_Tri5, $10, Mother_Nse5, Mother_PCM5
MotherHedr6:	MusSeg Mother_R6, Mother_6, Mother_Tri6, $0D, Mother_Nse6, Mother_PCM6
MotherHedr7:	MusSeg Mother_R7, Mother_7, Mother_Tri7, $12, Mother_Nse7, Mother_PCM7
MotherHedr8:	MusSeg Mother_R8, Mother_8, Mother_Tri8, $17, Mother_Nse8, Mother_PCM8


	; Music in Set 2A is played by "index", which is a segment of music.
	; The index always advances, though what that index actually represents
	; may be a reused segment of music.

	; These three LUTs are to be read vertically for each Set 2A song to
	; be played ($1, $2, $3, ... $F), so that song $1 uses a start
	; index of $08, an end index of $09, and a loop index of $08.

Music_Set2A_Starts:
	.byte $08, $00, $0A, $0B, $0D, $0E, $10, $11, $13, $14, $15, $16, $18, $1C, $1D, $1E

Music_Set2A_Ends:
	.byte $11, $0A, $0C, $0D, $0F, $10, $12, $13, $14, $15, $17, $1B, $1C, $1D, $2B

Music_Set2A_Loops:
	.byte $08, $0A, $0B, $0D, $0F, $10, $11, $13, $14, $15, $17, $18, $1C, $1D, $23

M12ASegData1A:
	.byte $D8, $68, $60, $60, $5A, $50, $4C, $68, $60, $60, $5A, $50, $4C, $68, $60 ; $A899 - $A8A8
	.byte $60, $5A, $50, $4C

M12ASegData17:
	.byte $00


PooOrb:	; [ORANGE] This is Poo's OOORRRBB sound, replacing the end-level fanfare
	.byte $8F, $7E, $7E, $00
PooOrbPCM:
	.byte $8F, $01, $8F, $02, $00

Mother_1:
	.byte $B0, $3C, $42, $50, $BA, $4A, $B2, $4C, $BA, $7E, $00
	.byte $DA, $7E, $3C, $42, $4C, $7E, $38, $42, $4A, $7E, $34, $3C, $46, $7E, $34, $3C
	.byte $42
Mother_Tri1:
	.byte $B9, $34, $B1, $7E, $B9, $34, $B3, $7E, $B9, $32, $B1, $7E, $B9, $32, $B3, $7E
	.byte $B9, $2E, $B1, $7E, $B9, $2E, $B3, $7E, $B9, $2A, $B1, $7E, $B9, $2A, $B3, $7E
Mother_Nse1:
	.byte $B4, $03, $BD, $01, $B4, $03, $BD, $01, $B4, $03, $BD, $01, $B4, $03, $B6, $01
	.byte $C4, $03, $CB, $01, $C4, $03, $CD, $01, $C4, $03, $CD, $01, $C4, $03, $CD, $01
	.byte $C4, $03, $C6, $01, $C5, $03, $C7, $01, $00
Mother_PCM1:
	.byte $B0, $03, $BC, $04, $B8, $03, $BA, $03, $03, $B0, $04, $03, $BC, $04, $B8, $03
	.byte $BA, $03, $03, $B0, $04

Mother_2:
	.byte $B0, $46, $4C, $54, $B9, $4C, $B1, $42, $BA, $3E, $00
	.byte $D9, $3E, $46, $4C, $3E, $3C, $42, $4C, $3C, $3A, $42, $48, $42, $38, $42, $32
	.byte $42
Mother_Tri2:
	.byte $B8, $26, $B2, $7E, $B8, $26, $B3, $7E, $B8, $24, $B2, $7E, $B8, $24, $B3, $7E
	.byte $B8, $22, $B2, $7E, $B8, $22, $B3, $7E, $B8, $2A, $B2, $7E, $B8, $2A, $B3, $7E
Mother_Nse2:
	.byte $B4, $03, $BD, $01, $B5, $03, $BE, $01, $B5, $03, $BE, $01, $B5, $03, $B6, $01
	.byte $B5, $03, $BB, $01, $B5, $03, $BE, $01, $B5, $03, $BE, $01, $B5, $03, $BE, $01
	.byte $B5, $03, $B6, $01, $B5, $03, $B6, $01, $00
Mother_PCM2:
	.byte $B0, $03, $BC, $04, $B7, $03, $B9, $03, $03, $B0, $04, $03, $BC, $04, $B7, $03
	.byte $B9, $03, $03, $B0, $04

Mother_3:
	.byte $B9, $3C, $38, $34, $38, $B0, $3C, $46, $4C, $54, $B1, $5E, $00
	.byte $D9, $7E, $2E, $34, $3C, $7E, $2C, $34, $3C, $7E, $2A, $34, $3C, $7E, $28, $2E
	.byte $34
Mother_Tri3:
	.byte $B5, $2E, $7E, $B4, $2E, $B6, $7E, $B4, $2E, $B6, $7E, $B4, $2E, $B6, $7E, $B4
	.byte $2C, $B6, $7E, $B4, $2C, $B6, $7E, $B4, $2C, $B6, $7E, $B4, $2C, $B6, $7E, $B4
	.byte $2A, $B6, $7E, $B5, $2A, $7E, $2A, $7E, $B4, $2A, $B6, $7E, $B4, $28, $B6, $7E
	.byte $B4, $28, $B6, $7E, $B4, $28, $B6, $7E, $B4, $28, $B6, $7E
Mother_Nse3:
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B3, $03, $B7, $01, $B3, $03, $B7, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $00
Mother_PCM3:
	.byte $B0, $03, $B9, $04, $03, $B0, $03, $04, $03, $B9, $04, $03, $B0, $03, $04

Mother_4:
	.byte $B8, $4C, $4A, $46, $4A, $4C, $4A, $46, $4A, $B0, $4C, $00
	.byte $D8, $46, $42, $3E, $42, $42, $42, $3E, $42, $D0, $3C
Mother_Tri4:
	.byte $B3, $26, $B5, $7E, $B3, $26, $B5, $7E, $B4, $26, $7E, $26, $7E, $2A, $7E, $B3
	.byte $2A, $B5, $7E, $B3, $2A, $B5, $7E, $B3, $2A, $B5, $7E, $B0, $1C
Mother_Nse4:
	.byte $B2, $03, $B6, $01, $B2, $03, $B6, $01, $B2, $03, $B6, $01, $B2, $03, $B6, $01
	.byte $B2, $03, $B6, $01, $B2, $03, $B6, $01, $B2, $03, $B6, $01, $B2, $03, $B6, $01
	.byte $B2, $03, $B6, $01, $B2, $03, $B6, $01, $B2, $03, $B6, $01, $B2, $03, $B7, $01
	.byte $00
Mother_PCM4:
	.byte $B1, $03, $B8, $04, $03, $B1, $03, $04, $03, $B8, $04, $03, $B4, $04, $04, $B8
	.byte $04, $04, $04

Mother_5:
	.byte $B8, $42, $42, $42, $7E, $B5, $42, $7E, $B8, $3C, $38, $B1, $34, $B8, $7E, $00
	.byte $D8, $32, $1A, $24, $D9, $32, $D0, $1A, $D8, $34, $1C, $26, $D9, $34, $D0, $1C
Mother_Tri5:
	.byte $B7, $24, $B2, $7E, $B7, $24, $B3, $7E, $B7, $26, $B2, $7E, $B7, $26, $B3, $7E
Mother_Nse5:
	.byte $B4, $03, $B6, $01, $B4, $03, $B6, $01, $B4, $03, $B6, $01, $B4, $03, $BA, $01
	.byte $B4, $03, $B6, $01, $B4, $03, $BA, $01, $B4, $03, $B6, $01, $B4, $03, $B6, $01
	.byte $B4, $03, $B6, $01, $B4, $03, $BA, $01, $B4, $03, $B6, $01, $B4, $03, $BA, $01
	.byte $00
Mother_PCM5:
	.byte $B0, $03, $B8, $04, $B0, $03, $B8, $04, $B0, $04, $03, $B8, $04, $B0, $03, $B8
	.byte $04, $B0, $04

Mother_6:
	.byte $B9, $42, $42, $42, $7E, $50, $4C, $4A, $B0, $4C, $B9, $7E, $00
	.byte $D9, $32, $1A, $24, $2A, $32, $12, $20, $2A, $24, $12, $1C, $24, $2A, $1C
Mother_Tri6:
	.byte $B8, $24, $B1, $7E, $B8, $24, $B2, $7E, $B8, $2A, $B1, $7E, $B8, $2A, $B2, $7E
	.byte $B8, $34, $B1, $7E, $B8, $34, $B2, $7E, $B8, $34, $BA, $7E
Mother_Nse6:
	.byte $B3, $03, $B6, $01, $B4, $03, $B7, $01, $B4, $03, $B7, $01, $B4, $03, $B7, $01
	.byte $B4, $03, $B7, $01, $B4, $03, $B7, $01, $B4, $03, $B7, $01, $B4, $03, $B7, $01
	.byte $B4, $03, $B7, $01, $B4, $03, $B7, $01, $B4, $03, $B7, $01, $B4, $03, $B7, $01
	.byte $B4, $03, $BB, $01, $00
Mother_PCM6:
	.byte $B0, $03, $B9, $04, $03, $B0, $03, $04, $03, $B9, $04, $03, $03, $04

Mother_7:
	.byte $BA, $46, $4A, $4C, $4A, $46, $4A, $4C, $4A, $46, $4A, $4C, $4A, $46, $4A, $4C
	.byte $7E, $00
	.byte $DA, $24, $2A, $46, $3E, $34, $3E, $42, $3C, $D0, $34, $DA, $3E, $34, $2E, $34
	.byte $42, $3C
Mother_Tri7:
	.byte $B9, $34, $B1, $7E, $B4, $26, $B6, $7E, $B4, $26, $B6, $7E, $B5, $26, $7E, $26
	.byte $7E, $B4, $24, $B6, $7E, $B4, $24, $B6, $7E, $B4, $24, $B6, $7E, $B4, $24, $B6
	.byte $7E, $B4, $20, $B6, $7E, $B4, $20, $B6, $7E, $B4, $20, $B6, $7E, $B4, $20, $B6
	.byte $7E, $B5, $24, $7E, $24, $7E, $7E, $7E
Mother_Nse7:
	.byte $B3, $02, $B7, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B3, $03, $B7, $01
	.byte $B3, $03, $B7, $01, $B3, $03, $B7, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $00
Mother_PCM7:
	.byte $B0, $04, $03, $BA, $04, $03, $B0, $03, $04, $03, $BA, $04, $03, $B0, $03

Mother_8:
	.byte $BA, $42, $42, $4C, $4A, $46, $4A, $4C, $4A, $46, $4A, $4C, $4C, $4C, $4C, $54
	.byte $B0, $4C, $B1, $4C, $BA, $7E, $00
	.byte $D0, $34, $DA, $46, $3E, $34, $3E, $42, $3C, $D0, $34, $DA, $46, $46, $46, $46
	.byte $4C, $D0, $3E, $D1, $3C, $DA, $7E
Mother_Tri8:
	.byte $B4, $24, $B6, $7E, $B4, $24, $B6, $7E, $B4, $26, $B6, $7E, $B4, $26, $B6, $7E
	.byte $B4, $26, $B6, $7E, $B4, $26, $B6, $7E, $B4, $24, $B6, $7E, $B5, $24, $7E, $24
	.byte $7E, $24, $7E, $B4, $20, $B6, $7E, $B4, $20, $B6, $7E, $B4, $20, $B6, $7E, $B4
	.byte $20, $B6, $7E, $B4, $2A, $B6, $7E, $B4, $2A, $B6, $7E, $B4, $2A, $B6, $7E, $B5
	.byte $2A, $7E, $B1, $1C
Mother_Nse8:
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B3, $03, $B7, $01
	.byte $B3, $03, $B7, $01, $B3, $03, $B7, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01
	.byte $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B8, $01, $B2, $03, $B9, $01
	.byte $00
Mother_PCM8:
	.byte $B0, $04, $03, $BA, $04, $03, $B0, $03, $04, $03, $BA, $04, $03, $B0, $03, $04
	.byte $03, $BA, $04, $03, $B0, $03, $B5, $04, $04, $BA, $04

M12ASegData0F:
	.byte $D8, $6E, $5E, $66, $5E, $6E, $5E, $66, $6A, $70, $60, $68, $60, $70, $60, $68 ; $B0C9 - $B0D8
	.byte $6C, $00, $D4, $7E, $D8, $56, $56, $56, $56, $56, $56, $56, $56, $58, $58, $58 ; $B0D9 - $B0E8
	.byte $58, $58, $58, $58, $58, $9C, $7E, $7E, $7E, $7E, $9C, $01, $89, $01, $8D, $02 ; $B0E9 - $B0F8
	.byte $02, $02, $8A, $01, $00, $8A, $7E, $01, $89, $01, $8D, $03, $03, $03, $8A, $7E ; $B0F9 - $B108
	.byte $00

M12ASegData10:
	.byte $D2, $7E, $7E, $30, $36, $7E, $DB, $3A, $D2, $7E, $7E, $7E, $DD, $3A, $3C ; $B109 - $B118
	.byte $D2, $3A, $7E, $36, $30, $7E, $2C, $00, $D2, $7E, $7E, $26, $2C, $7E, $DB, $30 ; $B119 - $B128
	.byte $D2, $7E, $7E, $7E, $DD, $30, $32, $D2, $30, $7E, $2C, $26, $7E, $22

M12ASegData11:
	.byte $D2, $7E ; $B129 - $B138
	.byte $7E, $30, $36, $7E, $DB, $3A, $D2, $7E, $7E, $7E, $92, $48, $4C, $7E, $98, $4E ; $B139 - $B148
	.byte $82, $7E, $00, $D2, $7E, $7E, $26, $2C, $7E, $DB, $30, $D2, $7E, $7E, $7E, $92 ; $B149 - $B158
	.byte $3E, $42, $7E, $98, $44, $82, $7E, $D2, $7E, $7E, $30, $36, $7E, $D9, $3A, $7E ; $B159 - $B168
	.byte $D2, $7E, $8C, $7E, $7E, $88, $02, $82, $06, $01, $02, $88, $02, $82, $06, $01 ; $B169 - $B178
	.byte $02, $88, $02, $82, $06, $01, $02, $88, $02, $82, $06, $01, $02, $00, $88, $01 ; $B179 - $B188
	.byte $86, $7E, $88, $7E, $82, $7E, $88, $03, $7E, $03, $7E, $03, $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INSTRUMENT PATCHES
; For music playback:
; These define values for a given patch value and note length, which properly
; configure square wave generators for a given note length.  Note that the PatL
; sets are used when the current track rest rate is >= 19, otherwise the PatS
; values are used in place.  These tables just define bytes supplied to the
; respective PAPU_CTLx register to configure the waveform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PatL1:	.byte $90, $92, $94, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $96, $96, $15, $17, $58, $1A

PatS1:	.byte $90, $92, $94, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $96, $96, $15, $17, $58, $1A

PatL2:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50
	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50
	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $51, $51, $51, $51, $51, $51
	.byte $52, $52, $52, $53, $53, $53, $54, $54, $55, $55, $56, $56, $57, $58, $59, $1A

PatS2:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $51, $51, $51, $52, $52
	.byte $53, $54, $55, $56, $57, $59, $1A

PatL3:	.byte $90, $91, $91, $91, $92, $92, $92, $93, $93, $94, $94, $94, $94, $95, $95, $95
	.byte $95, $96, $96, $96, $97, $97, $97, $97, $97, $97, $97, $98, $98, $98, $98, $98
	.byte $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98
	.byte $98, $98, $98, $98, $98, $98, $98, $98, $99, $99, $99, $9A, $9A, $99, $98, $97

PatS3:	.byte $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $91, $91, $91, $93, $95
	.byte $97, $98, $99, $9A, $9A, $99, $98

	.byte $97	; ?? A mistake?

PatL4:	.byte $94, $95, $95, $95, $95, $95, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96
	.byte $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96
	.byte $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96
	.byte $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $97, $97, $97, $98, $98, $98

PatS4:	.byte $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90
	.byte $90, $90, $97, $97, $98, $98, $98

PatS5:	.byte $51, $51, $52, $52, $53, $53, $53, $54, $54, $55, $56, $57, $57, $57, $57, $56
	.byte $56, $56, $55, $55, $54, $53, $53

PatL5:	.byte $51, $51, $51, $51, $51, $51, $52, $52, $52, $52, $52, $52, $52, $52, $52, $52
	.byte $52, $52, $52, $52, $52, $53, $53, $53, $53, $53, $54, $54, $54, $54, $54, $54
	.byte $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $56, $56, $56, $56, $57, $57
	.byte $57, $57, $57, $57, $57, $57, $57, $57, $56, $56, $56, $55, $55, $54, $53, $53

PatS6:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $51, $51, $52, $53
	.byte $54, $55, $56, $57, $58, $59, $5A

PatL6:	.byte $50, $50, $50, $51, $51, $51, $51, $51, $51, $51, $51, $51, $52, $52, $52, $53
	.byte $50, $50, $51, $51, $51, $51, $52, $52, $52, $52, $53, $53, $53, $54, $54, $55
	.byte $50, $51, $51, $52, $52, $52, $53, $53, $53, $54, $54, $55, $55, $56, $56, $57
	.byte $51, $52, $52, $52, $53, $53, $54, $54, $55, $55, $56, $56, $57, $58, $59, $5A


PatL8:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50 
	.byte $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51
	.byte $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51
	.byte $51, $51, $51, $51, $51, $51, $52, $53, $54, $55, $56, $57, $58, $19, $DA, $9B 

PatS8:	.byte $50, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $52, $53, $54
	.byte $55, $56, $57, $58, $19, $DA, $9B

	.byte $15, $07, $C8, $E8, $E0, $03, $D0, $F4

M2BSH .func \1-Music_Set2B_Headers	; "Music Set 2B Segment Header Offset"


	; Each "index" of music is tied to a header of a "segment" of music.  Some segments are
	; reused where repetitious musical notes exist.  The segment headers are apparently not
	; stored in any particular order.  This table connects an index to a header:
Music_Set2B_IndexOffs:
	; TGL
	.word TGLHedr4			; $00 small intro (forced due to zero index, where 0 loop ends the segment)
	.word TGLHedr1
	.word TGLHedr2
	.word TGLHedr3
	.word TGLHedr4
	.word TGLHedr5
	.word TGLHedr6			; $06
	; Castlevania - Vampire
	.word CVampireHedr1		; $07
	.word CVampireHedr2
	.word CVampireHedr3
	.word CVampireHedr4
	.word CVampireHedr5
	.word CVampireHedr6
	.word CVampireHedr7
	.word CVampireHedr8		; $0E
	; Gradius II - Dead End
	.word G2Hedr1			; $0F
	.word G2Hedr2
	.word G2Hedr1
	.word G2Hedr2
	.word G2Hedr3
	.word G2Hedr4
	.word G2Hedr3
	.word G2Hedr5			; $16
	; Metal Gear
	.word MGHedr1			; $17
	.word MGHedr2
	.word MGHedr3
	.word MGHedr4
	.word MGHedr5
	.word MGHedr6
	.word MGHedr5
	.word MGHedr7
	.word MGHedr8			; $1F
	.word MGHedr9			; $20
	.word MGHedr8			; $21
	.word MGHedrA			; $22
	.word MGHedrB			; $23
	.word MGHedrC			; $24
	.word MGHedrD			; $25
	.word MGHedrE			; $26


Music_Set2B_Headers:
	; The following is all of the segment headers for Set 2B music.
	; Tempo, Track Base Offset, Triangle offset, Square 1 offset, Noise offset, DCM offset (Square 2 is always assumed @ 0)
	; Note that Triangle, Noise, and DCM tracks are allowed to be disabled by using an offset of 0, but Squares 1/2 are not.
	; Of course, this wouldn't be hard to implement or anything, it's just the way it was coded...

; TGL
TGLHedr1:	MusSeg TGL1_Rests1, TGL1_1, TGL1_Tri1, $42, TGL1_Nse1, $0000
TGLHedr2:	MusSeg TGL1_Rests1, TGL1_2, TGL1_Tri2, $42, TGL1_Nse2, $0000
TGLHedr3:	MusSeg TGL1_Rests2, TGL1_3, TGL1_Tri3, $56, TGL1_Nse3, $0000
TGLHedr4:	MusSeg TGL1_Rests3, TGL1_4, TGL1_Tri4, $44, TGL1_Nse4, $0000
TGLHedr5:	MusSeg TGL1_Rests4, TGL1_5, TGL1_Tri5, $42, TGL1_Nse5, $0000
TGLHedr6:	MusSeg TGL1_Rests4, TGL1_6, TGL1_Tri6, $42, TGL1_Nse6, $0000

; Castlevania
CVampireHedr1:	MusSeg CVampire_R1, CVampire1, CVampire1_Tri, $18, CVampire1_Nse, $0000
CVampireHedr2:	MusSeg CVampire_R2, CVampire2, CVampire2_Tri, $1E, CVampire2_Nse, $0000
CVampireHedr3:	MusSeg CVampire_R3, CVampire3, CVampire3_Tri, $25, CVampire3_Nse, $0000
CVampireHedr4:	MusSeg CVampire_R4, CVampire4, CVampire4_Tri, $23, CVampire4_Nse, $0000
CVampireHedr5:	MusSeg CVampire_R5, CVampire5, CVampire5_Tri, $2F, CVampire5_Nse, $0000
CVampireHedr6:	MusSeg CVampire_R5, CVampire6, CVampire6_Tri, $31, CVampire6_Nse, $0000
CVampireHedr7:	MusSeg CVampire_R6, CVampire7, CVampire7_Tri, $29, CVampire7_Nse, $0000
CVampireHedr8:	MusSeg CVampire_R7, CVampire8, CVampire8_Tri, $29, CVampire8_Nse, $0000

; Gradius II
G2Hedr1:		MusSeg G2_R1, Gradius2_1, Gradius2_Tri1, $37, Gradius2_Nse1, $0000
G2Hedr2: 		MusSeg G2_R2, Gradius2_2, Gradius2_Tri2, $35, Gradius2_Nse2, $0000
G2Hedr3:		MusSeg G2_R3, Gradius2_3, Gradius2_Tri3, $24, Gradius2_Nse3, $0000
G2Hedr4:		MusSeg G2_R4, Gradius2_4, Gradius2_Tri4, $1A, Gradius2_Nse4, $0000
G2Hedr5:		MusSeg G2_R5, Gradius2_5, Gradius2_Tri5, $14, Gradius2_Nse5, $0000

; Metal Gear
MGHedr1:		MusSeg MG_R1, MG_1, MG_Tri1, $12, MG_Nse1, MG_PCM1
MGHedr2:		MusSeg MG_R23, MG_2, MG_Tri2, $12, MG_Nse23, MG_PCM23
MGHedr3:		MusSeg MG_R23, MG_3, MG_Tri3, $12, MG_Nse23, MG_PCM23
MGHedr4:		MusSeg MG_R4, MG_4, MG_Tri4, $11, MG_Nse4, MG_PCM4
MGHedr5:		MusSeg MG_R5, MG_5, MG_Tri5, $38, MG_Nse5, MG_PCM5
MGHedr6:		MusSeg MG_R6, MG_6, MG_Tri6, $17, MG_Nse6, MG_PCM6
MGHedr7:		MusSeg MG_R7, MG_7, MG_Tri7, $1A, MG_Nse7, MG_PCM7
MGHedr8:		MusSeg MG_R8, MG_8, MG_Tri8, $26, MG_Nse8, MG_PCM8
MGHedr9:		MusSeg MG_R9, MG_9, MG_Tri9, $0D, MG_Nse9, MG_PCM9
MGHedrA:		MusSeg MG_RA, MG_A, MG_TriA, $0E, MG_NseA, MG_PCMA
MGHedrB:		MusSeg MG_RBC, MG_B, MG_TriB, $11, MG_NseBCD, MG_PCMBC
MGHedrC:		MusSeg MG_RBC, MG_C, MG_TriC, $11, MG_NseBCD, MG_PCMBC
MGHedrD:		MusSeg MG_RD, MG_D, MG_TriD, $11, MG_NseBCD, MG_PCMD
MGHedrE:		MusSeg MG_RE, MG_E, MG_TriE, $1C, MG_NseE, MG_PCME


	; Music in Set 2B is played by "index", which is a segment of music.
	; The index always advances, though what that index actually represents
	; may be a reused segment of music.

	; These three LUTs are to be read vertically for each Set 2B song to
	; be played ($10, $20, $30, ... $C0), so that song $10 uses a start
	; index of $00, an end index of $06, and a loop index of $01.
Music_Set2B_Starts:
	.byte $17, $07, $0F, $0C, $0F, $13, $15, $1B, $1E, $1B, $27, $2C

Music_Set2B_Ends:
	.byte $26, $0E, $16, $0E, $12, $14, $1A, $1D, $26, $1D, $2B, $2C

Music_Set2B_Loops:
	.byte $17, $07, $0F, $0C, $10, $13, $18, $1B, $1F, $1B, $28, $2C


	; These are Set 2B music segments.  Note that more exist on page 29.

; [ORANGE] TGL1 (plains levels)
TGL1_1:
	.byte $D5, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20
	.byte $20, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18
	.byte $18, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C
	.byte $1C, $16, $7E, $0C, $24, $06, $06, $1E, $1E, $08, $08, $20, $20, $0A, $0A, $22
	.byte $22, $00, $B0, $3E, $3C, $B1, $38, $B2, $34, $B3, $30, $B4, $7E, $B2, $2A, $34
	.byte $B0, $7E, $3E, $B1, $7E, $B0, $3C, $B1, $3E, $B0, $42
TGL1_Tri1:
	.byte $80, $46, $81, $7E, $82
	.byte $46, $80, $7E, $38, $81, $7E, $82, $38, $80, $7E, $3C, $81, $7E, $82, $3C, $80
	.byte $7E, $36, $81, $7E, $82, $36, $80, $7E
TGL1_Nse1:
	.byte $80, $01, $85, $02, $86, $01, $85, $02
	.byte $86, $01, $85, $02, $86, $01, $85, $02, $86, $01, $85, $02, $86, $01, $85, $02
	.byte $86, $01, $85, $02, $86, $01, $85, $02, $87, $01, $00

TGL1_2:
	.byte $D5, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20
	.byte $20, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18
	.byte $18, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C
	.byte $1C, $16, $7E, $0C, $24, $06, $06, $1E, $1E, $08, $08, $20, $20, $0A, $0A, $22
	.byte $22, $00, $B0, $3E, $3C, $B1, $38, $B2, $34, $B3, $30, $B4, $7E, $B2, $2A, $34
	.byte $B0, $7E, $B2, $3E, $B0, $3C, $3E, $B1, $7E
TGL1_Tri2:
	.byte $80, $46, $81, $7E, $82, $46, $80
	.byte $7E, $38, $81, $7E, $82, $38, $80, $7E, $3C, $81, $7E, $82, $3C, $80, $7E, $36
	.byte $81, $7E, $82, $36, $80, $7E
TGL1_Nse2:
	.byte $85, $02, $86, $01, $85, $02, $86, $01, $85, $02
	.byte $86, $01, $85, $02, $86, $01, $85, $02, $86, $01, $85, $02, $86, $01, $85, $02
	.byte $87, $01, $85, $02, $01, $82, $02, $00

TGL1_3:
	.byte $D3, $08, $08, $20, $20, $08, $7E, $20, $20, $D1, $7E, $D3, $08, $08, $20, $20
	.byte $1A, $1A, $18, $18, $01, $01, $01, $7E, $18, $18, $D1, $7E, $D3, $01, $01, $18
	.byte $18, $01, $01, $04, $04, $1C, $1C, $04, $7E, $1C, $1C, $D1, $7E, $D3, $1C, $1C
	.byte $D4, $18, $D5, $7E, $D3, $16, $16, $D1, $7E, $D4, $16, $D5, $7E, $D4, $16, $D5
	.byte $7E, $D4, $16, $D5, $7E, $D4, $16, $D5, $7E, $D4, $16, $D5, $7E, $D4, $16, $D5
	.byte $7E, $D4, $16, $D5, $7E, $00, $B0, $4C, $B1, $7E, $B2, $3E, $B0, $7E, $B2, $3C
	.byte $3E, $B0, $3C, $34, $B1, $7E, $B2, $3C, $B0, $7E, $3E, $B1, $7E, $B0, $3C, $B1
	.byte $3E, $B0, $42
TGL1_Tri3:
	.byte $86, $56, $82, $54, $50, $80, $4C, $86, $42, $82, $4E, $87, $46
TGL1_Nse3:
	.byte $80, $01, $83, $02, $88, $01, $83, $02, $88, $01, $83, $02, $88, $01, $83, $02
	.byte $88, $01, $83, $02, $88, $01, $84, $02, $89, $01, $84, $02, $8A, $01, $84, $02
	.byte $85, $01, $84, $02, $85, $01, $84, $02, $85, $01, $00

TGL1_4:
	.byte $D3, $08, $08, $20, $20, $08, $20, $20, $20, $D1, $7E, $D3, $08, $08, $1C, $1C
	.byte $1A, $1A, $18, $18, $01, $01, $01, $7E, $18, $18, $D1, $7E, $D3, $01, $01, $18
	.byte $18, $01, $01, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04
	.byte $7E, $1C, $1C, $24, $24, $1E, $1E, $16, $16, $0C, $0C, $08, $08, $06, $06, $08
	.byte $08, $0A, $0A, $00, $B0, $4C, $B1, $7E, $B2, $3E, $B0, $7E, $B2, $3C, $3E, $B0
	.byte $3C, $34, $B1, $7E, $B2, $3C, $B0, $7E, $B2, $3E, $3C, $B0, $7E
TGL1_Tri4:
	.byte $80, $38, $3C
	.byte $3E, $42, $82, $3E, $84, $48, $81, $42, $3C, $34, $42, $3C, $34, $42, $80, $3C
	.byte $81, $36, $2E, $3C, $38, $36, $38, $3C
TGL1_Nse4:
	.byte $83, $02, $85, $01, $83, $02, $85, $01
	.byte $83, $02, $85, $01, $83, $02, $85, $01, $83, $02, $85, $01, $83, $02, $86, $01
	.byte $83, $02, $86, $01, $83, $02, $86, $01, $83, $02, $86, $01, $81, $02, $83, $01
	.byte $02, $00

TGL1_5:
	.byte $D5, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20
	.byte $20, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18
	.byte $18, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C
	.byte $1C, $16, $7E, $0C, $24, $06, $06, $1E, $1E, $08, $08, $20, $20, $0A, $0A, $22
	.byte $22, $00, $B0, $3E, $3C, $B1, $38, $B2, $34, $B3, $30, $B4, $7E, $B2, $42, $34
	.byte $B0, $7E, $3E, $B1, $7E, $B0, $3C, $B1, $3E, $B0, $42
TGL1_Tri5:
	.byte $80, $46, $81, $7E, $82
	.byte $46, $80, $7E, $56, $54, $81, $50, $82, $4C, $86, $54, $80, $36, $81, $7E, $80
	.byte $4E, $81, $50, $80, $54
TGL1_Nse5:
	.byte $80, $01, $85, $02, $87, $01, $85, $02, $87, $01, $85
	.byte $02, $87, $01, $85, $02, $87, $01, $85, $02, $87, $01, $85, $02, $87, $01, $85
	.byte $02, $87, $01, $85, $02, $88, $01, $00

TGL1_6:
	.byte $D5, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20, $20, $08, $7E, $20
	.byte $20, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18, $18, $01, $7E, $18
	.byte $18, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C, $1C, $04, $7E, $1C
	.byte $1C, $16, $7E, $0C, $24, $06, $06, $1E, $1E, $08, $08, $20, $20, $0A, $0A, $22
	.byte $22, $00, $B0, $3E, $3C, $B1, $38, $B2, $34, $B3, $30, $B4, $7E, $B2, $2A, $34
	.byte $B0, $7E, $B2, $3E, $B0, $3C, $3E, $B1, $7E
TGL1_Tri6:
	.byte $80, $46, $81, $7E, $82, $46, $80
	.byte $7E, $56, $54, $81, $50, $82, $4C, $86, $54, $80, $34, $3C, $81, $42, $3E, $3C
	.byte $42
TGL1_Nse6:
	.byte $85, $02, $87, $01, $85, $02, $87, $01, $85, $02, $87, $01, $85, $02, $87
	.byte $01, $85, $02, $87, $01, $85, $02, $88, $01, $85, $02, $01, $02, $01, $02, $01
	.byte $02, $01, $88, $02, $85, $01, $02, $01, $02, $01, $00

;;; Castlevania - Vampire
CVampire2:
	.byte $B0, $4C, $B1, $4C, $B2, $7E, $B1, $48, $B2, $7E, $B3, $46, $B4, $34, $B0, $38
	.byte $3A, $3E, $B5, $42, $34, $B4, $42, $B0, $3E, $B6, $30, $B7, $7E, $00, $B0, $42
	.byte $B1, $42, $B2, $7E, $B1, $3E, $B2, $7E, $B3, $3E, $B4, $34, $B0, $34, $30, $30
	.byte $B5, $34, $2C, $B4, $34, $B0, $30, $B6, $3E, $B7, $7E
CVampire2_Tri:
	.byte $B8, $34, $B9, $7E, $B8
	.byte $34, $BA, $7E, $B8, $34, $BA, $7E, $B8, $34, $BB, $7E, $B8, $34, $BA, $7E, $B8
	.byte $34, $B9, $7E, $B8, $34, $BA, $7E, $B8, $34, $BA, $7E, $B8, $34, $BA, $7E, $B8
	.byte $34, $BA, $7E, $B8, $34, $BA, $7E, $B8, $34, $BA, $7E, $B8, $2C, $B9, $7E, $B8
	.byte $2C, $BA, $7E, $B8, $2C, $BA, $7E, $B8, $44, $BC, $7E, $B8, $30, $BA, $7E, $B8
	.byte $30, $BA, $7E, $B8, $48, $BA, $7E, $B8, $30, $BA, $7E, $B8, $30, $BA, $7E, $B8
	.byte $30, $BA, $7E, $B8, $30, $BA, $7E, $B8, $30, $BA, $7E, $B8, $34, $B9, $7E
CVampire2_Nse:
	.byte $B0, $02, $01, $02, $02, $06, $01, $01, $01, $02, $01, $02, $02, $06, $01
	.byte $02, $02, $02, $01, $02, $02, $06, $01, $01, $01, $02, $02, $06, $01, $06, $06
	.byte $06, $01, $00

CVampire3:
	.byte $B0, $4C, $B1, $7E, $B0, $5A, $B1, $7E, $B0, $58, $5A, $58, $52, $7E, $7E, $7E, $7E, $7E, $7E;, $B0
	.byte $52, $4C, $B1, $7E, $B0, $3A, $34, $7E, $52, $4C, $52, $4C, $52, $4C, $52, $B1
	.byte $7E, $00, $B0, $42, $B1, $7E, $B0, $4C, $B1, $7E, $B0, $4A, $4C, $4A, $48, $7E
	.byte $7E, $7E, $7E, $B0, $5A, $7E, $5A, $58, $7E, $58, $56, $7E, $B3, $5A, $B4, $7E, $B0, $5A
	.byte $B3, $58, $B4, $7E, $B0, $58, $56, $7E, $7E, $7E
CVampire3_Tri:
	.byte $B7, $34, $B8, $7E, $B7, $34, $B8
	.byte $7E, $B7, $34, $B9, $7E, $B7, $34, $B8, $7E, $B7, $34, $BA, $7E, $B7, $34, $B8
	.byte $7E, $B7, $34, $B8, $7E, $B7, $34, $B8, $7E, $B7, $34, $B8, $7E, $B7, $34, $B8
	.byte $7E, $B7, $34, $B8, $7E, $B7, $2C, $BA, $7E, $B7, $2C, $B8, $7E, $B7, $2C, $B8
	.byte $7E, $B7, $44, $B8, $7E, $B7, $2C, $BA, $7E, $B7, $2C, $BA, $7E, $B7, $2C, $B8
	.byte $7E, $B7, $44, $BA, $7E, $B7, $44, $BA, $7E, $B7, $44, $BA, $7E, $B7, $34, $BA
	.byte $7E
CVampire3_Nse:
	.byte $B0, $02, $02, $06, $01, $01, $01, $02, $01, $02, $02, $06, $01, $02, $02, $02
	.byte $01, $02, $02, $06, $01, $01, $02, $02, $02, $06, $01, $06, $01, $06, $01, $02
	.byte $01, $00

CVampire4:
	.byte $B0, $4C, $B1, $7E, $B0, $5A, $B1, $7E, $B0, $58, $5A, $58, $52, $7E, $7E, $7E, $7E, $7E, $7E;, $B0
	.byte $52, $4C, $B1, $7E, $B0, $3A, $34, $7E, $52, $4C, $52, $4C, $52, $4C, $52, $00
	.byte $B0, $42, $B1, $7E, $B0, $4C, $B1, $7E, $B0, $4A, $4C, $4A, $48, $7E, $7E, $7E, $7E, $B0
	.byte $5A, $7E, $5A, $58, $7E, $58, $56, $7E, $5A, $7E, $5A, $58, $7E, $58, $56, $7E
CVampire4_Tri:
	.byte $B4, $34, $B5, $7E, $B4, $34, $B5, $7E, $B4, $34, $B6, $7E, $B4, $34, $B5, $7E
	.byte $B4, $34, $B7, $7E, $B4, $34, $B5, $7E, $B4, $34, $B5, $7E, $B4, $34, $B5, $7E
	.byte $B4, $34, $B5, $7E, $B4, $34, $B5, $7E, $B4, $34, $B5, $7E, $B4, $2C, $B7, $7E
	.byte $B4, $2C, $B5, $7E, $B4, $2C, $B5, $7E, $B4, $44, $B5, $7E, $B4, $2C, $B7, $7E
	.byte $B4, $2C, $B7, $7E, $B4, $2C, $B5, $7E, $B4, $44, $B7, $7E, $B4, $44, $B7, $7E
	.byte $B4, $44, $B7, $7E
CVampire4_Nse:
	.byte $F0, $02, $02, $06, $01, $01, $01, $02, $01, $02, $02, $06, $01, $02, $02, $02
	.byte $01, $02, $02, $06, $01, $01, $02, $02, $02, $06, $01, $06, $01, $06, $01, $02
	.byte $01, $00

CVampire7:
	.byte $B0, $64, $B1, $7E, $B0, $64, $B1, $7E, $B0, $4C, $B1, $7E, $B2, $4C, $B3, $7E
	.byte $2C, $7E, $2C, $7E, $B0, $34, $B1, $7E, $B4, $3A, $B3, $7E, $30, $7E, $30, $7E
	.byte $B0, $38, $B1, $7E, $B4, $3E, $B3, $7E, $00, $B0, $5A, $B1, $7E, $B0, $5A, $B1
	.byte $7E, $B0, $42, $B1, $7E, $B2, $42, $B3, $7E, $22, $7E, $22, $7E, $B0, $2C, $B1
	.byte $7E, $B4, $34, $B3, $7E, $26, $7E, $26, $7E, $B0, $30, $B1, $7E, $B4, $38, $B3
	.byte $7E
CVampire7_Tri:
	.byte $B5, $34, $B6, $7E, $B3, $34, $B4, $7E, $B3, $34, $B4, $30, $B5, $34, $B7
	.byte $7E, $B5, $2C, $B6, $7E, $B5, $2C, $B8, $7E, $B3, $30, $7E, $30, $B9, $7E
CVampire7_Nse:
	.byte $B3, $01, $02, $06, $01, $02, $06, $01, $06, $01, $01, $02, $02, $02, $02, $02
	.byte $02, $06, $01, $06, $01, $02, $06, $06, $06, $06, $01, $06, $01, $02, $06, $06
	.byte $06, $00

CVampire8:
	.byte $B0, $64, $B1, $7E, $B0, $64, $B1, $7E, $B0, $4C, $B1, $7E, $B2, $4C, $B3, $7E
	.byte $2C, $7E, $2C, $7E, $B0, $34, $B1, $7E, $B4, $3A, $B3, $7E, $30, $7E, $7E, $7E, $B0
	.byte $12, $B1, $7E, $B4, $18, $B3, $7E, $00, $B0, $5A, $B1, $7E, $B0, $5A, $B1, $7E
	.byte $B0, $42, $B1, $7E, $B2, $42, $B3, $7E, $22, $7E, $22, $7E, $B0, $2C, $B1, $7E
	.byte $B4, $34, $B3, $7E, $26, $7E, $B4, $7E, $7E, $7E
CVampire8_Tri:
	.byte $B7, $34, $B8, $7E, $B7, $34, $B9, $7E, $B3
	.byte $34, $B4, $30, $B7, $34, $BA, $7E, $B3, $2C, $7E, $B7, $2C, $BB, $7E, $B7, $30
	.byte $B8, $7E, $B7, $30, $B8, $7E, $B7, $2A, $BC, $7E, $B6, $30
CVampire8_Nse:
	.byte $B3, $01, $02, $06, $01, $02, $06, $01, $06, $01, $01, $02, $02, $02, $02, $02
	.byte $02, $06, $01, $06, $01, $02, $06, $06, $06, $06, $01, $06, $01, $02, $06, $06
	.byte $06, $00

; [ORANGE] Gradius II
Gradius2_1:
	.byte $C0, $7E, $C5, $46, $54, $5E, $46, $CA, $5A, $C7, $5A, $C1, $5A, $C0, $58, $C8
	.byte $5A, $C0, $58, $C8, $5A, $C0, $58, $C4, $5A, $C5, $58, $54, $50, $58, $CA, $54
	.byte $C7, $54, $C8, $54, $C5, $50, $4E, $4A, $CA, $4A, $C7, $4A, $CB, $4A, $C2, $3E
	.byte $C3, $40, $C2, $42, $C3, $44, $00, $C0, $7E, $C9, $3C, $C5, $46, $54, $5E, $46
	.byte $CA, $5A, $C7, $5A, $C1, $5A, $C0, $58, $C8, $5A, $C0, $58, $C8, $5A, $C0, $58
	.byte $C4, $5A, $C5, $58, $54, $50, $58, $CA, $54, $C7, $54, $C8, $54, $C5, $50, $4E
	.byte $4A, $CA, $4A, $C7, $4A, $CB, $4A
Gradius2_Tri1:
	.byte $C0, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E, $C4, $46, $C1, $7E, $C4, $2E, $C1
	.byte $7E, $C4, $3C, $C1, $7E, $C4, $42, $C1, $7E
Gradius2_Nse1:
	.byte $C6, $01, $C3, $02, $C2, $01, $C9, $02, $C8, $06, $C2, $01, $02, $C7, $01, $CA
	.byte $02, $C0, $01, $C2, $02, $C1, $01, $C4, $02, $C3, $01, $C8, $06, $C2, $01, $02
	.byte $C7, $01, $CA, $03, $C0, $01, $C2, $02, $C1, $01, $C4, $03, $C3, $01, $C8, $06
	.byte $C2, $01, $02, $C7, $01, $CA, $03, $C0, $01, $C2, $02, $C1, $01, $C4, $03, $C3
	.byte $01, $C8, $06, $C2, $01, $02, $C7, $01, $C1, $03, $00

Gradius2_2:
	.byte $C7, $46, $54, $5E, $46, $CD, $5A, $C9, $5A, $C2, $5A, $C1, $58, $CA, $5A, $C1
	.byte $58, $CA, $5A, $C1, $58, $C5, $5A, $C7, $58, $54, $50, $54, $CD, $5A, $C9, $5A
	.byte $C2, $5A, $C1, $58, $C8, $5A, $C7, $52, $50, $52, $CD, $4C, $C9, $4C, $CF, $4C
	.byte $C3, $4A, $C4, $48, $00, $CC, $3C, $C7, $46, $54, $5E, $46, $CD, $5A, $C9, $5A
	.byte $C2, $5A, $C1, $58, $CA, $5A, $C1, $58, $CA, $5A, $C1, $58, $C5, $5A, $C7, $58
	.byte $54, $CD, $4C, $C9, $4C, $C0, $4C, $CD, $46, $C7, $46, $C6, $46, $C5, $44, $C2
	.byte $46, $C5, $42, $C2, $46, $C5, $40, $C2, $46, $C5, $3E, $C2, $44
Gradius2_Tri2:
	.byte $C5, $46, $C2
	.byte $7E, $C5, $2E, $C2, $7E, $C5, $3C, $C2, $7E, $C5, $42, $C2, $7E, $C5, $46, $C2
	.byte $7E, $C5, $2E, $C2, $7E, $C5, $3C, $C2, $7E, $C5, $42, $C2, $7E, $C5, $46, $C2
	.byte $7E, $C5, $2E, $C2, $7E, $C5, $3C, $C2, $7E, $C5, $42, $C2, $7E, $C5, $46, $C2
	.byte $7E, $C5, $2E, $C2, $7E, $C5, $3C, $C2, $7E, $C5, $42, $C2, $7E, $C5, $3E, $C2
	.byte $7E, $C5, $26, $C2, $7E, $C5, $34, $C2, $7E, $C5, $3A, $C2, $7E, $C5, $3E, $C2
	.byte $7E, $C5, $26, $C2, $7E, $C5, $34, $C2, $7E, $C5, $3A, $C2, $7E, $C5, $3E, $C2
	.byte $7E, $C5, $26, $C2, $7E, $C5, $34, $C2, $7E, $C5, $3A, $C2, $7E, $C5, $3E, $C2
	.byte $7E, $C5, $26, $C2, $7E, $C3, $26, $C4, $28, $C3, $2A, $C4, $2C
Gradius2_Nse2:
	.byte $CC, $01, $C3, $02, $C2, $01, $C5, $03, $C4, $01, $CA, $06, $C3, $01, $02, $C9
	.byte $01, $CD, $03, $C1, $01, $C3, $02, $C2, $01, $C5, $03, $C2, $01, $CB, $06, $C3
	.byte $01, $02, $C9, $01, $CD, $03, $C1, $01, $C3, $02, $C2, $01, $C5, $03, $C4, $01
	.byte $CA, $06, $C3, $01, $02, $C9, $01, $CD, $03, $C1, $01, $C3, $02, $C2, $01, $C5
	.byte $03, $C4, $01, $CA, $06, $C3, $01, $02, $C9, $01, $C2, $03, $00

Gradius2_3:
	.byte $C6, $46, $34, $3E, $4A, $CE, $46, $C8, $46, $CF, $46, $C6, $34, $3E, $4C, $4A
	.byte $46, $42, $46, $38, $42, $4C, $CE, $4A, $C8, $4A, $CF, $4A, $C6, $42, $46, $4C
	.byte $4A, $46, $42, $00
	.byte $CE, $34, $C9, $34, $CC, $34, $C3, $34, $C6, $2E, $34, $CD, $3E, $C6, $2E, $34
	.byte $46, $42, $3E, $3C, $CE, $38, $C9, $38, $CC, $38, $C3, $38, $C6, $32, $38, $CD
	.byte $42, $C6, $32, $38, $46, $42, $38, $32
Gradius2_Tri3:
	.byte $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E, $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E
	.byte $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E, $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E
	.byte $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E, $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E
	.byte $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E, $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E
	.byte $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E, $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E
	.byte $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E, $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E
	.byte $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E, $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E
	.byte $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E, $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E
Gradius2_Nse3:
	.byte $CA, $01, $01, $C2, $03, $C3, $01, $CA, $06, $C2, $01, $C4, $06, $C1, $01, $CA, $06
	.byte $C2, $01, $C3, $03, $C9, $01, $C2, $03, $C3, $01, $CA, $06, $C2, $01, $C5, $06
	.byte $C0, $01, $CA, $06, $C2, $01, $C3, $03, $C9, $01, $C2, $03, $C3, $01, $CA, $06
	.byte $C2, $01, $C5, $06, $C0, $01, $CA, $06, $C2, $01, $C3, $03, $C9, $01, $C2, $03
	.byte $C3, $01, $CA, $06, $C2, $01, $C5, $06, $C0, $01, $C6, $06, $00

Gradius2_4:
	.byte $CC, $46, $C2, $4A, $C3, $4C, $C2, $50, $C3, $54, $C2, $56, $C3, $5A, $CB, $5E
	.byte $C6, $3C, $3C, $3E, $3E, $42, $42, $44, $44, $00
	.byte $CD, $24, $2E, $38, $42, $CA, $54, $3C, $46, $2E, $C6, $32, $32, $34, $34, $38
	.byte $38, $3A, $3A
Gradius2_Tri4:
	.byte $C4, $2E, $C1, $7E, $C4, $24, $C1, $7E, $C4, $2E, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $2E, $C1, $7E, $C4, $24, $C1, $7E, $C4, $2E, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $2E, $C1, $7E, $C4, $24, $C1, $7E, $C4, $2E, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $2E, $C1, $7E, $C4, $24, $C1, $7E, $C4, $2E, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $2E, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $2E, $C1, $7E, $C4, $46, $C1, $7E
	.byte $C4, $2E, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $2E, $C1, $7E, $C4, $46, $C1, $7E
	.byte $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E
	.byte $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E, $C4, $2C, $C1, $7E, $C4, $44, $C1, $7E
Gradius2_Nse4:
	.byte $C2, $01, $C3, $02, $C7, $01, $C2, $02, $C3, $01, $C8, $06, $C2, $01, $C5, $06
	.byte $C0, $01, $C8, $06, $C2, $01, $C3, $02, $C7, $01, $C2, $02, $C3, $01, $C8, $06
	.byte $C2, $01, $C5, $06, $C0, $01, $C8, $06, $C2, $01, $C3, $02, $C7, $01, $C2, $02
	.byte $C3, $01, $C8, $06, $C2, $01, $C5, $06, $C0, $01, $C8, $06, $C2, $01, $C3, $02
	.byte $C7, $01, $C2, $02, $C3, $01, $C8, $06, $C2, $01, $C6, $06, $06, $00

Gradius2_5:
	.byte $C5, $3C, $C6, $3E, $42, $46, $4A, $4C, $50, $CE, $54, $C6, $3C, $3E, $3E, $42
	.byte $42, $44, $44, $00
	.byte $CD, $2E, $32, $38, $C6, $3E, $42, $46, $4A, $CD, $46, $44, $C6, $32, $32, $34
	.byte $34, $38, $38, $3A, $3A
Gradius2_Tri5:
	.byte $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E
	.byte $C4, $24, $C1, $7E, $C4, $32, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $24, $C1, $7E
	.byte $C4, $32, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $24, $C1, $7E, $C4, $32, $C1, $7E
	.byte $C4, $24, $C1, $7E, $C4, $3C, $C1, $7E, $C4, $26, $C1, $7E, $C4, $3E, $C1, $7E
	.byte $C4, $2A, $C1, $7E, $C4, $42, $C1, $7E, $C4, $2C, $C1, $7E, $C4, $44, $C1, $7E
Gradius2_Nse5:
	.byte $C2, $01, $C3, $06, $C9, $01, $C6, $02, $CA, $06, $C2, $01, $C6, $06, $CA, $06
	.byte $C2, $01, $C3, $06, $C9, $01, $C6, $02, $CA, $06, $C2, $01, $C6, $06, $CA, $06
	.byte $C2, $01, $C3, $06, $C9, $01, $C6, $02, $CA, $06, $C2, $01, $C6, $06, $06, $C2
	.byte $06, $C3, $06, $C6, $06, $06, $06, $06, $06, $06, $C7, $06, $C0, $06, $00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;; BEGIN UNUSED COPY/PASTED CODE ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The following are copied fragments from PRG030 ... THEY DO NOT BELONG HERE
; They also are in the wrong address space (PRG030 is $8xxx, PRG028 is $Axxx)
; My guess... massive copy/paste error? :D


	; Set Temp_Var13/14 to point to the layout data for this Tileset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA TileLayout_ByTileset,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA TileLayout_ByTileset+1,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDY <Temp_Var11		 ; Y = tile temp		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; VScroll_TileQuads2Attrs:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDX <Temp_Var8		 ; X = Temp_Var8 (Scroll_AttrStrip offset)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Map_Tile_AddrL],Y	 ; Get the tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	DEY		 ; Y--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Map_Tile_AddrL],Y	 ; Get the tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; Player_GetTileV:	; $9E3C 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var13	 ; A = Temp_Var13 (Y Hi)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	PHA		 ; Save it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAY		 ; Y = Y Hi		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var14	 ; A = Temp_Var14 (Y Lo)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	PHA		 ; Save it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	JSR LevelJct_GetVScreenH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	STA <Temp_Var14	 ; Adjusted Y for vertical -> Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Select root offset into tile memory		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_AddrVL,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrL		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_AddrVH,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Combine positions into Temp_Var15 to form tile mem offset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #$f0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var15		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var16		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ORA <Temp_Var15		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	TAY		 ; Offset -> 'Y'		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	PLA		 ; Restore original value for Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var14	 ; Store it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	PLA		 ; Restore original value for Temp_Var13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var13	 ; Store it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Map_Tile_AddrL],Y	 ; Get tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Level_Tile	 ; Store into Level_Tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; This is basically a lookup for any given "Player Y Hi" shifted up 4 bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BE6C:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $00, $10, $20, $30, $40, $50, $60, $70, $80, $90, $A0, $B0, $C0, $D0, $E0, $F0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Translates the Player position into appropriate "high" value		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; as Vertical describes it ($0(00), $0(F0), $1(E0), ...)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; LevelJct_GetVScreenH:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Y = Player_YHi		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; A = Player_Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	CPY #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLS PRG028_BE8E	 ; If Y < 0 (i.e. if the Player Y High is less than zero, which shouldn't happen!), jump to PRG028_BE8E (RTS)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	ADD PRG030_9E6C,Y	; Player_Y += Player_YHi[Y]		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BCS PRG028_BE8A	 	; If carry set (overflow occurred), jump to PRG028_BE8A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	CMP #$f0			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLT PRG028_BE8E	 	; If result is < $F0, jump to PRG028_BE8E		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BE8A:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Add $10 and roll over 'Y' (Considered in the lower vertical half)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ADD #$10		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	INY			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BE8E:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Something similar to LevelJct_GetVScreenH, but I'm 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; not quite following the purpose		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; LevelJct_GetVScreenH2:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; A = Player_Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Y = Player_YHi		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CPY #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLS PRG028_BE9A	 ; If YHi < 0 (shouldn't happen?), jump to PRG028_BE9A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	SUB PRG030_9E6C,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BCS PRG028_BE9A	 ; If carry set, jump to PRG028_BE9A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	DEY		 ; Y--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BE9A:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY


; FIXME: Anybody want to claim this??		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; $9E9B		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $F0, $20		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; Player_GetTileAndSlope_Normal:	; $9E9D		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Clear slope array		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA #$00			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes+1		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes+2		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var16		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Level_TileOff	 ; Level_TileOff = Temp_Var16 >> 4 (current column Player is in)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var15		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #$0f			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A				; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAX		 ; X = (Temp_Var15 & $0F) << 1 (current "high" part of Player X shifted up by 1, indexing Tile Mem)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Set Map_Tile_AddrL/H to appropriate screen based on Player's position		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_Addr,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrL		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_Addr+1,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BEQ PRG028_BEC3	 ; If Temp_Var13 (Y Hi) = 0, jump to PRG028_BEC3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	INC <Map_Tile_AddrH ; Otherwise, go to second half of screen		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BEC3:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #$f0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ORA <Level_TileOff	 ; Level_TileOff gets the Player's current row in the upper 4 bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Level_TileOff is now Player's current offset in Tile Mem from the selected pointer		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	STA <Temp_Var12		 ; ... and copied into Temp_Var12		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	TAY		 	; Y = current offset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA [Map_Tile_AddrL],Y	; Get tile here		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Level_Tile	; Store into Level_Tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDY Level_Tileset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CPY #3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BEQ PRG028_BEDB	 ; If Level_Tileset = 3 (Hills style), jump to PRG028_BEDB		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	CPY #14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BNE PRG028_BF0D	 ; If Level_Tileset <> 14 (Underground), jump to PRG028_BF0D		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BEDB:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var1		 ; Temp_Var1 = 0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDY <Temp_Var12		 ; Y = current offset in Tile Mem		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA [Map_Tile_AddrL],Y	 ; Get tile here		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var2		 ; Store into Temp_Var2		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	AND #$c0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CLC		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAY		; Y = just the upper 2 bits of tile shifted right 6 (0 to 3)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var2		 ; Re-get tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CMP Tile_AttrTable,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLT PRG028_BF0D	 	; If it's less than the tile specified in Tile_AttrTable[Y], jump to PRG028_BF0D		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	TYA		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAX		 ; X = Y (the upper 2 bits) << 1 (two byte index)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Temp_Var3/4 are loaded with address inside PRG000_C000		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Level_SlopeSetByQuad,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Level_SlopeSetByQuad+1,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var4		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDX <Temp_Var1	 	; X = Temp_Var1 (0)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Temp_Var2	 	; A = Temp_Var2 (the retrieved tile)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	SUB Tile_AttrTable,Y	; Subtract the root tile value		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAY		 	; Y = result		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Temp_Var3],Y		; Get value 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes,X	; Store into Player_Slopes		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BF0D:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Level_Tile	; A = Level_Tile (the tile retrieved)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Probably unused space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY


; PRG030_SUB_9F40:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA Raster_State 	; Reset Raster_State		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA Update_Request		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	JMP PRG031_F499		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Filler space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Sub part of A0 mode of IRQ		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; PRG030_SUB_9F50:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Some kind of delay loop?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDX #$17	 ; X = $17		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BF52:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		 ; ?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	DEX		 ; X--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BPL PRG028_BF52 ; While X > 0, loop		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Latch this value, and force it into the counter!		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQLATCH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQDISABLE		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQENABLE		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Probably unused space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; IntIRQ_32PixelPartition_Part5:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Some kind of delay loop?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDX #$13	 ; X = $13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BF80:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		 ; ?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	DEX		 ; X--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BPL PRG028_BF80 ; While X > 0, loop		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; More NOPs		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	STA MMC3_IRQLATCH ; Latch A (last set to 27!)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQENABLE ; Enable IRQ again		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	JMP PRG031_FA3C	 ; Jump to PRG031_FA3C		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Unused space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; IntIRQ_32PixelPartition_Part2:	; $9FA0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Update_Request	 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #UPDATERASTER_32PIXSHOWSPR		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BNE PRG028_BFAA	 ; If UPDATERASTER_32PIXSHOWSPR is set, go to PRG028_BFAA		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Otherwise, change loaded pattern tables to hide sprites that fall beneath the 32 pixel partition		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	JMP IntIRQ_32PixPart_HideSprites		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BFAA:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; I think the following NOPs and loop are to help synchronize the IRQ		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; routine if it didn't perform the IntIRQ_32PixPart_HideSprites step		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDX #$03	 ; X = 3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BFAF:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		 ; ?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	DEX		 ; X--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BPL PRG028_BFAF	 ; While X > 0, loop		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	JMP IntIRQ_32PixelPartition_Part3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;  END UNUSED COPY/PASTED CODE  ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Remainder of ROM bank was empty
SFX_Counter3_Hook:
	AND #$7F
	STA SFX_Counter3
	RTS
