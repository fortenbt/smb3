; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:33.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
Video_DoWXMario00:
	vaddr $2908
	.byte $01, $A0

	vaddr $2909
	.byte VU_REPEAT | 14, $A1

	vaddr $2917
	.byte $01, $A2

	vaddr $2928
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2929
	.byte VU_REPEAT | 14, $FE

	vaddr $2937
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2949
	.byte VU_REPEAT | 14, $FE

	vaddr $2969
	.byte VU_REPEAT | 14, $FE

	vaddr $2989
	.byte VU_REPEAT | 14, $FE

	vaddr $29A9
	.byte VU_REPEAT | 14, $FE
	
	vaddr $29C9
	.byte VU_REPEAT | 14, $FE

	vaddr $29E8, 
	.byte $01, $E3

	vaddr $29E9
	.byte VU_REPEAT | 14, $E4

	vaddr $29F7
	.byte $01, $E5

	; ----

	vaddr $2949
	;.byte $05, $D8, $F0, $E9, $EC, $EE	; WORLD
	; "Super Orb Bros"
	.byte $0E, $C1, $AB, $D9, $DC, $A8, $FE, $F0, $A8, $E1, $FE, $10, $A8, $93, $A9

	;vaddr $29AA
	;.byte $05, $BA, $BC, $E9, $FC, $F0	; MARIO

	;vaddr $29B3
	;.byte $01, $FB

	; ----

	vaddr $2BD2
	.byte VU_REPEAT | 4, $00

	vaddr $2BDA
	.byte VU_REPEAT | 4, $00
	.byte $00

Video_DoWXMario80:
	vaddr $2918
	.byte $01, $A0

	vaddr $2919
	.byte VU_REPEAT | 7, $A1

	vaddr $2900
	.byte VU_REPEAT | 7, $A1

	vaddr $2907
	.byte $01, $A2

	vaddr $2938
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2939
	.byte VU_REPEAT | 7, $FE

	vaddr $2920
	.byte VU_REPEAT | 7, $FE

	vaddr $2927
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2959
	.byte VU_REPEAT | 7, $FE

	vaddr $2940
	.byte VU_REPEAT | 7, $FE

	vaddr $2979
	.byte VU_REPEAT | 7, $FE

	vaddr $2960
	.byte VU_REPEAT | 7, $FE

	vaddr $2999
	.byte VU_REPEAT | 7, $FE

	vaddr $2980
	.byte VU_REPEAT | 7, $FE

	vaddr $29B9
	.byte VU_REPEAT | 7, $FE

	vaddr $29A0
	.byte VU_REPEAT | 7, $FE

	vaddr $29D9
	.byte VU_REPEAT | 7, $FE
	
	vaddr $29C0
	.byte VU_REPEAT | 7, $FE

	vaddr $29F8
	.byte $01, $E3

	vaddr $29F9
	.byte VU_REPEAT | 7, $E4

	vaddr $29E0
	.byte VU_REPEAT | 7, $E4

	vaddr $29E7
	.byte $01, $E5

	; ----
	
	vaddr $295C
	.byte $04, $D8, $F0, $E9, $EC	; WORL

	vaddr $2940
	.byte $01, $EE			; D

	vaddr $29BA
	.byte $05, $BA, $BC, $E9, $FC, $F0 ; MARIO

	vaddr $29A3
	.byte $01, $FB

	vaddr $2BD0
	.byte VU_REPEAT | 2, $00

	; ----
	
	vaddr $2BD6
	.byte VU_REPEAT | 4, $00

	vaddr $2BDE
	.byte VU_REPEAT | 2, $00
	.byte $00


Video_DoGameOver00:
	vaddr $2908
	.byte $01, $A0

	vaddr $2909
	.byte VU_REPEAT | 14, $A1


	vaddr $2917
	.byte $01, $A2

	vaddr $2928
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2929
	.byte VU_REPEAT | 14, $FE

	vaddr $2937
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2949
	.byte VU_REPEAT | 14, $FE

	vaddr $2969
	.byte VU_REPEAT | 14, $FE

	vaddr $2989
	.byte VU_REPEAT | 14, $FE

	vaddr $29A9
	.byte VU_REPEAT | 14, $FE
	
	vaddr $29C9
	.byte VU_REPEAT | 14, $FE

	vaddr $29E8
	.byte $01, $E3

	vaddr $29E9
	.byte VU_REPEAT | 14, $E4

	vaddr $29F7
	.byte $01, $E5

	; ----

	vaddr $296B
	.byte $0A, $EB, $BC, $BA, $E8, $FE, $F0, $6A, $E8, $E9, $6B	; GAME OVER!

	vaddr $29AF
	.byte $08, $ED, $F0, $DB, $EA, $FC, $DB, $DA, $E8	; CONTINUE

	vaddr $29CF
	.byte $03, $E8, $DB, $EE	; END

	; ----

	vaddr $2BD2
	.byte VU_REPEAT | 4, $00

	vaddr $2BDA
	.byte VU_REPEAT | 4, $00

	.byte $00


Video_DoGameOver80:
	vaddr $2918
	.byte $01, $A0

	vaddr $2919
	.byte VU_REPEAT | 7, $A1

	vaddr $2900
	.byte VU_REPEAT | 7, $A1

	vaddr $2907
	.byte $01, $A2

	vaddr $2938
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2939
	.byte VU_REPEAT | 7, $FE

	vaddr $2920
	.byte VU_REPEAT | 7, $FE

	vaddr $2927
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2959
	.byte VU_REPEAT | 7, $FE

	vaddr $2940
	.byte VU_REPEAT | 7, $FE

	vaddr $2979
	.byte VU_REPEAT | 7, $FE

	vaddr $2960
	.byte VU_REPEAT | 7, $FE

	vaddr $2999
	.byte VU_REPEAT | 7, $FE

	vaddr $2980
	.byte VU_REPEAT | 7, $FE

	vaddr $29B9
	.byte VU_REPEAT | 7, $FE

	vaddr $29A0
	.byte VU_REPEAT | 7, $FE

	vaddr $29D9
	.byte VU_REPEAT | 7, $FE
	
	vaddr $29C0
	.byte VU_REPEAT | 7, $FE

	vaddr $29F8
	.byte $01, $E3

	vaddr $29F9
	.byte VU_REPEAT | 7, $E4

	vaddr $29E0
	.byte VU_REPEAT | 7, $E4

	vaddr $29E7
	.byte $01, $E5

	; ----

	vaddr $297B
	.byte $04, $EB, $BC, $BA, $E8		; GAME

	vaddr $2960
	.byte $05, $F0, $6A, $E8, $E9, $6B	; OVER!

	vaddr $29A0
	.byte $07, $F0, $DB, $EA, $FC, $DB, $DA, $E8

	vaddr $29BF
	.byte $01, $ED

	vaddr $29C0
	.byte $02, $DB, $EE	; ND

	vaddr $29DF
	.byte $01, $E8	; E

	; ----

	vaddr $2BD0
	.byte VU_REPEAT | 2, $00 

	vaddr $2BD6
	.byte VU_REPEAT | 4, $00

	vaddr $2BDE
	.byte VU_REPEAT | 2, $00

	.byte $00

Video_DoW2WZ:	; "WELCOME TO WARP ZONE" banner
	vaddr $2884
	.byte VU_VERT | $04, $A0, $E6, $E6, $E3

	vaddr $2885
	.byte VU_REPEAT | 22, $A1

	vaddr $289B
	.byte VU_VERT | $04, $A2, $E7, $E7, $E5

	vaddr $28A5	;W    E    L    C    O    M    E         T    O         W    A    R    P         Z    O    N    E
	.byte 22, $FE, $D8, $E8, $EC, $ED, $F0, $BA, $E8, $FE, $EA, $F0, $FE, $D8, $BC, $E9, $D9, $FE, $FD, $F0, $DB, $E8, $FE

	vaddr $28C5
	.byte VU_REPEAT | 22, $FE

	vaddr $28E5
	.byte VU_REPEAT | 22, $E4

	vaddr $2BC9
	.byte VU_REPEAT | 6, $00
	.byte $00

Video_DoWXLuigi00:
	vaddr $2908
	.byte $01, $A0

	vaddr $2909
	.byte VU_REPEAT | 14, $A1

	vaddr $2917
	.byte $01, $A2

	vaddr $2928
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2929

	.byte VU_REPEAT | 14, $FE

	vaddr $2937
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2949
	.byte VU_REPEAT | 14, $FE

	vaddr $2969
	.byte VU_REPEAT | 14, $FE

	vaddr $2989
	.byte VU_REPEAT | 14, $FE

	vaddr $29A9
	.byte VU_REPEAT | 14, $FE
	
	vaddr $29C9
	.byte VU_REPEAT | 14, $FE

	vaddr $29E8, 
	.byte $01, $E3

	vaddr $29E9
	.byte VU_REPEAT | 14, $E4

	vaddr $29F7
	.byte $01, $E5

	vaddr $294C
	.byte $05, $D8, $F0, $E9, $EC, $EE	; WORLD

	vaddr $29AA
	.byte $05, $EC, $DA, $FC, $EB, $FC	; LUIGI

	vaddr $29B3
	.byte $01, $FB

	vaddr $2BD2
	.byte VU_REPEAT | 4, $00

	vaddr $2BDA
	.byte VU_REPEAT | 4, $00
	.byte $00


Video_DoWXLuigi80:
	vaddr $2918
	.byte $01, $A0

	vaddr $2919
	.byte VU_REPEAT | 7, $A1

	vaddr $2900
	.byte VU_REPEAT | 7, $A1

	vaddr $2907
	.byte $01, $A2

	vaddr $2938
	.byte VU_REPEAT | VU_VERT | 6, $E6

	vaddr $2939
	.byte VU_REPEAT | 7, $FE

	vaddr $2920
	.byte VU_REPEAT | 7, $FE

	vaddr $2927
	.byte VU_REPEAT | VU_VERT | 6, $E7

	vaddr $2959
	.byte VU_REPEAT | 7, $FE

	vaddr $2940
	.byte VU_REPEAT | 7, $FE

	vaddr $2979
	.byte VU_REPEAT | 7, $FE

	vaddr $2960
	.byte VU_REPEAT | 7, $FE

	vaddr $2999
	.byte VU_REPEAT | 7, $FE

	vaddr $2980
	.byte VU_REPEAT | 7, $FE

	vaddr $29B9
	.byte VU_REPEAT | 7, $FE

	vaddr $29A0
	.byte VU_REPEAT | 7, $FE

	vaddr $29D9
	.byte VU_REPEAT | 7, $FE
	
	vaddr $29C0
	.byte VU_REPEAT | 7, $FE

	vaddr $29F8
	.byte $01, $E3

	vaddr $29F9
	.byte VU_REPEAT | 7, $E4

	vaddr $29E0
	.byte VU_REPEAT | 7, $E4

	vaddr $29E7
	.byte $01, $E5
	
	vaddr $295C
	.byte $04, $D8, $F0, $E9, $EC	; WORL

	vaddr $2940
	.byte $01, $EE			; D

	vaddr $29BA
	.byte $05, $EC, $DA, $FC, $EB, $FC	; LUIGI

	vaddr $29A3
	.byte $01, $FB

	vaddr $2BD0
	.byte VU_REPEAT | 2, $00
	
	vaddr $2BD6
	.byte VU_REPEAT | 4, $00

	vaddr $2BDE
	.byte VU_REPEAT | 2, $00
	.byte $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_IntroAttrSave
;
; This subroutine saves the attribute info underneath where
; the "World X" intro box is about to sit.  This is used to
; "clean up" the changes made to the attribute table later.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_IntroAttrSave:
	LDA <Horz_Scroll
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		 ; A >> 5 (div by 32, for figuring out what set of 2x2 tiles we need to fix)
	ADD #$d2
	STA <Temp_Var1

	ADD #$08
	STA <Temp_Var2

	LDA PPU_STAT

	LDX #$00	 ; X = 0

PRG010_C2DA:
	; Set the address to $2Bxx (attribute table 2, all that the map effects)
	LDA #$2B
	STA PPU_VRAM_ADDR
	LDA <Temp_Var1	
	STA PPU_VRAM_ADDR

	LDA PPU_VRAM_DATA

	LDA PPU_VRAM_DATA
	STA <Scroll_ColorStrip,X

	LDY <Temp_Var1	 ; Y = Temp_Var1
	INY
	TYA
	AND #$07
	BNE PRG010_C2F9

	LDA <Temp_Var1
	AND #$f8
	TAY

PRG010_C2F9:
	STY <Temp_Var1
	CPX #$03
	BNE PRG010_C303
	LDA <Temp_Var2	
	STA <Temp_Var1	

PRG010_C303:
	INX	

	CPX #$08
	BNE PRG010_C2DA	 ; While X <> 8, loop

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GameOver_PatchPlayerName
;
; This subroutine pushes the Player's name for
; the "Game Over!" box into the graphics
; buffer for further processing...
; Note that this is not a "friendly" function, in that
; it directly sets the graphics buffer, not inserts.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GameOver_MLName:
	.byte $BA, $BC, $E9, $FC, $F0, $00	; MARIO[Terminator]
	.byte $EC, $DA, $FC, $EB, $FC, $00	; LUIGI[Terminator]
GameOver_MLName_Len = 6

GameOver_PatchPlayerName:
	LDY Player_Current	; Y = Player_Current
	LDX #$00	 ; X = 0

	CPY #$00
	BEQ PRG010_C320	 ; If Player_Current = 0 (Player is Mario), jump to PRG010_C320

	LDX #GameOver_MLName_Len	; X = GameOver_MLName_Len

PRG010_C320:
	LDY #$00	 ; Y = 0
PRG010_C322:
	LDA GameOver_MLName,X	 ; Get patterns for MARIO/LUIGI
	STA Graphics_Buffer+3,Y	 ; -> graphics buffer

	INX		 ; X++ (next name character pattern)
	INY		 ; Y++ (next graphics buffer byte)

	CPY #GameOver_MLName_Len
	BNE PRG010_C322	; While Y < GameOver_MLName_Len, loop!

	; Store VRAM high address
	LDA #$29
	STA Graphics_Buffer

	; Store run length
	LDA #(GameOver_MLName_Len-1)
	STA Graphics_Buffer+2

	; Store VRAM low address
	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	ADD #$2a
	STA Graphics_Buffer+1

	; Graphics_BufCnt += (GameOver_MLName_Len + 2)
	LDA Graphics_BufCnt
	ADD #(GameOver_MLName_Len + 2)
	STA Graphics_BufCnt

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_ConfigWorldIntro
;
; This subroutine pushes the world number and the
; player's lives counter into the intro box into
; the graphics buffer for further processing...
; Note that this is not a "friendly" function, in that
; it directly sets the graphics buffer, not inserts.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_ConfigWorldIntro:

	; High byte
	LDA #$29	 	
	STA Graphics_Buffer

	; Low byte: Calculate the proper offset address based on the horizontal scroll
	LDA <Horz_Scroll
	LSR A		 
	LSR A		 
	LSR A		 ; A = Horz_Scroll >> 3
	CLC		 
	EOR #$52
	STA Graphics_Buffer+1

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+2

	LDY World_Num	 	; Y = World_Num
	INY		 	; Worlds start at 0, so Y++
	TYA		 	; A = World_Num + 1
	ORA #$f0	 	; Offset to correct tile
	STA Graphics_Buffer+3	; Store the tile into the buffer

	; High byte
	LDA #$29	 	
	STA Graphics_Buffer+4	

	; Low byte: Calculate the proper offset address based on the horizontal scroll
	LDA <Horz_Scroll	
	LSR A		
	LSR A		
	LSR A		 ; A = Horz_Scroll >> 3
	EOR #$b4
	STA Graphics_Buffer+5

	; Run length of 2
	LDA #$02
	STA Graphics_Buffer+6

	; Takes the lives from the status bar!
	LDA StatusBar_LivesH
	STA Graphics_Buffer+7
	LDA StatusBar_LivesL
	STA Graphics_Buffer+8

	LDA #$00	
	STA Graphics_Buffer+9	 ; Terminator

	RTS		 ; Return

	; Cover map screen with black
Map_W8DarknessFill:
	LDA PPU_STAT

	; Use horizontal updates
	LDA <PPU_CTL1_Copy
	AND #~$04
	STA PPU_CTL1

	LDY #$02	 ; Y = $02

	LDX #$60	 ; X = $60 (low VRAM address)
	LDA #$28	 ; A = $28 (high VRAM address)
	STA PPU_VRAM_ADDR	; Set VRAM high address

	LDA #$80	 ; A = $80
	STA PPU_VRAM_ADDR	 ; Set VRAM low address

	LDA #$ff	 ; A = $FF (the black tile)
PRG010_C3AC:
	STA PPU_VRAM_DATA	 ; Store black pattern tile

	DEX		 ; X--
	BNE PRG010_C3AC	 ; While X <> 0, loop
 
	DEY		 ; Y--
	BPL PRG010_C3AC	 ; While Y > 0, loop

	RTS		 ; Return

Map_ScrollDeltaX:	.byte 2, -2	; Based on scroll direction, moves Horz_Scroll by this amount
Map_ScrollDeltaXHi:	.byte 0, $FF	; sign extension to above

	; The BGM per world at initial arrival (see also World_BGM in PRG030)
	; This is for when the song is delayed (e.g. by warp whistle) and plays
	; after Mario lands the map is going on normal... only triggered when
	; there is no "set 2" song playing (otherwise, doesn't matter)
World_BGM_Arrival:
	.byte MUS2A_WORLD1, MUS2A_WORLD2, MUS2A_WORLD3, MUS2A_WORLD4
	.byte MUS2A_WORLD5, MUS2A_WORLD6, MUS2A_WORLD7, MUS2A_WORLD8
	.byte MUS2A_WARPWHISTLE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoMap
;
; A very large, encompassing function which
; runs most Map_Operations and performs 
; other required tasks that keep the world
; lively and interesting...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_DoMap:
	JSR World5_Sky_AddCloudDeco	; Add world 5's cloud decoration

	LDA Map_Operation
	CMP #$0d	 
	BNE PRG010_C413	 	; If Map_Operation <> $0D (normal), jump to PRG010_C413

	; Map is operating normally
	LDX World_Num	 	; X = World_Num
	LDY World_BGM_Arrival,X	; Y = World_BGM_Arrival[X]

	CPX #$04	 
	BNE PRG010_C3E3	 	; If X <> 4 (not on World 5), jump to PRG010_C3E3

	LDX Player_Current	; X = Player_Current
	LDA <World_Map_XHi,X	
	BEQ PRG010_C3E3	 	; If not on the high part of World 5, jump to PRG010_C3E3

	LDY #MUS2A_SKY	 	; High part of World 5 uses alternate song
	JMP PRG010_C3EA	 	; Jump to PRG010_C3EA

PRG010_C3E3:
	LDA Map_MusicBox_Cnt	
	BEQ PRG010_C3EA	 	; If Map_MusicBox_Cnt = 0 (music box not active), jump to PRG010_C3EA

	LDY #MUS2A_MUSICBOX	 ; Otherwise, Y = $C (music box song)

PRG010_C3EA:
	LDA SndCur_Music2
	BNE PRG010_C3F2	 	; If SndCur_Music2 <> 0 (a song from set 2 is playing), jump to PRG010_C3F2

	; Otherwise, queue the requested song!
	STY Sound_QMusic2	

PRG010_C3F2:
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_Move,X
	BNE PRG010_C40C	 	; If Player is moving on the map, jump to PRG010_C40C

	LDA Map_MoveRepeat,X
	CMP #$18	 
	BEQ PRG010_C403	 	; If at the movement repeat limit, jump to PRG010_C403

	; Otherwise...
	INC Map_MoveRepeat,X	; Map_MoveRepeat++

PRG010_C403:
	LDA <Pad_Holding
	BNE PRG010_C40C	 	; If Pad_Holding <> 0, jump to PRG010_C40C

	; Player has stopped holding a direction; stop the repeat
	LDA #$ff	 
	STA Map_MoveRepeat,X	; Otherwise, Map_MoveRepeat = $FF

PRG010_C40C:
	LDA <Map_WarpWind_FX
	BEQ PRG010_C413	 		; If Map_WarpWind_FX = 0 (no warp wind happening), jump to PRG010_C413
	JMP Map_DoMap_WarpWind_FX	; Do the warp wind effect!

PRG010_C413:
	LDA Map_Pan_Count
	BNE PRG010_C43C	 	; If map is panning, jump to PRG010_C43C

	LDX Player_Current	; X = Player_Current
	LDA <World_Map_Move,X
	BNE PRG010_C46B	 	; If Player is moving on map, jump to PRG010_C46B

	LDA Map_Operation
	CMP #$0d	 
	BNE PRG010_C46B	 	; If Map_Operation <> $D (Normal), jump to PRG010_C46B

	LDA <Pad_Input
	AND #PAD_B	
	BEQ PRG010_C46B		; If Player is NOT pressing B, jump to PRG010_C46B

	; Player is pressing B button...
	LDA #SND_MAPINVENTORYFLIP	 
	STA Sound_QMap	 	; Play inventory opening sound

	LDA Inventory_Open
	EOR #$01	 	
	STA Inventory_Open	; Toggle the Inventory_Open flag

	JMP WorldMap_UpdateAndDraw	; Jump into WorldMap_UpdateAndDraw...

PRG010_C43C:
	LDA Map_DrawPanState
	BEQ PRG010_C447	 	; If Map_DrawPanState = 0, jump to PRG010_C447

	JSR Map_DrawAndPan	 	; Otherwise, call the dynamic jump routine required!
	JMP WorldMap_UpdateAndDraw	; Jump into WorldMap_UpdateAndDraw...

PRG010_C447:
	LDY <Scroll_LastDir
	LDA <Horz_Scroll
	ADD Map_ScrollDeltaX,Y
	STA <Horz_Scroll	 ; Horz_Scroll += Map_ScrollDeltaX[Y] (scroll in proper direction by delta amount)
	STA <Scroll_Temp	 ; Scroll_Temp = Horz_Scroll

	LDA <Horz_Scroll_Hi
	ADC Map_ScrollDeltaXHi,Y	
	STA <Horz_Scroll_Hi	; Add carry if needed!

	JSR Scroll_Update_Ranges	; Update Scroll column values
	JSR Scroll_Update	 	; Render new column of tiles if needed
	JSR Scroll_Map_SpriteBorder	; Keep up the map's sprite border

	DEC Map_Pan_Count
	DEC Map_Pan_Count 	; Map_Pan_Count -= 2
	BEQ PRG010_C470	 	; If Map_Pan_Count = 0, jump to PRG010_C470

PRG010_C46B:
	LDA Map_DrawPanState	
	BEQ PRG010_C481	 	; If Map_DrawPanState = 0, jump to PRG010_C481

PRG010_C470:
	JSR Map_DrawAndPan	 	; Otherwise, call the dynamic jump routine required!
	JSR WorldMap_UpdateAndDraw	; Update and draw the world map

	LDA Map_DrawPanState
	BNE PRG010_C481	 		; If Map_DrawPanState <> 0, jump to PRG010_C481

	LDA #$01
	STA World_EnterState	 ; World_EnterState = 1

	RTS		 ; Return

PRG010_C481:

	; If the first map object's actual Y is not zero, jump to Map_DoOperation (??  Why??)
	LDA Map_Object_ActY
	BNE Map_DoOperation	 	; If Map_Object_ActY <> 0, jump to Map_DoOperation

	; For all objects $D - $0...
	LDY #(MAPOBJ_TOTAL-1)
PRG010_C488:
	; Copy object's Y and XHi/Los into their display variables
	LDA Map_Objects_Y,Y
	STA Map_Object_ActY,Y
	LDA Map_Objects_XHi,Y
	STA Map_Object_ActXH,Y
	LDA Map_Objects_XLo,Y
	STA Map_Object_ActX,Y

	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_CANOE
	BGE PRG010_C4A9		; If object ID >= MAPOBJ_CANOE, jump to PRG010_C4A9

	; All other objects get a random number of 0-3 assigned to their "data" field
	LDA RandomN,Y
	AND #$03	
	STA Map_Object_Data,Y

PRG010_C4A9:
	DEY		 ; Y--
	BPL PRG010_C488	 ; If Y >= 0, loop!

Map_DoOperation:
	LDA Map_Operation
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word MO_WorldXIntro	; 0 - "World X" Intro (the box, erasing it, and the stars)
	.word MO_SwitchToMO_D	; 1 - Just switches to Map_Operation = $D
	.word MO_SkidToPrev	; 2 - "Skid" backwards from death (short distance, same map screen)
	.word MO_SkidToPrevAfar	; 3 - "Skid" backwards from death, from far away (different map screen); this skids from the far end...
	.word MO_SkidAfarPrep	; 4 - Prepare to finish skid from afar
	.word MO_SkidAfarFinish	; 5 - Finish the far away skidding
	.word MO_Wait14Ticks	; 6 - Loads 14 ticks and wait for it
	.word MO_DoLevelClear	; 7 - Do level completion effect
	.word MO_DoFortressFX	; 8 - If any Poof-then-Fortress effect (e.g. busting a lock) to do, do it!
	.word MO_CheckForBonus	; 9 - Check for any map bonuses to appear (White Toad House, Coin Ship)
	.word MO_Wait14Ticks	; A - Loads 14 ticks and wait for it
	.word MO_HammerBroMarch	; B - Map Hammer brother march around (mostly handled elsewhere instead of this state routine)
	.word MO_Wait8Proceed	; C - After 8 ticks, resume normal operations (if 1P game or didn't end turn), or else go to state $0F
	.word MO_NormalMoveEnter; D - "Normal" map operations; move on map (paths, canoe, bridges etc.), enter levels (including 2P vs and hand trap random)
	.word MO_HandTrap	; E - Hand trap gotcha!

	; NOTE: There is a Map_Operation $F (edge scroll) and Map_Operation $10 (enter level)
	; that are not in this jump table, but handled explicitly...

World5_Sky_CloudDeco:
	; Sprite data of a single cloud over the lower world
	.byte $30, $7D, $03, $48, $30, $7F, $03, $50, $30, $A3, $03, $58, $30, $A5, $03, $60
World5_Sky_CloudDeco_End

World5_Sky_AddCloudDeco:
	; All this does is on World 5, Sky part ONLY, add a cloud
	; Maybe there was to be intention of other map graphic decorations?

	LDA World_Num	 ; A = World_Num
	CMP #4
	BNE PRG010_C4F9	 ; If World_Num <> 4 (World 5), jump to PRG010_C4F9 (RTS)

	; World 5 only!
	LDX Player_Current	; X = Player_Current
	LDA <World_Map_XHi,X	; A = Player's X Hi byte (to determine if we're on the Sky part of W5)
	BEQ PRG010_C4F9	 	; If not on World 5 sky screen, jump to PRG010_C4F9 (RTS)

	; World 5 Sky only!

	; Copy in the cloud sprite data
	LDY #(World5_Sky_CloudDeco_End - World5_Sky_CloudDeco - 1)
PRG010_C4F0:
	LDA World5_Sky_CloudDeco,Y
	STA Sprite_RAM+$50,Y
	DEY		 	; Y--
	BPL PRG010_C4F0	 	; While Y >= 0, loop!

PRG010_C4F9:
	RTS		 ; Return


MO_WorldXIntro:
	; Process by current World_EnterState value...
	LDA World_EnterState
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word WorldIntro_BoxTimer	; 0 - Draws Player sprite in "World X" box, and delays until Map_Intro_Tick = 0
	.word WorldIntro_EraseAndStars	; 1 - Erases the "World X" intro box and does the starry intro
	.word WorldIntro_CompleteStars	; 2 - Complete the starry intro

WorldIntro_BoxTimer:
	JSR Map_WorldIntro_DrawPlayer	 ; Put in the tiny player symbol

WorldIntro_BoxTimer_NoSym:
	LDA Map_Intro_Tick
	BNE PRG010_C513	 	; If Map_Intro_Tick <> 0, jump to PRG010_C513

	; This initializes it, since if the world intro box is new, this is zero
	LDA #$80
	STA Map_Intro_Tick	; Map_Intro_Tick = $80

PRG010_C513:
	DEC Map_Intro_Tick	; Map_Intro_Tick--
	BNE PRG010_C51B	 	; If Map_Intro_Tick <> 0, jump to PRG010_C51B

	; Map_Intro_Tick expired
	INC World_EnterState	; Go to next state!

PRG010_C51B:
	RTS		 ; Return


	; This defines two sprites to make up the Player's current powerup
Map_WorldIntro_PSpr:
	.byte $63, $ED, $03, $78	; Left half of Player sprite
	.byte $63, $EF, $03, $80	; Right half of Player sprite

	; This defines the first pattern to use for the Player sprite based on powerup
	; The second pattern is implicitly +2 to this value
Map_WorldIntro_PSPat:
	.byte $ED	; 0 - Small
	.byte $2D	; 1 - Big
	.byte $2D	; 2 - Fire
	.byte $2D	; 3 - Leaf
	.byte $89	; 4 - Frog
	.byte $79	; 5 - Tanooki
	.byte $4B	; 6 - Hammer


	; Draws the tiny Player icon in the world intro box
Map_WorldIntro_DrawPlayer:

	; Copies in the 2 sprites from Map_WorldIntro_PSpr
	LDY #$07	 ; Y = 7
PRG010_C52D:
	LDA Map_WorldIntro_PSpr,Y
	STA Sprite_RAM+$84,Y	
	DEY		 	; Y--
	BPL PRG010_C52D	 	; While Y >= 0, loop!

	LDX Player_Current	 
	LDY World_Map_Power,X	 
	LDA Map_WorldIntro_PSPat,Y	; Get pattern to use based on Player's current powerup
	STA Sprite_RAM+$85	 	; Store as pattern

	ADD #$02	 
	STA Sprite_RAM+$89	 	; Opposite side is prior value + 2

	RTS		 	; Return...

	RTS		 ; Return

WorldIntro_EraseAndStars:
	;;; [ORANGE] Utilize this state to allow us to interact with NPCs
	;;;JSR Map_Intro_Erase1Strip	; Erase one strip of the "World X" Intro box
	JSR WorldIntro_Or_NPCInteraction
	JMP MapStarsIntro_DoStarFX	 		; Jump to PRG010_B76C

	; Provides "Video_Upd_Table" format Graphics_Buffer data specifically
	; for eradicating the "World X" intro from a dark World 8 map
	; The low bytes of the video address are replaced with the appropriate offset
Map_W8Dark_IntroCover:
	vaddr $2900
	.byte VU_VERT | 8
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF 

	vaddr $2900
	.byte VU_VERT | 8
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF


; Map_Intro_Erase1Strip
;
; Erases one "strip" of 16x16 tiles to clear the "World X" intro box (or Gameover!) box
; It's important to note that it's done one strip at a time, not at once!
Map_Intro_Erase1Strip:

	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA <Map_IntBoxErase
	BNE PRG010_C5A9	 	; If Map_IntBoxErase <> 0, jump to PRG010_C5A9

	; Map_IntBoxErase is set to offset of upper-left corner of "World X" 
	; intro box to tell where to start copying the map tiles from!
	LDA <Scroll_ColumnR
	AND #$08	 
	ADD #$34
	STA <Map_IntBoxErase	; Map_IntBoxErase = (Scroll_ColumnR & 8) + $34

	LDA <Scroll_ColumnL
	AND #$f0	
	LSR A		
	LSR A		
	LSR A		
	TAY		 	; Y = (Scroll_ColumnL & $F0) >> 3 (basically current "screen" of map * 2, for indexing Tile_Mem_Addr)

	; Store starting offset for this map screen into Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Effectively adds $100 to the address (maps get loaded at screen base + $110)


	; Calculates the base offset into the nametable for erasing the "World X" intro box
	LDA <Scroll_ColumnR
	AND #$08	 	; 0 or 8, depending if we're scrolled "halfway" across two screens
	ASL A		 	; Now 0 or 16
	ADD #$08	 	; Now 8 or 24
	STA <Map_Intro_NTOff	; Map_Intro_NTOff = 8 or 24

	; Calculates the corresponding offset to the attribute table
	LDA <Horz_Scroll
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A			; Divide by 32 because EACH attribute BYTE defines FOUR 8x8 tiles (4 * 8 = 32)
	ADD #$d2	
	STA <Map_Intro_ATOff		; Map_Intro_ATOff = (Horz_Scroll / 32) + $D2

	LDA #$02	
	STA <Map_StarsState		; Map_StarsState = 2

PRG010_C5A9:
	LDA World_8_Dark
	BEQ PRG010_C5C5		; If World_8_Dark = 0 (no darkness effect), jump to PRG010_C5C5

	; The World 8 Darkness effect version of clearing the World X intro box...

	; Copy Map_W8Dark_IntroCover into the Graphics_Buffer
	LDY #$15	 	
PRG010_C5B0:
	LDA Map_W8Dark_IntroCover,Y	
	STA Graphics_Buffer,Y	 	
	DEY		 		; Y--
	BPL PRG010_C5B0	 		; While Y >= 0, loop!

	; Patch in the correct low byte for the video address
	LDX <Map_Intro_NTOff		
	STX Graphics_Buffer+1	
	INX		 
	STX Graphics_Buffer+$C
	JMP PRG010_C622	 		; Jump to PRG010_C622

PRG010_C5C5:
	LDA Map_IntBoxErase	 
	STA <Temp_Var1		 	; Temp_Var1 = Map_IntBoxErase

	LDX #$00	 		; X = 0

PRG010_C5CC:	
	; CHECKME: Isn't Level_Tileset always equal to zero on world maps??
	; Probably wouldn't matter since PAGE_A000 is hard-coded to 12,
	; instead of using Page_Per_Tileset like it ought to :)
	LDA Level_Tileset
	ASL A		 
	TAY		 		; Y = Level_Tileset << 1 (for indexing TileLayout_ByTileset)

	; Set Temp_Var15 to point to the 16x16 tile 8x8 layout data
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var15		 
	LDA TileLayout_ByTileset+1,Y
	STA <Temp_Var16	

	LDY <Temp_Var1		 	; Get offset to current 16x16 tile we want to grab
	LDA [Map_Tile_AddrL],Y	 	; Grab it!
	TAY		 		; Y = tile

	; The 16x16 tile is laid out in four 256 byte sized "chunks" which define each 8x8
	; in the order of upper-left, lower-left, upper-right, lower-right

	; Upper-left
	LDA [Temp_Var15],Y	 	; Get first 8x8
	STA Scroll_PatStrip,X	 	; Store this 8x8 into the vertical strip

	; Lower-left
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+1,X	; Store this 8x8 into vertical strip, next slot to the right

	; Upper-right
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+$B,X	; Store into vertical strip

	; Lower-right
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+$C,X	; Store into vertical strip

	LDA <Temp_Var1	
	ADD #16	
	STA <Temp_Var1		 	; Temp_Var1 += 16 (get next tile one row down)

	INX
	INX		; X += 2 (next block down in Scroll_PatStrip)

	CPX #$08	
	BNE PRG010_C5CC	; If X <> 8 (4 tiles downward in Scroll_PatStrip), loop!

	; Pushes the Scroll_PatStrip memory into the Graphics_Buffer
	LDX #$12	 		; X = $12
PRG010_C609:
	LDA Scroll_PatStrip,X
	STA Graphics_Buffer+3,X
	DEX		 		; X--
	BPL PRG010_C609	 		; If X >= 0, loop!

	; Used VRAM addr $29xx for both strips
	LDA #$29	 
	STA Graphics_Buffer	
	STA Graphics_Buffer+$B
	
	LDA #(VU_VERT | 8)		; 8 8x8s vertically applied
	STA Graphics_Buffer+2
	STA Graphics_Buffer+$D

PRG010_C622:
	LDX <Map_Intro_NTOff		
	STX Graphics_Buffer+1	 	; Store lower part of VRAM address
	INX		 
	STX Graphics_Buffer+$C	 	; Store lower part of VRAM address


	; Now it's the attribute table's turn...

	; Store VRAM addr $2Bxx
	LDA #$2b
	STA Graphics_Buffer+$16
	STA Graphics_Buffer+$1A

	; Store lower part of VRAM address
	LDA <Map_Intro_ATOff	
	STA Graphics_Buffer+$17
	ADD #$08	 
	STA Graphics_Buffer+$1B

	; Just one byte to copy
	LDA #$01
	STA Graphics_Buffer+$18
	STA Graphics_Buffer+$1C

	LDA <Map_Intro_CurStripe
	AND #$06	
	LSR A		
	TAX		 ; X = (Map_Intro_CurStripe & 6) >> 1

	LDA <Scroll_ColorStrip,X
	STA Graphics_Buffer+$19	

	LDA <Scroll_ColorStrip+4,X	
	STA Graphics_Buffer+$1D	

	LDA <Map_Intro_CurStripe		
	AND #$01	 
	BNE PRG010_C66A	 	; If Map_Intro_CurStripe bit 0 set, jump to PRG010_C66A

	; Otherwise...
	LDA <Scroll_ColorStrip,X
	AND #$33	 
	STA Graphics_Buffer+$19

	LDA <Scroll_ColorStrip+4,X	
	AND #$33	 	
	STA Graphics_Buffer+$1D	

PRG010_C66A:
	LDA #$00	 
	STA Graphics_Buffer+$1E

	; If, on the next increment to Map_IntBoxErase, the lower 4 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_IntBoxErase
	INX		
	TXA		
	AND #$0f	 	
	BNE PRG010_C689	 	; If (Map_IntBoxErase + 1) & $0F is non-zero, jump to PRG010_C689

	; Otherwise, we need to update the address
	LDA <Map_Tile_AddrL
	ADD #$b0
	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $B0 (11 tiles over)

	LDA <Map_Tile_AddrH
	ADC #$01	 
	STA <Map_Tile_AddrH	; Next screen plus add carry if needed

	LDA <Map_IntBoxErase
	AND #$f0	 	
	TAX		 	; X = (Map_IntBoxErase & $F0); current row within map "screen" of tiles

PRG010_C689:
	STX <Map_IntBoxErase	; Update Map_IntBoxErase

	TXA		
	AND #$01	
	BNE PRG010_C69F	 	; If (Map_IntBoxErase & 1) <> 0 (if we're on an "odd" tile), jump to PRG010_C69F

	; Otherwise need to update the attribute stuff!

	; If, on the next increment to Map_Intro_ATOff, the lower 3 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_Intro_ATOff
	INX
	TXA
	AND #$07
	BNE PRG010_C69D	 	; If (Map_Intro_ATOff + 1) & 7 <> 0, jump to PRG010_C69D

	LDA <Map_Intro_ATOff
	AND #$f0	 
	TAX		 	; X contains just the upper 4 bits of Map_Intro_ATOff

PRG010_C69D:
	STX <Map_Intro_ATOff	; Update Map_Intro_ATOff


PRG010_C69F

	; If, on the next +2 to Map_Intro_NTOff, the lower 5 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_Intro_NTOff
	INX
	INX
	TXA
	AND #$1f
	BNE PRG010_C6AA		; If (Map_Intro_NTOff + 1) & $1f <> 0, jump to PRG010_C6AA

	LDX #$00	 	; X = 0

PRG010_C6AA:
	STX <Map_Intro_NTOff	; Update Map_Intro_NTOff

	INC <Map_Intro_CurStripe ; Map_Intro_CurStripe++

	LDA <Map_Intro_CurStripe
	CMP #$08	 
	BNE PRG010_C6BB	 	; If Map_Intro_CurStripe <> 8, jump to PRG010_C6BB

	; Otherwise, we're done!  The stupid box is erased!
	LDA #$00
	STA <Map_IntBoxErase	; Map_IntBoxErase = 0
	INC World_EnterState	; Next state!  (NOTE: Gameover uses this too, so GameOver_State, which is the same memory)

PRG010_C6BB:
	; In any case, put page 11 back in at A000
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	RTS		 ; Return

WorldIntro_CompleteStars:
	JSR MapStarsIntro_DoStarFX	; Continue updating starry intro until complete
	LDA Map_StarFX_State	 
	BNE PRG010_C6D7		; If Map_StarFX_State <> 0, jump to PRG010_C6D7 (RTS)

	; Star intro is over!

	INC Map_Operation	; Next Map_Operation...

	LDA #$00
	STA World_EnterState	; World_EnterState = 0

	JMP Map_DrawPlayer	; Jump to Map_DrawPlayer

PRG010_C6D7:
	RTS		 ; Return

GameOver_Complete:
	LDA Map_Intro_Tick
	BNE PRG010_C6E2	 ; If Map_Intro_Tick <> 0, jump to PRG010_C6E2

	; Map_Intro_Tick = $10
	LDA #$10
	STA Map_Intro_Tick

PRG010_C6E2:
	JSR PRG010_C513

	LDA Map_Intro_Tick
	BNE PRG010_C6EF	 ; If Map_Intro_Tick <> 0, jump to PRG010_C6EF

	LDA #$00
	STA Map_Object_ActY

PRG010_C6EF:
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

GameOver_Loop:
	LDA GameOver_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GameOver_WaitOnBGM	; 0: Wait for "Game Over" music to finish
	.word GameOver_DoMenu		; 1: Player selects action

	; Player selected CONTINUE...
	.word Map_Intro_Erase1Strip	; 2: Erase the Gameover box
	.word GameOver_Timeout		; 3: Short timeout before we decide what to do next
	.word GameOver_TwirlToStart	; 4: Player twirls back to map start (jumps to State 8 after this)
	.word GameOver_TwirlFromAfar	; 5: Player twirling in from far away; pretty much straight left
	.word GameOver_AlignToStartY	; 6: Player aligns to starting map Y
	.word GameOver_ReturnToStartX	; 7: Player slides back to starting X
	.word GameOver_Complete		; 8: Complete the sequence

	; NOTE: GameOver_State = 9 is handled specially outside of this routine

GameOver_WaitOnBGM:
	LDA SndCur_Music1	 
	BNE PRG010_C712	 ; If Game Over music is still playing, jump to PRG010_C712

	INC GameOver_State	 ; GameOver_State++

PRG010_C712:
	JMP PRG010_C772	 ; Jump to PRG010_C772

GameOver_DoMenu:
	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG010_C72B	 ; If Player is pressing neither UP nor DOWN, jump to PRG010_C72B

	; Play the bleep noise
	LDA #SND_MAPPATHMOVE
	STA Sound_QMap

	; Switch between $60/$68 (cursor up and down)
	LDA Map_GameOver_CursorY
	EOR #$08
	STA Map_GameOver_CursorY

	JMP PRG010_C748	 ; Jump to PRG010_C748

PRG010_C72B:

	; Player not pressing UP or DOWN...

	LDA <Pad_Input
	AND #PAD_START
	BEQ PRG010_C748	 ; If Player is NOT pressing START, jump to PRG010_C748

	; Play the starry entrance sound (this is never heard!)
	LDA #SND_MAPENTERWORLD
	STA Sound_QLevel1

	LDX #$09	 ; X = 9 (Player selects END)
	LDA Map_GameOver_CursorY

	AND #$08
	BNE PRG010_C741	 ; If Player selected "END", jump to PRG010_C741

	LDX #$02	 ; X = 2 (Player selects CONTINUE)

PRG010_C741:
	STX GameOver_State	 ; Set GameOver_State appropriately

	; Map_UnusedGOFlag = $F8 
	LDA #$f8
	STA <Map_UnusedGOFlag

PRG010_C748:
	; Clear all the map object Y to $F8 (off-screen)!
	LDY #$0d	 ; Y = $D
	LDA #$f8	 ; A = $F8
PRG010_C74C:
	STA Map_Object_ActY,Y	 ; -> map object's Y
	DEY		 ; Y--
	BPL PRG010_C74C	 ; While Y >= 0, loop!

	JMP PRG010_C75D	 ; Jump to PRG010_C75D

GameOver_DeadPlayerSprite:
	.byte $64, $61, $00, $50	; Left half
	.byte $64, $61, $40, $58	; Right half
	
PRG010_C75D:

	; Set game over action cursor Y
	LDA Map_GameOver_CursorY
	STA Sprite_RAM+$94

	; Set game over action cursor pattern
	LDA #$6f
	STA Sprite_RAM+$95

	; Set game over action cursor attributes
	LDA #SPR_PAL0
	STA Sprite_RAM+$96

	; Set game over action cursor X
	LDA #$68
	STA Sprite_RAM+$97

	; Generate the little "dead Player" sprite in the Game Over box
PRG010_C772:
	LDY #$07	 ; Y = 7
PRG010_C774:
	LDA GameOver_DeadPlayerSprite,Y	 ; Get dead player sprite byte
	STA Sprite_RAM+$84,Y	 ; Store into Sprite_RAM

	DEY		 ; Y--
	BPL PRG010_C774	 ; While Y >= 0, loop!

	RTS		 ; Return

GameOver_Timeout:
	LDA Map_Intro_Tick
	BNE PRG010_C788	 ; If Map_Intro_Tick <> 0, jump to PRG010_C788

	; Map_Intro_Tick = $10 -- short version
	LDA #$10
	STA Map_Intro_Tick

PRG010_C788:
	JSR WorldIntro_BoxTimer_NoSym	 ; Just delay until Map_Intro_Tick = 0

	LDA GameOver_State
	CMP #$04
	BNE PRG010_C79D	 ; If GameOver_State <> 4 (4 means timer expired, went to next state), jump to PRG010_C79D (WorldMap_UpdateAndDraw)

	; We're in state 4 now... (this will be for one cycle only, we're on our way out)

	LDA <Horz_Scroll_Hi
	BNE PRG010_C79A	 ; If not back on the first map screen yet, jump to PRG010_C79A

	LDA <Horz_Scroll
	BEQ PRG010_C79D	 ; If on the first map screen hard left, jump to PRG010_C79D (WorldMap_UpdateAndDraw)

PRG010_C79A:

	; In some way we're not all the way to the left on the map at this time...

	INC GameOver_State	 ; GameOver_State++

PRG010_C79D:
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

MO_SwitchToMO_D:
	; Kind of a silly and pointless Map_Operation; maybe they intended for more here?
	LDA #$0d
	STA Map_Operation	; Map_Operation = $D
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

MO_Wait14Ticks:
	LDA Map_Intro_Tick
	BNE PRG010_C7B2	 ; If Map_Intro_Tick <> 0, jump to PRG010_C7B2

	; Map_Intro_Tick = 14
	LDA #14
	STA Map_Intro_Tick

PRG010_C7B2:
	DEC Map_Intro_Tick	; Map_Intro_Tick--
	BNE PRG010_C7BA	 	; If Map_Intro_Tick <> 0, jump to PRG010_C7BA

	INC Map_Operation	; Map_Operation++

PRG010_C7BA:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw map and don't come back

	; Indexed by value from FortressFX_Wx
	; 		        0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F   10
FortressFX_VAddrH:	.byte $2A, $2A, $2A, $29, $29, $29, $29, $29, $29, $28, $29, $29, $29, $29, $29, $29, $29
FortressFX_VAddrL:	.byte $06, $50, $12, $4C, $06, $96, $86, $8E, $9A, $92, $8A, $1A, $CE, $10, $52, $98, $CA

	; Indexed by value from FortressFX_Wx
	; Stores the column index for Map_Completions followed by which
	; bit of Map_Completions is to be set to "clear" whatever lock
	; is now busted or bridge constructed...
FortressFX_MapCompIdx:
	.byte $03, $02	; 0	[ORANGE] our secret bridge
	.byte $08, $01	; 1
	.byte $09, $02	; 2
	.byte $16, $10	; 3
	.byte $13, $20	; 4
	.byte $0B, $08	; 5
	.byte $03, $08	; 6
	.byte $17, $08	; 7
	.byte $0D, $08	; 8
	.byte $19, $80	; 9
	.byte $25, $08	; A
	.byte $0D, $20	; B
	.byte $17, $04	; C
	.byte $08, $20	; D
	.byte $19, $10	; E
	.byte $2C, $08	; F
	.byte $35, $04	; 10

	; Indexed by value from FortressFX_Wx
	; Patterns to overwrite to cause the disappearance of a lock
	; or creation of a bridge, whatever is appropriate
FortressFX_Patterns:
	.byte $D4, $D6, $D5, $D7	; 0 [ORANGE] modded to be a bridge
	.byte $FE, $C0, $FE, $C0	; 1
	.byte $FE, $FE, $E1, $E1	; 2
	.byte $FE, $C0, $FE, $C0	; 3
	.byte $FE, $FE, $E1, $E1	; 4
	.byte $D4, $D6, $D5, $D7	; 5
	.byte $D4, $D6, $D5, $D7	; 6
	.byte $FE, $FE, $E1, $E1	; 7
	.byte $FE, $FE, $E1, $E1	; 8
	.byte $D4, $D6, $D5, $D7	; 9
	.byte $FE, $FE, $E1, $E1	; A
	.byte $FE, $C0, $FE, $C0	; B
	.byte $FE, $FE, $E1, $E1	; C
	.byte $FE, $C0, $FE, $C0	; D
	.byte $FE, $FE, $E1, $E1	; E
	.byte $FF, $FF, $FF, $FF	; F (Makes an all black square in the dark)
	.byte $FE, $FE, $E1, $E1	; 10

	; Indexed by value from FortressFX_Wx
	; The related "row" for the FortressFX_MapLocation
FortressFX_MapLocationRow:
	.byte $80, $90, $80, $50, $40, $60, $60, $60, $60, $20, $60, $40, $70, $40, $50, $60, $70

	; Indexed by value from FortressFX_Wx
	; Selects location of tile to bust out
	; Lower 4 bits are the "screen", upper 4 bits are the column
FortressFX_MapLocation:
	.byte $30, $80, $90, $61, $31, $B0, $30, $71, $D0, $91, $52, $D0, $71, $80, $91, $C2, $53

FortressFX_MapTileReplace:
	.byte TILE_BRIDGE, $46, $45, $46, $45, $B3, $B3, $DA, $DA, $B3, $45, $46, $45, $46, $45, $46, $45

	; Defines slots for post-Mini-Fortress events; since this is looked up 
	; by an index table (FortressFXBase_ByWorld), there's no need for this 
	; to be precisely four in every world, but that's what they allocated...
FortressFX_W1:	.byte $00, $00, $00, $00
FortressFX_W2:	.byte $01, $00, $00, $00
FortressFX_W3:	.byte $02, $03, $00, $00
FortressFX_W4:	.byte $04, $05, $00, $00
FortressFX_W5:	.byte $06, $07, $00, $00
FortressFX_W6:	.byte $08, $09, $0A, $00
FortressFX_W7:	.byte $0B, $0C, $00, $00
FortressFX_W8:	.byte $0D, $0E, $0F, $10

FFX_Off	.func	(\1 - FortressFX_W1)

FortressFXBase_ByWorld:
	.byte FFX_Off(FortressFX_W1)	; World 1
	.byte FFX_Off(FortressFX_W2)	; World 2
	.byte FFX_Off(FortressFX_W3)	; World 3
	.byte FFX_Off(FortressFX_W4)	; World 4
	.byte FFX_Off(FortressFX_W5)	; World 5
	.byte FFX_Off(FortressFX_W6)	; World 6
	.byte FFX_Off(FortressFX_W7)	; World 7
	.byte FFX_Off(FortressFX_W8)	; World 8

	; Kept going in the series... how many worlds did they think they'd need??
	.byte $20, $24, $28, $2C, $30, $34, $38, $3C, $40



MO_DoFortressFX:
	LDA <Map_ClearLevelFXCnt
	BEQ PRG010_C8B0	 ; If not already doing a "poof" effect, jump to PRG010_C8B0
	JMP PRG010_C9A4	 ; Otherwise, jump to PRG010_C9A4

PRG010_C8B0:
	LDA Map_DoFortressFX
	BNE PRG010_C8B8	 ; If we've got some post-Mini-Fortress effect to do, jump to PRG010_C8B8
	JMP PRG010_C9D0	 ; Otherwise, jump to PRG010_C9D0

PRG010_C8B8:

	; Got a post-Mini-Fortress effect to do

	LDA Map_Intro_Tick
	BNE PRG010_C8C2	 ; If tick counter <> 0, jump to PRG010_C8C2

	; Otherwise, Map_Intro_Tick = $20
	LDA #$20
	STA Map_Intro_Tick

PRG010_C8C2:
	JSR FX_MonoFlash_By_MapTick	; Do "flash" effect while busting lock / creating bridge / etc.

	LDA Map_Intro_Tick
	BEQ PRG010_C8CD	 ; If Map_Intro_Tick = 0, jump to PRG010_C8CD

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_C8CD:
	DEC Map_DoFortressFX	 ; Map_DoFortressFX-- (normalize the index, since Boom Boom should set this at 1+)

	; Play Magic sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

	LDY World_Num	 ; Y = World_Num

	LDA FortressFXBase_ByWorld,Y	; Get base index for this world
	ADD Map_DoFortressFX	 	; Add specific index
	TAY		 ; -> 'Y'

	; Reassign Map_DoFortressFX to the retrieved slot index
	LDA FortressFX_W1,Y
	STA Map_DoFortressFX

	; Set poof counter
	LDA #$01
	STA <Map_ClearLevelFXCnt

	LDY Graphics_BufCnt	 ; Y = current graphics buffer count
	LDX Map_DoFortressFX	 ; X = Mini Fortress effect slot index

	; Get appropriate high byte of VRAM address -> Temp_Var11
	LDA FortressFX_VAddrH,X
	STA <Temp_Var11	
	STA Graphics_Buffer,Y	; ... and into Graphics Buffer

	INY		 ; Y++ (next byte in graphics buffer)

	; Get appropriate low byte of VRAM address -> Temp_Var12
	LDA FortressFX_VAddrL,X
	STA <Temp_Var12	
	STA Graphics_Buffer,Y	; ... and into Graphics Buffer

	INY		 ; Y++ (next byte in graphics buffer)

	; Mark a 2 byte run
	LDA #$02
	STA Graphics_Buffer,Y
	INY		 ; Y++ (next byte in graphics buffer)

	LDA Map_DoFortressFX
	ASL A
	ASL A
	TAX		 ; X = Map_DoFortressFX * 4 (four 8x8 tiles per Map_DoFortressFX index)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INX		 ; X++ (next pattern)
	INY		 ; Y++ (next byte in graphics buffer)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INX		 ; X++ (next pattern)
	INY		 ; Y++ (next byte in graphics buffer)

	; 32 bytes to get to the next row (bottom half of map tile getting changed)
	LDA <Temp_Var12
	ADD #32
	STA <Temp_Var12
	LDA <Temp_Var11
	ADC #$00
	STA <Temp_Var11

	STA Graphics_Buffer,Y	 ; Store new high byte

	INY		 ; Y++ (next byte in graphics buffer)

	LDA <Temp_Var12
	STA Graphics_Buffer,Y	 ; Store new low byte

	INY		 ; Y++ (next byte in graphics buffer)

	; Mark a 2 byte run
	LDA #$02
	STA Graphics_Buffer,Y
	INY		 ; Y++ (next byte in graphics buffer)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INY		 ; Y++ (next byte in graphics buffer)
	INX		 ; X++ (next pattern)

	LDA FortressFX_Patterns,X	; Get pattern
	STA Graphics_Buffer,Y	 	; Store into graphics buffer
	INY		 ; Y++ (next byte in graphics buffer)

	; Terminator!
	LDA #$00
	STA Graphics_Buffer,Y

	STY Graphics_BufCnt	 ; Update graphics buffer count

	LDA Map_DoFortressFX
	ASL A
	TAY		 ; Y = Map_DoFortressFX * 2

	; Index into Map_Completions -> Temp_Var11
	LDA FortressFX_MapCompIdx,Y
	STA <Temp_Var11

	INY		 ; Y++

	; Bit needing set on that Map_Completions column -> Temp_Var12
	LDA FortressFX_MapCompIdx,Y
	STA <Temp_Var12

	LDY <Temp_Var11
	LDA Map_Completions,Y
	AND <Temp_Var12	
	BNE PRG010_C9C9	 ; If this lock is already busted / bridge already built, jump to PRG010_C9C9

	; Mark lock busted / bridge built (Mario)
	LDA Map_Completions,Y
	ORA <Temp_Var12	
	STA Map_Completions,Y

	; Mark lock busted / bridge built (Luigi)
	LDA Map_Completions+$40,Y
	ORA <Temp_Var12	
	STA Map_Completions+$40,Y

	LDX Map_DoFortressFX
	LDA FortressFX_MapLocation,X
	AND #$0f	 ; Extract the "screen" of the map
	ASL A		 ; Convert to 2-byte index
	TAY		 ; -> 'Y'

	LDA Tile_Mem_Addr,Y	; Get low byte of address to tile memory for the specified screen
	ADD #$f0		; Offset to map level
	STA <Temp_Var15		; -> Temp_Var15

	LDA Tile_Mem_Addr+1,Y	; Get high byte of address to tile memory for the specified screen
	ADC #$00		; Apply carry
	STA <Temp_Var16		; -> Temp_Var16

	LDA FortressFX_MapLocation,X	; Get the column value
	LSR A
	LSR A
	LSR A
	LSR A				; Shift into position
	ORA FortressFX_MapLocationRow,X	 ; OR on the Row
	TAY		 ; -> 'Y'

	; Replace the tile in-memory
	LDA FortressFX_MapTileReplace,X
	STA [Temp_Var15],Y

PRG010_C9A4:
	LDA <Counter_1
	AND #$03
	BNE PRG010_C9B2	 ; Only proceed 1:4 ticks, otherwise jump to PRG010_C9B2

	INC <Map_ClearLevelFXCnt
	LDA <Map_ClearLevelFXCnt
	CMP #$07
	BEQ PRG010_C9C9	 ; Basically event ends in 7*4 = 28 ticks, then jump to PRG010_C9C9

PRG010_C9B2:
	LDY Map_DoFortressFX	 ; Y = Map_DoFortressFX

	; Store the map location pixel Y -> Temp_Var1
	LDA FortressFX_MapLocationRow,Y
	STA <Temp_Var1

	; Store the map location pixel X -> Temp_Var2
	LDA FortressFX_MapLocation,Y
	AND #$f0
	STA <Temp_Var2

	LDY <Map_ClearLevelFXCnt		 ; Y = Map_ClearLevelFXCnt
	JSR Map_DrawClearLevelPoof	 ; Draw the "poof"
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_C9C9:
	; Clear variables
	LDA #$00
	STA Map_DoFortressFX
	STA <Map_ClearLevelFXCnt

PRG010_C9D0:
	INC Map_Operation	 	; Map_Operation++
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw

FX_MonoFlash_By_MapTick:
	; Every 4 ticks, this alternates between color and mono on the PPU
	; to produce a quick and dirty "bright flash" effect
	LDA Map_Intro_Tick
	AND #$04	 	; A = Map_Intro_Tick & 4
	LSR A		 
	LSR A		 	; Shift down twice (so 0/1 toggle only, every 4 map ticks)
	ORA #$18	 	; Normal BG/sprite bits
	STA <PPU_CTL2_Copy	; Update PPU_CTL2
	DEC Map_Intro_Tick	; Map_Intro_Tick--
	RTS		 	; Return


MO_HammerBroMarch:
	LDA Map_NoLoseTurn
	BEQ PRG010_C9F2	 ; If Player's turn will end, jump to PRG010_C9F2

	; Otherwise, Map_Operation = $0C (the "Wait 8 ticks and proceed" state...)
	LDA #$0c
	STA Map_Operation

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_C9F2:
	JSR WorldMap_UpdateAndDraw	; Update and draw map

	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1) (For all map objects)
PRG010_C9F7:
	LDA Map_March_Count,Y
	BNE PRG010_CA2A	 	; If march counter <> 0, jump to PRG010_CA2A (RTS)

	DEY		 	; Y--
	BPL PRG010_C9F7		; While Y >= 0, loop

	; ALL March counters are zero...

	; First Map_March_Count = 8
	LDA #$08
	STA Map_March_Count

	INC Map_Operation	 ; Map_Operation++ (the "Wait 8 ticks and proceed" state...)

	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1) (For all map objects)
PRG010_CA09:
	LDA Map_Object_ActY,Y
	;ADD #$08	; +8
	;AND #$f0	; Align to grid
	STA Map_Objects_Y,Y	 ; -> Map object Y

	LDA Map_Object_ActX,Y
	;ADD #$08	; +8
	;AND #$f0	; Align to grid
	STA Map_Objects_XLo,Y	 ; -> Map object X

	LDA Map_Object_ActXH,Y
	ADC #$00	 ; Apply carry
	STA Map_Objects_XHi,Y	 ; -> Map object X Hi

	DEY		 	; Y--
	BPL PRG010_CA09		; While Y >= 0, loop

PRG010_CA2A:
	RTS		 ; Return


MO_Wait8Proceed:
	LDA Map_Intro_Tick
	BNE PRG010_CA35	 ; If Map_Intro_Tick <> 0, jump to PRG010_CA35

	; Map_Intro_Tick = 8
	LDA #$08
	STA Map_Intro_Tick

PRG010_CA35:
	DEC Map_Intro_Tick	 ; Map_Intro_Tick--
	BNE PRG010_CA7F	 	; If Map_Intro_Tick <> 0, jump to PRG010_CA7F

	; Map_Intro_Tick just expired...

	LDX Player_Current	 ; X = Player_Current 

	; Clear all controller input data
	LDA #$00	 
	STA <Controller1	
	STA <Controller1Press	
	STA <Controller2	
	STA <Controller2Press	

	; Stop any movement repeating
	LDA #$ff	 ; A = $FF
	STA Map_MoveRepeat,X

	LDA Map_NoLoseTurn
	BNE PRG010_CA77	 ; If Player's turn does not end (e.g. used a pipeway, Toad House, etc.), jump to PRG010_CA77

	LDA World_Num
	CMP #$02
	BNE PRG010_CA60	 ; If World_Num <> 2 (World 3), jump to PRG010_CA60

	; On World 3, toggle the bridge state
	LDA World3_Bridge
	EOR #$01
	STA World3_Bridge

PRG010_CA60:
	LDA Total_Players
	CMP #$01
	BEQ PRG010_CA77	 ; If only a 1P game, jump to PRG010_CA77

	LDX Player_Current	 ; X = Player_Current

	LDA #$01
	STA Map_Player_SkidBack,X

	; Map_Operation = $0F
	LDA #$0f
	STA Map_Operation

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_CA77:
	INC Map_Operation	 ; Map_Operation++ (Map_Operation = $0D, resume normal operations)

	; World_EnterState = 0
	LDA #$00
	STA World_EnterState

PRG010_CA7F:
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw


	; FIXME: Anybody wants to claim this??
; $CA82
	LDA World_EnterState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Map_StateNothing
	.word MO_NormalMoveEnter

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DrawAndPan
;
; Draw and perform panning on World Map
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_DrawAndPan:
	LDA Map_DrawPanState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Map_Do_Borders	; 0 - NOT USED (Map_DrawAndPan is not called if Map_DrawPanState == 0)
	.word Map_Do_Borders	; 1 - Draw left/right borders
	.word Map_DoVBorders	; 2 - Vertical border 
	.word Map_DoVBorders	; 3 - Vertical border 
	.word Map_PanInit	; 4 - Initialize map panning
	.word Map_PanRight	; 5 - Pan map to the right
	.word Map_PanLeft	; 6 - Pan map to the left
	
PRG010_CAA0:
	.byte $00, $0E

Map_Do_Borders:
	LDX <Map_ScrollOddEven	; X = Map_ScrollOddEven
	LDA <Scroll_ColumnL	; A = Scroll_ColumnL
	ADD PRG010_CAA0,X	; Add a value based on the value of Map_ScrollOddEven (0 for not entering, 1 for entering; 2 was used in Japanese version only showing the level)
	PHA			; Save A
	AND #$f0	 	; Screen only
	LSR A		 
	LSR A		 
	LSR A		 	; A >> 2 screen index
	TAY		 	; Y = A
	LDA Tile_Mem_Addr,Y	; Beginning of tiles we're going to modify
	ADD #$f0	 	; Add $f0 to it??

	; Store address into [<Map_Tile_AddrH][Map_Tile_AddrL]
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	ADC #$00	 	; if any overflow from the addition
	STA <Map_Tile_AddrH	

	PLA		 	; Restore A (Screen_ColumnL + value)
	AND #$0f	 	; Screen-relative column index 
	STA <Temp_Var5	 	; Store that to Temp_Var5
	LDX #$00	 	; X = 0
	LDA <Map_ScrollOddEven	; A = Map_ScrollOddEven
	AND #$01	 	; Check if entering
	BEQ PRG010_CACF	 	; If NOT entering, jump to PRG010_CACF
	LDX #$06	 	; Otherwise, X = 6
PRG010_CACF:
	LDY <Temp_Var5		; Y = Temp_Var5 (screen-relative column index)
	LDA [Map_Tile_AddrL],Y	; Get tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var1		; Store this into Temp_Var1
	INY		 	; Y++
	LDA [Map_Tile_AddrL],Y	; Get the next tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var2		; Store this into Temp_Var2

	TYA		 	
	ADD #15
	TAY		 	; Y += 15 (next row)

	LDA [Map_Tile_AddrL],Y	; Get this tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var3		; Store this into Temp_Var3
	INY		 	; Y++
	LDA [Map_Tile_AddrL],Y	; Get this tile
	AND #$c0	 	; Only keep its upper 2 bits ($00, $40, $80, $C0)
	STA <Temp_Var4		; Store this into Temp_Var4

	; Take the four tiles and form an attribute byte
	LDA <Temp_Var1
	LSR A		
	LSR A		
	ORA <Temp_Var2	
	LSR A		
	LSR A		
	ORA <Temp_Var3	
	LSR A		
	LSR A		
	ORA <Temp_Var4	

	STA Map_BorderAttrFromTiles,X
	INX		 ; X++

	LDA <Temp_Var5
	ADD #32
	STA <Temp_Var5	 ; Temp_Var5 += 32

	AND #$f0	 ; Only keep upper four bits of Temp_Var5
	CMP #$c0	 
	BNE PRG010_CACF	 ; If not equal to $C0, loop!

	INC Map_DrawPanState	 ; Map_DrawPanState++
	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG010_CB1E

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

PRG010_CB1E:
	JMP Scroll_Map_SpriteBorder	 ; Draw the sprite version of the border

Border_VAttrMask:	.byte $CC, $CC, $CC, $CC, $CC, $CC
			.byte $33, $33, $33, $33, $33, $33
Border_VAttrs:		.byte $11, $11, $11, $11, $11, $11	; Attributes along left vertical border
			.byte $44, $44, $44, $44, $44, $44	; Attributes along right vertical border

PRG010_CB39:
	vaddr $2BC0
	.byte $01, $00

	vaddr $2BC8
	.byte $01, $00

	vaddr $2BD0
	.byte $01, $00

	vaddr $2BD8
	.byte $01, $00

	vaddr $2BE0
	.byte $01, $00

	vaddr $2BE8
	.byte $01, $00

	.byte $00	; Terminator
PRG010_CB39_End

; FIXME: Anybody want to claim this??
; $CB52
        vaddr $2BC7
	.byte $01, $00

	vaddr $2BCF
	.byte $01, $00

	vaddr $2BD7
	.byte $01, $00

	vaddr $2BDF
	.byte $01, $00

	vaddr $2BE7
	.byte $01, $00

	vaddr $2BEF
	.byte $01, $00

	; Terminator
	.byte $00

PRG010_CB6B:
	vaddr $2860
	.byte $01, $00

	vaddr $2880
	.byte VU_VERT | VU_REPEAT | $13, $00

	vaddr $2AE0
	.byte $01, $00

	.byte $00	; Terminator
PRG010_CB6B_End

Border_TopCorners:	.byte $80, $81, $FF	; Upper left corner, upper right corner, and a black one more to the right
Border_VertEdges:	.byte $CC, $CC, $FF	; Border left, border right, and a black one more to the right
Border_BottomCorners:	.byte $82, $83, $FF	; Lower left corner, lower right corner, and a black one more to the right

VBorder_Offset:
	.byte $01, $1E, $1F


Map_DoVBorders:
	LDA Map_DrawPanState
	CMP #$02
	BNE PRG010_CBE0	 ; If Map_DrawPanState <> 2, jump to PRG010_CBE0

	LDY #(PRG010_CB6B_End - PRG010_CB6B - 1)
PRG010_CB8D:
	LDA PRG010_CB6B,Y	 ; Get graphics buffer command byte
	STA Graphics_Buffer,Y	 ; Store into graphics buffer

	DEY		 ; Y--
	BPL PRG010_CB8D	; While Y >= 0, loop

	LDX <Map_ScrollOddEven		 ; X = Map_ScrollOddEven

	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	EOR VBorder_Offset,X
	STA <Temp_Var1

	LDY #$02	 ; Y = 2
	LDX #$00	 ; X = 0
PRG010_CBA6:
	LDA Graphics_Buffer+1,X
	EOR <Temp_Var1
	STA Graphics_Buffer+1,X

	INX
	INX
	INX
	INX	; X += 4

	DEY		 ; Y--
	BPL PRG010_CBA6	; While Y >= 0, loop

	LDY <Map_ScrollOddEven	 ; Y = Map_ScrollOddEven

	LDA Border_TopCorners,Y
	STA Graphics_Buffer+3

	LDA Border_VertEdges,Y
	STA Graphics_Buffer+7

	LDA Border_BottomCorners,Y
	STA Graphics_Buffer+$B

	; Graphics_BufCnt = 12
	LDA #12
	STA Graphics_BufCnt

	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	CMP #$03
	BNE PRG010_CBDD	 ; If Map_ScrollOddEven <> 3, jump to PRG010_CBDD

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

	INC Map_DrawPanState	 ; Map_DrawPanState++

PRG010_CBDD:
	JMP Scroll_Map_SpriteBorder	 ; Draw sprite border and don't come back!

PRG010_CBE0:
	LDY #(PRG010_CB39_End - PRG010_CB39 - 1)
	LDX #(PRG010_CB39_End - PRG010_CB39 - 1)

	LDA <Map_ScrollOddEven
	BEQ PRG010_CBEA	 ; If Map_ScrollOddEven = 0, jump to PRG010_CBEA

	LDX #$31	 ; X = $31

PRG010_CBEA:
	LDA PRG010_CB39,X	 ; Get graphics buffer command byte
	STA Graphics_Buffer,Y	 ; Store into graphics buffer

	DEX		 ; X--
	DEY		 ; Y--
	BPL PRG010_CBEA	 ; While Y >= 0, loop

	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1

	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0

	; Temp_Var2 = 5
	LDA #$05
	STA <Temp_Var2

	LDA <Map_ScrollOddEven
	BEQ PRG010_CC0B	 ; If Map_ScrollOddEven = 0, jump to PRG010_CC0B

	LDY #$06	 ; Y = 6

PRG010_CC0B: 

	; Set VRAM low address in graphics buffer
	LDA Graphics_Buffer+1,X
	EOR <Temp_Var1
	STA Graphics_Buffer+1,X

	LDA Map_BorderAttrFromTiles,Y
	AND Border_VAttrMask,Y
	ORA Border_VAttrs,Y
	STA Graphics_Buffer+3,X

	INX
	INX
	INX
	INX		 ; X += 4

	INY		 ; Y++

	DEC <Temp_Var2	 ; Temp_Var2--
	BPL PRG010_CC0B	 ; While Temp_Var2 >= 0, loop

	; Graphics_BufCnt = $18
	LDA #$18
	STA Graphics_BufCnt

	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG030_CC3C

	; Map_DrawPanState = 0
	LDA #$00
	STA Map_DrawPanState
	STA <Map_ScrollOddEven

PRG030_CC3C:
	JMP Scroll_Map_SpriteBorder	 ; Draw sprite border and don't come back

Map_PanInit:

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

	INC Map_DrawPanState	 ; Map_DrawPanState++

	JMP Map_PanRight	 ; Jump to Map_PanRight

Scroll_ColumnLOff:	.byte $00, $0F, $00

Map_PanRight:
	; Switch to page 12 @ A000 (for map tile 8x8 layout data)
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #12
	STA MMC3_PAGE

	LDY <Map_ScrollOddEven		 ; Y = Map_ScrollOddEven

	LDA <Scroll_ColumnL
	ADD Scroll_ColumnLOff,Y
	STA <Scroll_ColumnL

	AND #$f0
	LSR A
	LSR A
	LSR A
	TAY		 ; -> 'Y'

	; Set Map_Tile_AddrL/H 
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Map is always on the "lower" tile memory

	LDA <Scroll_ColumnL
	AND #$0f
	STA <Temp_Var1

	LDX #$00	 ; X = 0

PRG010_CC7A:
	LDA Level_Tileset
	ASL A 
	TAY		 ; Y = Level_Tileset * 2

	; Get pointer to tile layout -> Temp_Var15/16
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var15
	LDA TileLayout_ByTileset+1,Y
	STA <Temp_Var16

	LDY <Temp_Var1		 ; Y = Temp_Var1

	LDA [Map_Tile_AddrL],Y	; Get tile
	TAY		 	; -> 'Y'

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG010_CC98

	; Temp_Var16 += 2 (two 8x8 patterns over)
	INC <Temp_Var16
	INC <Temp_Var16

PRG010_CC98:
	LDA [Temp_Var15],Y		; Get this pattern
	STA Scroll_PatStrip+$20,X	; Store into Scroll_PatStrip

	INC <Temp_Var16			; Temp_Var16++

	LDA [Temp_Var15],Y		; Get this pattern
	STA Scroll_PatStrip+$21,X	; Store into Scroll_PatStrip

	; X += 2
	INX
	INX

	; Temp_Var1 += 16
	LDA <Temp_Var1
	ADD #$10
	STA <Temp_Var1

	AND #$f0
	CMP #$b0
	BNE PRG010_CC7A

	LDA <Scroll_ColumnL
	AND #$0f
	ASL A
	TAY		 ; -> 'Y'

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG010_CCC0

	INY		 ; Y++

PRG010_CCC0:
	LDA #$20
	STA Scroll_ToVRAMHi	 ; Scroll_ToVRAMHi = $20

	STY Scroll_LastCol8

	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	CMP #$03
	BNE PRG010_CCD7	 ; If Map_ScrollOddEven <> 3, jump to PRG010_CCD7

	; Map_ScrollOddEven = 0
	LDA #$00
	STA <Map_ScrollOddEven

	INC Map_DrawPanState	 ; Map_DrawPanState++

PRG010_CCD7:
	; Switch to page 11 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #11
	STA MMC3_PAGE

	JMP Scroll_Map_SpriteBorder	 ; Draw map sprite border and don't come back

Map_PanLeft:
	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var1

	LDY #(PRG010_CB39_End - PRG010_CB39 - 1)
	LDX #(PRG010_CB39_End - PRG010_CB39 - 1)

	LDA <Map_ScrollOddEven
	BEQ PRG010_CCF7	 ; If Map_ScrollOddEven = 0, jump to PRG010_CCF7

	LDX #$31	 ; X = $31
PRG010_CCF7:
	LDA PRG010_CB39,X	 ; Get graphics buffer command byte
	STA Graphics_Buffer,Y	 ; Store into graphics buffer

	DEX		 ; X--
	DEY		 ; Y--
	BPL PRG010_CCF7	 ; While Y >= 0, loop

	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0

	LDA <Map_ScrollOddEven
	BEQ PRG010_CD0B	 ; If Map_ScrollOddEven = 0, jump to PRG010_CD0B

	LDY #$06	 ; Y = 6

PRG010_CD0B:
	; Set VRAM low address in graphics buffer
	LDA Graphics_Buffer+1,X
	EOR <Temp_Var1
	STA Graphics_Buffer+1,X

	LDA Map_BorderAttrFromTiles,Y
	STA Graphics_Buffer+3,X

	INX
	INX
	INX
	INX	; X += 4

	INY	; Y++

	CPY #$0c
	BNE PRG010_CD0B	 ; If Y <> 12, loop

	; Graphics_BufCnt = $18
	LDA #$18
	STA Graphics_BufCnt


	INC <Map_ScrollOddEven	 ; Map_ScrollOddEven++

	LDA <Map_ScrollOddEven
	AND #$01
	BNE PRG030_CD36

	LDA #$00
	STA Map_DrawPanState	 ; Map_DrawPanState = 0
	STA <Map_ScrollOddEven	 ; Map_ScrollOddEven = 0

PRG030_CD36:
	JMP Scroll_Map_SpriteBorder	 ; Draw map sprite border and don't come back

Map_StateNothing:
	INC World_EnterState		; World_EnterState++
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw

	; FIXME: Anyone want to claim this?  Related to $CA82??
; $CD3F
	LDX Player_Current	 ; X = Player_Current

	LDA #$00
	STA Map_Unused72C
	STA Map_Unused7995
	STA Player_FallToKing,X
	STA Bonus_UnusedFlag	; ?

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw


	; FIXME: Anyone want to claim this?  Related to $CA82??
; $CD53

	; Map_ReturnStatus = 3 (??)
	LDA #$03	 
	STA Map_ReturnStatus

	; Map_Intro_Tick = $80
	LDA #$80
	STA Map_Intro_Tick

	LDX Player_Current	; X = Player_Current

	LDA #$00
	STA Map_Unused72C
	STA Map_Unused7995
	STA Player_FallToKing,X

	INC World_EnterState	 ; World_EnterState++

PRG010_CD6E:
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw

	; Amount to move on map when standard or in canoe ('C')
MapMove_DeltaY:		.byte   0,   0,   0,   0,   2,   0,   0,   0,  -2
MapMove_DeltaX:		.byte   0,   2,  -2,   0,   0,   0,   0,   0,   0
MapMove_DeltaXHi:	.byte   0,   0, $FF,   0,   0,   0,   0,   0,   0	; sign extension $FF

MapMove_DeltaYC:	.byte   0,   0,   0,   0,   1,   0,   0,   0,  -1
MapMove_DeltaXC:	.byte   0,   1,  -1,   0,   0,   0,   0,   0,   0
MapMove_DeltaXHiC:	.byte   0,   0, $FF,   0,   0,   0,   0,   0,   0	; sign extension $FF

MapMove_DeltaDiff = MapMove_DeltaYC - MapMove_DeltaY	; For clarity

PRG010_CDA7:
	.byte $06, $05, $0A, $09, $09, $0A, $05, $06

	; Enterable special tiles (Note the couple of oddities here...)
	; NOTE: Due to a bug in the code, several bytes after this table are also considered
	; as "enterable" tiles (clear down thru Map_PostJC_PUpPP2 as of a matter of fact!)
Map_EnterSpecialTiles:
	.byte TILE_TOADHOUSE, TILE_SPADEBONUS, TILE_PIPE, TILE_ALTTOADHOUSE
	.byte TILE_CASTLEBOTTOM, TILE_SPIRAL, TILE_ALTSPIRAL, TILE_PATHANDNUB
	.byte TILE_DANCINGFLOWER, TILE_HANDTRAP, TILE_BOWSERCASTLELL

	; Color table for setting the 2nd entry power up color on the map used for clearing Judgem's cloud!
	; NOTE: This is a patch table, you'll want it to agree with PRG027's "InitPals_Per_MapPUp"
Map_PostJC_PUpPP1:	.byte $16, $16, $27, $16, $2A, $17, $30

	; In conjunction with the table above; patches $1A (Luigi) for $16 as needed
Map_PostJC_PUpPML:	.byte $16, $1A

	; Color table for setting the 4th entry power up color on the map used for clearing Judgem's cloud!
	; NOTE: This is a patch table, you'll want it to agree with PRG027's "InitPals_Per_MapPUp"
Map_PostJC_PUpPP2:	.byte $0F, $0F, $16, $0F, $0F, $0F, $0F


MO_NormalMoveEnter:
	LDA #$00
	STA Map_NoLoseTurn	 ; Map_NoLoseTurn = 0
	STA Map_WasInPipeway	 ; Map_WasInPipeway = 0

	LDX Player_Current
	LDA <World_Map_Move,X
	BEQ PRG010_CDDC	 	; If Player is not moving on map, jump to PRG010_CDDC

	JMP PRG010_CEE4	 	; Otherwise, jump to PRG010_CEE4...

PRG010_CDDC:
	;;; [ORANGE] Hook here to check for NPC interaction via a select push
	;;;LDA Map_Pan_Count
	JSR CheckForNPCInteraction
	BNE PRG010_CD6E	 	; If map is panning, jump to PRG010_CD6E (indirect to WorldMap_UpdateAndDraw)

	LDA <Pad_Input	
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)	 
	BEQ PRG010_CDEC	 	; If Player is not pushing up/down/left/right, jump to PRG010_CDEC

	LDA #SND_PLAYERBUMP	 
	STA Sound_QPlayer	; "Bump" noise

PRG010_CDEC:
	JSR Map_GetTile	 	; Get current tile Player is standing on

	AND #$c0	 	; Only keeping the upper 2 bits of it
	CLC		 
	ROL A		 
	ROL A		 
	ROL A		 
	TAY		 	; Y = upper 2 bits of map tile shifted down; the "tile quadrant"

	; In short, what this checks is, for a given "quadrant" of the tile you're standing on
	; ($00, $40, $80, $C0), it turns this into an index (>> 6) and looks up a value
	; in "Tile_AttrTable+4" to determine the minimum value for what you're standing on
	; to be "enterable" as a level panel; if you fail this test, the tile can't
	; possibly be enterable (so goes the idea...)

	LDA <World_Map_Tile
	CMP Tile_AttrTable+4,Y
	BLT PRG010_CE64	 	; If tile is not in "enterable" range, jump to PRG010_CE64

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	BEQ PRG010_CE64	 	; If Player has not been holding up/down/left/right, jump to PRG010_CE64

	; Player is holding a direction...

	LDY #$03	 	; Y = 3
PRG010_CE05:
	CMP Map_HoldPadDir,Y
	BEQ PRG010_CE0D	 	; If Player is holding this direction, jump to PRG010_CE0D
	DEY			; Y--
	BNE PRG010_CE05		; Otherwise, loop! (Check next possible direction)

PRG010_CE0D:
	LDA Map_PrevMoveDir
	CMP Map_RevDir,Y
	BEQ PRG010_CE64	 	; Based on their last SUCCESSFUL move, if Player reversed direction, jump to PRG010_CE64 (allowed to escape a level panel the way they came in only!)

	LDA Map_PrevMoveDir

	PHA		 	; Save 'A' (Map_PrevMoveDir)
	JSR Map_CheckDoMove	; CHECK if we can move on map, if able and desired
	PLA		 	; Retore 'A' (Map_PrevMoveDir, restores it if changed by Map_CheckDoMove)
	STA Map_PrevMoveDir	; Undoes the change; we're just CHECKING right now!

	LDA Sound_QMap	 
	BEQ PRG010_CE61	 	; If no sound played, there's no traversable path; jump to PRG010_CE61

	; A traversable path was found... since we're currently standing on an enterable, 
	; non-bypassable level panel, you must be wearing a Judgem's cloud to proceed...

	;;; [ORANGE] We hook this to allow the player to pass levels where they've gotten
	;;; at least one orb.
	;;;LDA Map_Power_Disp
	;;CMP #$07
	JSR CheckAllowedToPass
	NOP
	NOP
	BEQ PRG010_CE39	 	; If Player is wearing Judgem's cloud, jump to PRG010_CE39

	; Otherwise, undo the move; you're not allowed to take the path until you complete that level!
	LDX Player_Current
	LDA #$00	 
	STA <World_Map_Move,X	; Don't actually move on path
	STA Sound_QMap	 	; Don't actually play the sound
	JMP PRG010_CE78	 	; Jump to PRG010_CE78

PRG010_CE39:
	; Player is wearing Judgem's cloud

	LDA <Temp_Var4		; Temp_Var4 = Pad_Holding (since Map_CheckDoMove)
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	STA Map_PrevMoveDir	; Store the left/right/down/up of the move

	; Restore the displayed power up to the Player's actual power up
	LDX Player_Current
	LDA World_Map_Power,X
	STA Map_Power_Disp	

	TAY		 	; A = Player's actual power up

	; Get the color we need to patch in...
	LDA Map_PostJC_PUpPP1,Y
	CMP #$16	 
	BNE PRG010_CE54	 	; If color <> $16 (Mario's red), jump to PRG010_CE54

	; Otherwise possibly change to Luigi green, if that's appropriate...
	LDA Map_PostJC_PUpPML,X	 

PRG010_CE54:
	; Copy appropriate power up patch values into the palette buffer
	STA Palette_Buffer+$11
	LDA Map_PostJC_PUpPP2,Y
	STA Palette_Buffer+$13	

	; Queue the palette buffer to update!
	LDA #$06
	STA <Graphics_Queue

PRG010_CE61:
	; If Player didn't move, we also come here
	JMP PRG010_CE71	 	; Jump to PRG010_CE71

PRG010_CE64:
	; Player reversed direction

	JSR Map_CheckDoMove	; Attempt move

	LDA Sound_QMap
	BEQ PRG010_CE71	 	; If no sound played, Player didn't move (Dirty check!); jump to PRG010_CE71

	LDA #$00	 
	STA Sound_QPlayer	; Otherwise, stop any Player sound (perhaps "bump")

PRG010_CE71: 
	LDX Player_Current	
	LDA <World_Map_Move,X
	BNE PRG010_CEE4	 	; If the Player's map movement is non-zero, jump to PRG010_CEE4

PRG010_CE78:
	; Player is not moving on map...

	LDA <Controller1Press
	ORA <Controller2Press
	AND #$80	 
	BEQ PRG010_CEE1		; If neither of the two players are pressing the 'A' button jump to PRG010_CEE1

	LDX Player_Current	; X = Player_Current
	TXA		 
	EOR #$01	 	
	TAY		 	; Y = Player_Current ^ 1 (i.e. the OTHER Player)

	LDA Player_Lives,Y
	CMP #$ff	 
	BEQ PRG010_CEBF	 	; If the other Player is dead, jump to PRG010_CEBF

	; Basically if Player 1 and 2 are not standing on top of eachother when one of them pushed A, jump to PRG010_CEBF
	LDA <World_Map_XHi,X
	CMP World_Map_XHi,Y
	BNE PRG010_CEBF	
	LDA <World_Map_Y,X
	CMP World_Map_Y,Y
	BNE PRG010_CEBF	
	LDA <World_Map_X,X
	CMP World_Map_X,Y
	BNE PRG010_CEBF	

	LDA #$12
	STA <Map_Enter2PFlag	; Map_Enter2PFlag = $12 (enterint 2P Vs)

PRG010_CEA7:
	LDA #$10
	STA Map_Operation	; Map_Operation = $10 (begin "enter level" effect)

PRG010_CEAC:
	LDX Player_Current	; X = Player_Current

	LDA #$00	 
	STA Map_Player_SkidBack,X	; Clear Map_Player_SkidBack

	LDA #$00	 
	STA World_EnterState	; World_EnterState = 0
	STA Map_NoLoseTurn	 ; Clear Map_NoLoseTurn

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG010_CEBF:
	; A Player pressed 'A' but they were not on top of each other, so no 2P vs...

	LDA <Pad_Input
	AND #PAD_A	
	BEQ PRG010_CEE1	 	; If Player is not pressing 'A', jump to PRG010_CEE1

	LDA <World_Map_Tile
	LDY #$1a	; Y = $1A (BUG!  Map_EnterSpecialTiles is much smaller than this, should be $0A!  Causes some bytes used for palette data to be considered!)
PRG010_CEC9:
	CMP Map_EnterSpecialTiles,Y
	BEQ PRG010_CEA7	 	; If this is one of the special enterable tiles, jump to PRG010_CEA7 (enter level!)
	DEY		 	; Y--
	BPL PRG010_CEC9	 	; If Y >= 0, jump to PRG010_CEC9

	; Not a special tile...
	LDA <World_Map_Tile
	AND #$c0	 	; Only keeping the upper 2 bits of it
	CLC		 
	ROL A		 
	ROL A		 
	ROL A		 
	TAY		 	; Y = map tile >> 6 (basically)

	; What makes other tiles (e.g. standard panels) work...
	LDA <World_Map_Tile
	CMP Tile_AttrTable+4,Y
	BGE PRG010_CEA7	 	; If the tile the Player is standing on >= Tile_AttrTable+4[Y], jump to PRG010_CEA7 (enter level!)

PRG010_CEE1:		
	JMP WorldMap_UpdateAndDraw	; Jump to WorldMap_UpdateAndDraw


PRG010_CEE4:
	; Player is moving on map...

	DEC <World_Map_Move,X
	DEC <World_Map_Move,X	 	; World_Map_Move -= 2

	LDA <World_Map_Dir,X	 
	LDY Map_InCanoe_Flag	 
	BEQ PRG010_CEF4	 		; If not in canoe, jump to PRG010_CEF4

	; Otherwise, in canoe...
	ADD #MapMove_DeltaDiff 		; Add MapMove_DeltaDiff to World_Map_Dir (use canoe values)
	INC <World_Map_Move,X	 	; Soften the map move reduction by adding on back

PRG010_CEF4:
	TAY		 		; Y = 'A'

	; Move Player as according to specified delta
	LDA <World_Map_Y,X	 
	ADD MapMove_DeltaY,Y
	STA <World_Map_Y,X
	LDA <World_Map_X,X
	ADD MapMove_DeltaX,Y
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	ADC MapMove_DeltaXHi,Y	
	STA <World_Map_XHi,X

	LDA <World_Map_Move,X
	AND #31				; Check if any move is left (relies on starting value of 32!)
	BNE WorldMap_UpdateAndDraw	; If so, jump to WorldMap_UpdateAndDraw...

	; The move has completed...
	JSR Map_GetTile	 
	CMP #TILE_HANDTRAP
	BNE WorldMap_UpdateAndDraw	; If the Player has not landed on a hand trap, jump to WorldMap_UpdateAndDraw

	; Player's on a hand trap...
	LDX Player_Current
	LDA RandomN,X	 
	AND #$01			; 50/50 chance
	BNE WorldMap_UpdateAndDraw	; Player has 50/50 chance we just jump to WorldMap_UpdateAndDraw

	INC Map_Operation	 	; Otherwise, Map_Operation++ (now $E)
	JMP PRG010_CEAC	 		; Jump to PRG010_CEAC

WorldMap_UpdateAndDraw:
	LDY Player_Current 	; Y = Player_Current

	LDA Map_UnusedPlayerVal2,Y	; A = Map_UnusedPlayerVal2
	STA <Temp_Var3		; Stored into Temp_Var3
	JMP Map_DrawPlayer	; Draw Player sprite on map

World_Map_Max_PanR:
	; Per-world defintion of the maximum scroll column allowed on the map
	; $10 defines one screen.  Worlds which have multiple screens but do
	; not pan between them (World 5 & 8) have $00, but this not what actually
	; restricts movement (though in a cleaner implementation probably should
	; have been.)  Instead, you'll find specific lock-out code a bit after
	; the Map_Check_PanR label... also of note, there's no entry for World 9
	; (Warp Zone) which will incorrectly pan if the Player ever could scoot
	; that far over (not that there's anything to scroll TO of course)
	.byte $10, $20, $30, $30, $00, $30, $20, $00

	; NOTE: Should be safe to expand these to include new map powers,
	; BUT make sure to add elements to all of Map_Power_TilesF1/2 and
	; Map_Power_AttribF1/2 together or else funny visuals will occur...

Map_Power_Pats_F1:
	; This table defines patterns to be used per power-up
	; to the sprites making up the Player.
	; Byte order is upper left, upper right, lower left, lower right
	; Note that Small Mario / Judgems do not have a visible "upper"
	;
	; NOTE: $27 is actually a magic value hard-wired to remove the
	; upper sprites!  (The tiles appear as a black box otherwise)
	; See code following label PRG010_D045 for this hardcode...
	.byte $27, $27, $2D, $2F	; Small
	.byte $B1, $B1, $B3, $B7	; Super Mushroom
	.byte $B1, $B1, $B3, $B7	; Fire Flower
	.byte $B9, $B9, $B3, $B7	; Leaf
	.byte $AF, $AF, $D1, $D1	; Frog Suit
	.byte $AD, $AD, $C1, $C1	; Tanooki Suit
	.byte $AB, $AB, $CD, $CF	; Hammer Suit
	.byte $27, $27, $9F, $9F	; Judgems Cloud
	.byte $B9, $B9, $8D, $8F	; P-Wing

Map_Power_Pats_F2:
	.byte $27, $27, $2F, $2D	; Small
	.byte $B1, $B1, $B7, $B3	; Super Mushroom
	.byte $B1, $B1, $B7, $B3	; Fire Flower
	.byte $B9, $B9, $B7, $B3	; Leaf
	.byte $BF, $BF, $D3, $D3	; Frog Suit
	.byte $BD, $BD, $C3, $C3	; Tanooki Suit
	.byte $AB, $AB, $CF, $CD	; Hammer Suit
	.byte $27, $27, $9F, $9F	; Judgems Cloud
	.byte $B9, $B9, $A7, $A9	; P-Wing

Map_Power_Attrib_F1:
	; This table defines attributes to be applied per power-up
	; to the sprites making up the Player; only actually used
	; to apply horizontal flips here and there...
	; Byte order is upper left, upper right, lower left, lower right
	; Note that Small Mario / Judgems do not have a visible "upper"
	.byte $00, $40, $00, $00	; Small
	.byte $00, $40, $00, $00	; Super Mushroom
	.byte $00, $40, $00, $00	; Fire Flower
	.byte $00, $40, $00, $00	; Leaf
	.byte $00, $40, $00, $40	; Frog Suit
	.byte $00, $40, $00, $40	; Tanooki Suit
	.byte $00, $40, $00, $00	; Hammer Suit
	.byte $00, $40, $00, $40	; Judgems Cloud
	.byte $00, $40, $00, $00	; P-Wing

Map_Power_Attrib_F2:
	; Frame 2; see Map_Power_Attrib_F1
	.byte $00, $40, $40, $40	; Small
	.byte $00, $40, $40, $40	; Super Mushroom
	.byte $00, $40, $40, $40	; Fire Flower
	.byte $00, $40, $40, $40	; Leaf
	.byte $00, $40, $00, $40	; Frog Suit
	.byte $00, $40, $00, $40	; Tanooki Suit
	.byte $00, $40, $40, $40	; Hammer Suit
	.byte $00, $40, $00, $40	; Judgems Cloud
	.byte $00, $40, $00, $00	; P-Wing

Map_Marker_MorL:
	.byte $63, $4F		; The (M), (L) small markers

PRG010_CFCE:
	.byte $00, $04, $05, $06


; These two LUTs define four frames (two bytes each) of "twirling" frames
Player_Twirl_Tiles:	.byte $0F, $0D, $2D, $2F, $0D, $0F, $3D, $3F
Player_Twirl_Attribs:	.byte $40, $40, $00, $00, $00, $00, $00, $00

Map_BorderSprites:
	.byte $10, $03, $01, $08
	.byte $10, $05, $01, $F0
	.byte $10, $0B, $01, $F8
	.byte $B0, $09, $01, $08
	.byte $B0, $07, $01, $F0
	.byte $B0, $0B, $01, $F8
Map_BorderSprites_End

Map_DrawPlayer:
	LDX Player_Current	; X = Player_Current
	LDA <World_Map_Y,X	; A = Player's Y position
	CMP #$f8
	BEQ PRG010_D012	 	; If Player's Y = $f8, jump to PRG010_D012

	; Update Player's sprite Y position!
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90
	SUB #16			 ; Subtract 16 for upper half
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

PRG010_D012:
	LDA <World_Map_X,X	 ; A = Player's X position
	SUB <Horz_Scroll	 ; Made relative to the horizontal scroll

	; Update Player's sprite X position!
	STA Sprite_RAM+$87
	STA Sprite_RAM+$8F
	ADD #8		 	 ; Add 8 for right half 
	STA Sprite_RAM+$8B
	STA Sprite_RAM+$93

	LDA Map_Power_Disp
	ASL A		 
	ASL A		 
	TAX		 ; X = Map_Power_Disp << 2 (4 bytes index per power-up)

	LDA <Counter_1
	AND #$08	; On 8 ticks, off 8 ticks
	BEQ PRG010_D037	; 
	TXA		
	ADD #(Map_Power_Pats_F2-Map_Power_Pats_F1)	
	TAX		; X Offset to second frame

PRG010_D037:
	LDY #$00	 ; Y = 0
	LDA Map_Starman	
	BEQ PRG010_D045	 ; If not using a starman, jump to PRG010_D045

	LDA <Counter_1
	AND #%00001100
	LSR A
	LSR A
	TAY		 ; Y = 0 to 3 (color cycle Star Man)

PRG010_D045:

	; This builds the 4 hardware sprites for the Player sprite
	TYA		 
	ORA Map_Power_Attrib_F1,X	 
	STA Sprite_RAM+$86	 
	LDA Map_Power_Pats_F1,X	 
	STA Sprite_RAM+$85	 
	TYA		 
	ORA Map_Power_Attrib_F1+1,X	 
	STA Sprite_RAM+$8A	 
	LDA Map_Power_Pats_F1+1,X	 
	STA Sprite_RAM+$89	 
	TYA		 
	ORA Map_Power_Attrib_F1+2,X	 
	STA Sprite_RAM+$8E	 
	LDA Map_Power_Pats_F1+2,X	 
	STA Sprite_RAM+$8D	 
	TYA		 
	ORA Map_Power_Attrib_F1+3,X	 
	STA Sprite_RAM+$92	 
	LDA Map_Power_Pats_F1+3,X	 
	STA Sprite_RAM+$91	 

	; Hardcode: Tile $27 removes the upper sprites
	LDA Sprite_RAM+$85	 
	CMP #$27	 
	BNE PRG010_D088	 	; If not using tile $27, jump to PRG010_D088	

	; Set the unused upper sprites to Y coord = $f8 (off-screen, invisible)
	LDA #$f8	 
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

PRG010_D088:
	LDX Player_Current	; X = Player_Current
	LDA World_Map_Twirl,X
	BNE Map_DoPlayer_As_Twirl	 	; If this player is "twirling", jump to Map_DoPlayer_As_Twirl

	; Player isn't twirling ...

	LDA Map_Operation
	CMP #6
	BLT Map_DoPlayer_Edge_Scroll	 ; If Map_Operation < $06, jump to Map_DoPlayer_Edge_Scroll

	CMP #$0d
	BLT Map_DoPlayer_As_Marker	 ; If Map_Operation < $0d, jump to Map_DoPlayer_As_Marker

	CMP #$0f
	BNE Map_DoPlayer_Edge_Scroll	 ; If Map_Operation <> $0f, jump to Map_DoPlayer_Edge_Scroll

Map_DoPlayer_As_Marker:
	; If you get here: $06 >= Map_Operation >= $0C, or $0F

	LDX Player_Current	; X = Player_Current

	; Player is displayed as (M) or (L) marker as appropriate
	LDA Map_Marker_MorL,X	
	STA Sprite_RAM+$91	
	LDA #$03	 	
	STA Sprite_RAM+$92	

	; Other sprites are disabled
	LDA #$f8	 	
	STA Sprite_RAM+$84	
	STA Sprite_RAM+$88	
	STA Sprite_RAM+$8C	

	JMP Map_DoPlayer_Edge_Scroll	 	; Jump to Map_DoPlayer_Edge_Scroll...

Map_DoPlayer_As_Twirl:
	; Player is "twirling"!
	DEC <Map_Skid_Count	; Map_Skid_Count-- (wraps around forever)
	LDA <Map_Skid_Count	 
	AND #$06	 	; Take Map_Skid_Count as a 2 byte offset, 1:4
	TAY

	; Setup appropriate "twirl" frame!		 
	LDA Player_Twirl_Tiles,Y	 
	STA Sprite_RAM+$8D	 
	LDA Player_Twirl_Tiles+1,Y	 
	STA Sprite_RAM+$91	 
	LDA Player_Twirl_Attribs,Y	 
	STA Sprite_RAM+$8E	 
	LDA Player_Twirl_Attribs+1,Y	 
	STA Sprite_RAM+$92	 

Map_DoPlayer_Edge_Scroll:
	LDA Map_Operation
	CMP #$02
	BEQ Map_Check_PanR	 	; If Map_Operation = $02 (Skidding backward), jump to Map_Check_PanR

	LDX Player_Current	; X = Player_Current

	LDA Map_Player_SkidBack,X 
	BNE Map_No_Pan	 	; If Player did not skid back, jump to Map_No_Pan

	LDA <Map_WarpWind_FX
	BNE Map_No_Pan	 	; If any world map FX are occurring, jump to Map_No_Pan

Map_Check_PanR:
	LDA Map_Pan_Count
	BNE Map_No_Pan	 	; If map is panning, jump to Map_No_Pan

	; NOTE: This block disables panning on World 5 and 8.  Change this
	; to make them pan like normal maps!! *****
	LDA World_Num
	CMP #7			
	BEQ Map_No_Pan	 	; If World_Num = 7 (World 8), jump to Map_No_Pan
	CMP #4	 		
	BEQ Map_No_Pan	 	; If World_Num = 4 (World 5), jump to Map_No_Pan

	LDA Sprite_RAM+$87
	CMP #208
	BLT Map_Check_PanL 	; If Player's sprite's X coord is less than 208, jump to Map_Check_PanL

	LDY World_Num	 	; Y = World_Num
	LDA <Scroll_ColumnR	; A = Current right-hand column
	CMP World_Map_Max_PanR,Y
	BEQ Map_No_Pan	 	; If map scrolling has already reached the right-side limit, jump to Map_No_Pan

	LDX #$00	 	; X = 0
	JMP Map_Set_Pan	 	; Jump to Map_Set_Pan ...

Map_Check_PanL:
	LDA <Scroll_ColumnL	; A = Current left-hand column 
	BEQ Map_No_Pan	 	; If map scrolling has already reached the left-side limit, jump to Map_No_Pan

	LDA Sprite_RAM+$87
	CMP #33

	BGE Map_No_Pan	 	; If Player's sprite's X coord is >= 33, jump to Map_No_Pan
	LDX #$01	 	; X = 1

Map_Set_Pan:
	; We need to pan the map!
	STX <Scroll_LastDir	; Set proper pan direction
	LDA #$80	 
	STA Map_Pan_Count	; Map_Pan_Count = $80 (moves half a screen's worth)
	LDA #$04	 
	STA Map_DrawPanState	; Map_DrawPanState = 4 (Do panning)

Map_No_Pan:
	LDA Total_Players
	CMP #$01
	BEQ PRG010_D16F	 	; If Total_Players = 1 (1P mode), jump to PRG010_D16F

	LDA World_Num
	CMP #$08
	BEQ PRG010_D16F	 	; If World_Num = 8 (World 9, Warp Zone), jump to PRG010_D16F

	LDA Player_Current
	EOR #$01	 	; Switch to the opposite Player
	TAX		 	; X = Player_Current ^ 1
	LDA Player_Lives,X	; The "other" Player's lives
	BMI PRG010_D16F	 	; If they're deceased, jump to PRG010_D16F

	LDA <World_Map_X,X	; A = Other player's X coord
	SUB <Horz_Scroll	; Made relative to the screen
	BEQ PRG010_D16F	 	; If relatively 0, jump to PRG010_D16F

	LDA <World_Map_XHi,X	; A = Other player's X Hi byte 
	SBC #$00	 	
	CMP <Horz_Scroll_Hi	
	BNE PRG010_D16F	 	; If other Player's marker is not visible, jump to PRG010_D16F

	; Other Player sprite marker
	LDA <World_Map_Y,X	 
	STA Sprite_RAM+$94	 
	LDA Map_Marker_MorL,X	 
	STA Sprite_RAM+$95	 
	LDA #$03	 
	STA Sprite_RAM+$96	 
	LDA <World_Map_X,X	 
	SUB <Horz_Scroll		 
	ADD #$04	 
	STA Sprite_RAM+$97	 

PRG010_D16F:
	LDA Map_Operation
	CMP #$01	
	BLT PRG010_D179	 ; If Map_Operation < 1, jump to PRG010_D179

	JSR MapObjects_UpdateDrawEnter	; Update all objects, draw them, enter them

PRG010_D179:
	LDA World_Num
	CMP #$08	
	BNE PRG010_D183	 ; If World_Num <> 8 (World 9, Warp Zone), jump to PRG010_D183 (RTS)
	JSR Map_WarpZone_DrawNumbers	 ; Draw the numbers of the warp zone

PRG010_D183:
	RTS		 ; Return

Map_WarpZone_Numbers:
	; Sprites of the world numbers used in the warp zone
	.byte $3F, $91, $01, $64
	.byte $3F, $93, $01, $84
	.byte $3F, $95, $01, $A4
	.byte $5F, $97, $01, $64
	.byte $5F, $99, $01, $84
	.byte $5F, $9B, $01, $A4
	.byte $7F, $9D, $01, $A4

Map_WarpZone_DrawNumbers:

	LDY #$1b	 ; Y = $1B
PRG010_D1A2:
	LDA Map_WarpZone_Numbers,Y
	STA Sprite_RAM+$98,Y
	DEY		 
	BPL PRG010_D1A2	 ; While Y >= 0, loop!
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Map_SpriteBorder
;
; When the world map scrolls, there's no way
; to maintain the border graphic using the
; BG layer, so it emulates it with sprites
; until the scrolling ceases!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Map_SpriteBorder:

	LDA #$20	 
	STA <Temp_Var1	 ; Temp_Var1 = $20
	LDY #$60	 ; Y = $60

PRG010_D1B2:

	; Set first three hardware sprites to Y = Temp_Var1
	LDA <Temp_Var1
	STA Sprite_RAM,Y
	STA Sprite_RAM+4,Y
	STA Sprite_RAM+8,Y

	; Set first and second pattern to 1 (border tile)
	LDA #$01	 
	STA Sprite_RAM+1,Y
	STA Sprite_RAM+5,Y

	; And third to $B
	LDA #$0b	 	
	STA Sprite_RAM+9,Y	

	; Set all of their attributes to 1 (palette)
	LDA #$01	 
	STA Sprite_RAM+2,Y
	STA Sprite_RAM+6,Y
	STA Sprite_RAM+10,Y

	; First X = 8
	LDA #$08	
	STA Sprite_RAM+3,Y
 
	; Second X = 240
	LDA #240
	STA Sprite_RAM+7,Y

	; Third X = 248
	LDA #248
	STA Sprite_RAM+11,Y

	LDA <Temp_Var1	
	ADD #16
	STA <Temp_Var1	 ; Temp_Var1 += 16

	TYA		
	SUB #12	
	TAY		 ; Y -= 12 (3 sprites backward)
	BPL PRG010_D1B2	 ; While Y >= 0, loop!

	LDY #(Map_BorderSprites_End - Map_BorderSprites - 1)
PRG010_D1F4:
	LDA Map_BorderSprites,Y
	STA Sprite_RAM+$6C,Y

	DEY		 	; Y--
	BPL PRG010_D1F4	 	; While Y >= 0, loop!

	RTS		 ; Return

Map_GetTile:
	LDX Player_Current
	LDA <World_Map_XHi,X
	ASL A		 
	TAY		 

	; Store starting offset for this map screen into Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Effectively adds $100 to the address (maps get loaded at screen base + $110)

	LDA <World_Map_X,X
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA <Temp_Var1		; Temp_Var1 = World_Map_X / 16 (the current column of the current screen)

	LDA <World_Map_Y,X
	SUB #16
	AND #$f0
	ORA <Temp_Var1		; Temp_Var1 now holds the X column in the lower 4-bits and the Y row in the upper 4-bits

	TAY		 	; Store this offset value into 'Y'

	LDA [Map_Tile_AddrL],Y
	STA <World_Map_Tile	
	RTS		 ; Return


	; FIXME: Anyone want to claim this?  (Exact same routine appears in PRG011 @ $B6F6)
; $D228 
	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_Dir,X	; Get Player's map direction
	EOR #$03
	CMP #$03
	BNE PRG010_D235	 	; If Player did not travel left or right, jump to PRG010_D235

	EOR #$0f	 ; Otherwise invert all direction bits??

PRG010_D235:
	STA <World_Map_Dir,X	 ; -> World_Map_Dir

	RTS		 ; Return

	; For Player holding Right 01 Left 02 Down 04 Up 08 check
Map_HoldPadDir:	.byte $01, $02, $04, $08	; R01 L02 D04 U08

	; Lookup indexed same as above to see if Player reversed direction from their last move
Map_RevDir:	.byte $02, $01, $08, $04	; R01 L02 D04 U08

	; LUT based on map object's travel direction to get a list of
	; valid tiles to travel over in that direction...
	;
	; Travel directions:
	; 0 = Right, 1 = Left, 2 = Down, 3 = Up
	;
	; Seems Nintendo was possibly leaving "one way" tiles open
	; as an idea or something, since left/right and up/down
	; are duplicated, identical data (when the pointers could've
	; been made the same, y'know?)
Map_Object_Valid_Tiles:	.word Map_Object_Valid_Left, Map_Object_Valid_Right, Map_Object_Valid_Down, Map_Object_Valid_Up

	; Safe to expand this, but make sure you update all four!!
Map_Object_Valid_Left:	
	.byte TILE_HORZPATH,    TILE_DRAWBRIDGEH, TILE_BRIDGE,      TILE_HORZPATHW, TILE_HORZPATHWLL
	.byte TILE_HORZPATHWLR, TILE_HORZPATHSKY, TILE_HORZPATHWLB, TILE_HANDTRAP
Map_Object_Valid_Right:
	.byte TILE_HORZPATH,    TILE_DRAWBRIDGEH, TILE_BRIDGE,      TILE_HORZPATHW, TILE_HORZPATHWLL
	.byte TILE_HORZPATHWLR, TILE_HORZPATHSKY, TILE_HORZPATHWLB, TILE_HANDTRAP
Map_Object_Valid_Down:	
	.byte TILE_VERTPATH,    TILE_VERTPATH,    TILE_VERTPATH,    TILE_DRAWBRIDGEV, TILE_VERTPATHWLU
	.byte TILE_VERTPATHWLL, TILE_VERTPATHW,   TILE_VERTPATHSKY, TILE_VERTPATHWLB
Map_Object_Valid_Up:
	.byte TILE_VERTPATH,    TILE_VERTPATH,    TILE_VERTPATH,    TILE_DRAWBRIDGEV, TILE_VERTPATHWLU
	.byte TILE_VERTPATHWLL, TILE_VERTPATHW,   TILE_VERTPATHSKY, TILE_VERTPATHWLB

	; This makes it safe to expand the above
Map_Object_Valid_Tiles2Check = (Map_Object_Valid_Right - Map_Object_Valid_Left) 	

	; Appropriate crossable draw bridge tile based on direction 0-3
	; 0-3 (right, left, down, up respectively)
Map_DrawBridgeCheck:	.byte TILE_DRAWBRIDGEH, TILE_DRAWBRIDGEH, TILE_DRAWBRIDGEV, TILE_DRAWBRIDGEV

	; Matching elements for Map_DrawBridgeCheck, looks to see if World3_Bridge value is
	; an appropriate number to allow crossing of the bridge
Map_DrawBridgeCheckV:	.byte $00, $00, $01, $01

	; Appropriate Y, X, and XHi offsets to check for a canoe based on direction 0-3
	; 0-3 (right, left, down, up respectively)
Map_CanoeCheckYOff:	.byte  0,   0, 16, -16
Map_CanoeCheckXOff:	.byte 16, -16,  0,   0
Map_CanoeCheckXHiOff:	.byte  0,  $FF, 0,   0	; Remember, this is used more as a 16-bit sign extension, hence $FF in position of X's -16


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_CheckDoMove
;
; Checks if able to move and performs moves based on Player's pad input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_CheckDoMove:
	LDA <Pad_Holding
	STA <Temp_Var4		; Temp_Var4 = Pad_Holding

	LDA Map_InCanoe_Flag
	BNE PRG010_D296	 	; If Player is in canoe, jump to PRG010_D296

	LDX Player_Current
	LDA Map_MoveRepeat,X
	BEQ PRG010_D296		; If Player's "move repeat" value is at zero, jump to PRG010_D296

	CMP #$18
	BEQ PRG010_D296	 	; If the "move repeat" value is at $18 (the max), jump to PRG010_D296

	RTS		 	; Return...

PRG010_D296:

	LDY #$03	 	; Y = 3
	LDA <Temp_Var4		; A = Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)	 	; Just up/down/left/right

PRG010_D29C:
	CMP Map_HoldPadDir,Y
	BEQ PRG010_D2A5	 	; If this is the direction the Player was going, jump to PRG010_D2A5
	DEY		 	; Y--
	BPL PRG010_D29C	 	; While Y >= 0, loop!

	RTS		 	; Return...

PRG010_D2A5:

	; 'A' is the Pad_Holding value...

	; This loop converts R01 L02 D04 U08 to 0, 1, 2, 3
	LDY #$00	 	; Y = 0
PRG010_D2A7
	LSR A		 	; A >>= 1
	BCS PRG010_D2AD	 	; If the LSb of 'A' was set, jump to PRG010_D2AD
	INY		 	; Y++
	BNE PRG010_D2A7	 	; Loop (shouldn't be more than 3 times)

PRG010_D2AD:
	TYA		 	; A = 0-3
	STA <Temp_Var3		; Temp_Var3 = 0-3 (right, left, down, up respectively)
	ASL A		 	

	TAX		 	; X = A << 1 (indexing Map_Object_Valid_Tiles)

	; [Temp_Var2][Temp_Var1] become an address into Map_Object_Valid_Tiles
	LDA Map_Object_Valid_Tiles,X
	STA <Temp_Var1		 
	LDA Map_Object_Valid_Tiles+1,X
	STA <Temp_Var2		 

	JSR MapTile_Get_By_Offset	; Get tile Player is going to move over (adjacent tile in travel direction)

	; Search to see if this is a valid to move over given the Player's direction et al.
	LDY #(Map_Object_Valid_Tiles2Check-1)
PRG010_D2C1:
	CMP [Temp_Var1],Y	
	BEQ PRG010_D336	 	; If Player is going to travel over this particular valid tile, jump to PRG010_D336
	DEY		 	; Y--
	BPL PRG010_D2C1	 	; While Y >= 0, loop!

	; Player is not on any of the valid tiles...

	LDY Map_InCanoe_Flag
	BEQ PRG010_D2E1	 	; If Player is NOT in a canoe, jump to PRG010_D2E1

	CMP #TILE_DOCK	 
	BNE PRG010_D2D8	 	; If Player is not docking, jump to PRG010_D2D8

	LDA #$00
	STA Map_InCanoe_Flag	; Map_InCanoe_Flag = 0
	BEQ PRG010_D332	 	; Jump (technically always) to PRG010_D332

PRG010_D2D8:
	; Canoe range checks!

	CMP #TILE_WATER_INVT
	BLT PRG010_D310	 	; If tile is less than the inverted-T water tile, jump to PRG010_D310

	CMP #TILE_VERTPATHWLU
	BLT PRG010_D332		; If tile is less than the overwater path tile, jump to PRG010_D332

	; Tile index larger than TILE_VERTPATHWLU / $AA can never be moved over in the canoe

	RTS		 ; Return

PRG010_D2E1:
	; On a dock, not in a canoe!  But let's see if there's one to hop into...

	LDY World_Map_Tile
	CPY #TILE_DOCK	
	BNE PRG010_D310	 	; If Player is not standing on a dock tile, jump to PRG010_D310

	LDY <Temp_Var3		; Y = Temp_Var3; 0-3 (right, left, down, up respectively)

	LDX Player_Current
	LDA <World_Map_Y,X
	ADD Map_CanoeCheckYOff,Y
	STA <Temp_Var1		; Temp_Var1 = Player's Y on map plus an appropriate offset to search for canoe

	LDA <World_Map_X,X
	ADD Map_CanoeCheckXOff,Y
	STA <Temp_Var2		; Temp_Var2 is like Temp_Var1, for X

	LDA <World_Map_XHi,X	
	ADC Map_CanoeCheckXHiOff,Y
	STA <Temp_Var3		; Temp_Var3 is like Temp_Var2, for X Hi

	LDX #(MAPOBJ_TOTAL-1) 	; X = (MAPOBJ_TOTAL-1) (search all map objects)
PRG010_D306:
	LDY Map_Objects_IDs,X	
	CPY #MAPOBJ_CANOE
	BEQ PRG010_D31D	 	; If this is a canoe, jump to PRG010_D31D
	DEX		 	; X--
	BNE PRG010_D306	 	; If X > 0, loop! (NOTE: Does not check map object index 0 as a canoe

PRG010_D310:
	LDA Pad_Input
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	BEQ PRG010_D31C	 	; If Player is not pressing left/right/down/up, jump to PRG010_D31C (RTS)

	LDA #SND_PLAYERBUMP	 
	STA Sound_QPlayer	; Play "bump" sound (there's no canoe here or tile can't possibly be moved over [< TILE_WATER_INVT/$82])

PRG010_D31C:
	RTS		 	; Return!

PRG010_D31D:
	; There's a canoe here...!

	; Temp_Var1-3 configure a detection position precisely one tile away
	; from the Player in whatever direction is appropriate; the canoe
	; must match this coordinate precisely.

	; NOTE: Currently the detection loop, as it stands, works for ONE CANOE 
	; PER MAP ONLY!!  (Because as soon as it finds one, it jumps down here,
	; and there's no mechanism to return to the loop!)

	; If the canoe isn't positioned right for any of the calculated coordinates,
	; we fail this test (and make the "bump" sound if needed)

	LDY Map_Object_ActY,X
	CPY <Temp_Var1	
	BNE PRG010_D310	

	LDY Map_Object_ActX,X	
	CPY <Temp_Var2	
	BNE PRG010_D310	 

	LDY Map_Object_ActXH,X
	CPY <Temp_Var3	
	BNE PRG010_D310	 

PRG010_D332:
	LDA #16		 ; A = 16 (canoe movement amount)
	BNE PRG010_D349	 ; Jump (technically always) to PRG010_D349

PRG010_D336:
	; Player has a tile he can travel over ... (non-canoe)

	LDX #SND_MAPPATHMOVE		; X = SND_MAPPATHMOVE

	; Drawbridge check!
	LDY <Temp_Var3			; Y = Temp_Var3; 0-3 (right, left, down, up respectively)
	CMP Map_DrawBridgeCheck,Y	
	BNE PRG010_D347	 		; If Player is not crossing a draw bridge tile, jump to PRG010_D347

	LDA World3_Bridge
	CMP Map_DrawBridgeCheckV,Y
	BNE PRG010_D359	 		; If the bridge is up, jump to PRG010_D359

PRG010_D347:
	; Valid tile move!
	; Note: 32 is used here, it's also relied on in the logic further down (see a bit below PRG010_CEF4)
	LDA #32		 		; A = 32 (value to be stored into World_Map_Move, i.e. units to move, two tiles [16 * 2])

PRG010_D349:
	LDX Player_Current
	STA <World_Map_Move,X	 	; Tell Player to move 'A' units

	LDA <Temp_Var4			; A = Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)	; Just the left/right/down/up bits
	STA <World_Map_Dir,X	 	; Store as movement direction!
	STA Map_PrevMoveDir	 	; Store as previous move!

	LDX #SND_MAPPATHMOVE 		; Play the "path move" sound!

PRG010_D359:
	; The only possible value that ever gets here in 'X' is SND_MAPPATHMOVE; 
	; they may have intended other possible sounds to play e.g. in the canoe.
	; Of note, the check used after Map_CheckDoMove is called is to see if
	; Sound_QMap = 0, which would indicate failure to traverse a path.
	STX Sound_QMap

	RTS		 		; Return...!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get_Tile_By_Offset
;
; Returns the tile that the Player is standing on or near, selected
; by input 'Y' register.  Tile returned in 'A'.  'X' is two times
; the screen/Player X Hi byte when this function exits...
; Y is a value from 0-3 specifying a "search direction"
; 0 = To the right
; 1 = To the left
; 2 = Below
; 3 = Above
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Search_YOff:	.byte -16, -16, 0, -32
Search_XHiOff:	.byte   0,  -1, 0,   0
Search_XOff:	.byte  16, -16, 0,   0

MapTile_Get_By_Offset:	; $D369
	; Y is a value from 0-3 specifying a "search direction"
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_Y,X	; A = player's current Y position on-map
	ADD Search_YOff,Y	; Offset Player's Y based on current search direction
	STA <Temp_Var15		; Store into Temp_Var15

	LDA <World_Map_X,X	; A = player's current X position on-map
	ADD Search_XOff,Y	; Offset Player's X based on current search direction
	STA <Temp_Var16	; Store into Temp_Var16

	LDA <World_Map_XHi,X	; A = player's current X Hi position on-map
	ADC Search_XHiOff,Y	; Offset Player's X Hi based on current search direction
	ASL A		 	; Take result, left shift 1 (two byte offset into Tile_Mem_Addr)
	TAX		 	; X = A (selects starting offset for this screen)

	; Store starting offset for this map screen into Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Effectively adds $100 to the address (maps get loaded at screen base + $110)

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16	; Temp_Var16 = Temp_Var16 >> 4

	LDA <Temp_Var15
	AND #$f0		; Aligns Player's Y to a tile
	ORA <Temp_Var16
	TAY		 	; Y = (Temp_Var15 & 0xF0) | Temp_Var15 (offset to specific tile Player is at)
	LDA [Map_Tile_AddrL],Y	; Get this tile
	RTS		 	; Return!
 
	; Offsets around Player for darkness effect
Map_W8D_XOffTable:	.byte -16, 32, 32, -16
Map_W8D_YOffTable:	.byte -16, 32, 32, -16

	; Update darkness around Player
Map_W8DarknessUpdate:
	; Map_W8D_Idx starts at 0
	; A = Player's X coordinate + some offset
	; Y = Player's Y coordinate
	; X = 1

	; Set variables by input parameters
	STA Map_W8D_XOff
	STY Map_W8D_YOff
	STX Map_W8D_Dir	

	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0

	LDA Map_W8D_Dir	 ; A = Map_W8D_Dir
	AND #$03	 
	BEQ PRG010_D3E3	 ; If (Map_W8D_Dir & 3) = 0 (every 4 counts), jump to PRG010_D3E3

	LDY #$86	 ; Y = $86
	STY <Temp_Var3	 ; Temp_Var3 = $86

	AND #$02
	BNE PRG010_D3C6
	INX		 ; If (Map_W8D_Dir & 2) = 0 (every 2 counts), X++
PRG010_D3C6:
	LDA Map_W8D_Idx	 ; A = Map_W8D_Idx
	BEQ PRG010_D3CD	 ; If Map_W8D_Idx = 0, jump to PRG010_D3CD
	INX
	INX		 ; Otherwise, X += 2
PRG010_D3CD:
	LDA Map_W8D_XOff 	; A = Map_W8D_XOff
	ADD Map_W8D_XOffTable,X	; Add appropriate offset for here
	STA Map_W8D_X	 	; Store result into Map_W8D_X

	LDA Map_W8D_YOff
	SUB #16		
	STA Map_W8D_Y		; Map_W8D_Y = Map_W8D_YOff - 16
	JMP PRG010_D40B	 	; Jump to PRG010_D40B

PRG010_D3E3:
	LDY #$06	 	; Y = 6
	STY <Temp_Var3		; Temp_Var3 = 6
	LDX #$00	 	; X = 0
	LDA Map_W8D_Dir	; A = Map_W8D_Dir
	AND #$08	 	
	BNE PRG010_D3F1
	INX		 	; If (Map_W8D_Dir & 8) = 0 (every 8 counts), X++
PRG010_D3F1:
	LDA Map_W8D_Idx	 	; A = Map_W8D_Idx
	BEQ PRG010_D3F8	 	; If Map_W8D_Idx = 0, jump to PRG010_D3F8
	INX
	INX		 	; Otherwise, X += 2
PRG010_D3F8:
	LDA Map_W8D_YOff
	ADD Map_W8D_YOffTable,X	
	STA Map_W8D_Y		; Map_W8D_Y = Map_W8D_Y + Y offset

	LDA Map_W8D_XOff
	SUB #16
	STA Map_W8D_X	 	; Map_W8D_X = Map_W8D_XOff - 16

PRG010_D40B:
	LDA Map_W8D_Y	 	; A = Map_W8D_Y
	LDX Map_W8D_X	 	; X = Map_W8D_X
	JSR W8D_Calc_VRAM_Addr	; Returns Temp_Var15 as the video address we need to modify

	; Store Temp_Var15 -> Map_W8D_VAddrH/L
	LDA <Temp_Var15
	STA Map_W8D_VAddrH
	LDA <Temp_Var16
	STA Map_W8D_VAddrL

	JSR W8D_Calc_RC	; Calculate the Map_W8D_RC value (row in upper bits, column in lower bits)

	; Copy Map_W8D_VAddrH/L -> Map_W8D_VAddrH2/L2
	LDA Map_W8D_VAddrH
	STA Map_W8D_VAddrH2
	LDA Map_W8D_VAddrL
	STA Map_W8D_VAddrL2

	JSR W8D_FillGraphicsBuffer	 ; Fill graphics buffer with commands required

	; Set the terminator
	LDA #$00
	STA Graphics_Buffer,Y

	; Update Graphics_BufCnt
	STY Graphics_BufCnt
	RTS		 ; Return

W8D_FillGraphicsBuffer:
	LDA Map_W8D_Dir
	AND #$03
	BNE PRG010_D445	 	; If traveling left or right, jump to PRG010_D445

	; Traveling up or down 

	LDA #$01		; A = 1 (1 byte, i.e. horizontal offset between 8x8 patterns)
	TAX		 	; X = 1 (1 byte, i.e. horizontal offset between map tiles)
	BNE PRG010_D449	 	; (technically always) jump to PRG010_D449

PRG010_D445:
	LDA #32	 ; A = 32 (32 bytes, i.e. vertical offset between 8x8 patterns)
	LDX #16	 ; X = 16 (16 bytes, i.e. vertical offset between map tiles)
PRG010_D449:
	STA <Temp_Var6
	STX <Temp_Var7

	LDY Graphics_BufCnt	; Y = Graphics_BufCnt
	LDX #$05	 	; X = 5

	LDA Map_W8D_VAddrH2
	STA Graphics_Buffer,Y

	INY

	LDA Map_W8D_VAddrL2
	STA Graphics_Buffer,Y

	INY

	LDA <Temp_Var3	
	STA Graphics_Buffer,Y

	INY

PRG010_D466:
	LDA Map_W8D_Idx
	BEQ PRG010_D46F	 ; If Map_W8D_Idx = 0, jump to PRG010_D46F

	LDA #$ff	 ; A = $FF
	BNE PRG010_D472	 ; Jump (technically always) to PRG010_D472

PRG010_D46F:
	JSR W8D_GetNext8x8	 ; Get next 8x8 tile to display

PRG010_D472:
	STA Graphics_Buffer,Y	 ; Store into graphics buffer
	INY		 ; Y++ Next buffer byte

	; Address offset to next 8x8 pattern
	LDA Map_W8D_VAddrL2
	ADD <Temp_Var6
	STA Map_W8D_VAddrL2
	LDA Map_W8D_VAddrH2
	ADC #$00
	STA Map_W8D_VAddrH2

	TXA
	AND #$01
	BNE PRG010_D495	; If we're offseting horizontally instead of vertically, jump to PRG010_D495

	; Offsetting vertically...

	; Offset to next row
	LDA Map_W8D_RC
	ADD <Temp_Var7
	STA Map_W8D_RC

PRG010_D495:
	DEX			; X--
	BPL PRG010_D466		; While X >= 0, loop

	RTS		 ; Return

W8D_Calc_RC:
	LDA Map_W8D_Y
	AND #$f0	 ; Grid align 
	STA Map_W8D_RC ; -> Map_W8D_RC

	LDA Map_W8D_X
	LSR A		
	LSR A		
	LSR A		
	LSR A		 ; Shift right 4 bits (column)
	ORA Map_W8D_RC
	STA Map_W8D_RC ; Form row/column offset -> Map_W8D_RC

	RTS		 ; Return


W8D_GetNext8x8:
	; Backup X and Y into Temp_Var2 and Temp_Var5
	STY <Temp_Var2		 
	STX <Temp_Var5

	JSR W8D_Calc_TileOff	 ; Calculate offset within tile

	LDY Map_W8D_RC	 ; Y = row/column offset

	; Uses a fixed offset of Tile_Mem + $450
	LDA Tile_Mem + $450,Y	 ; Get tile here
	STA <Temp_Var11		 ; -> Temp_Var11

	; Switch to page 12 @ A000 (for map tile 8x8 layout data)
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #12
	STA MMC3_PAGE

	JSR TileLayout_GetBaseAddr	 ; Set Temp_Var13/14 to layout pointer, and reload Y = Temp_Var11 (the tile)

	LDA Map_W8D_TileOff	; In-tile offset
	ADD <Temp_Var14
	STA <Temp_Var14		; Temp_Var14 += Map_W8D_TileOff

	LDA [Temp_Var13],Y	; Load this 8x8 pattern of tile
	PHA		 ; Save it

	; Restore previous page @ A000
	JSR PRGROM_Change_A000

	PLA		 ; Restore 8x8 pattern

	; Restore X and Y
	LDY <Temp_Var2
	LDX <Temp_Var5

	RTS		 ; Return

W8D_Calc_VRAM_Addr:
	; A = Map_W8D_Y
	; X = Map_W8D_X

	; This will shift 'A' to the left twice, but with each shift immediately put the
	; shifted out carry right back into the bit 0 position...
	ASL A
	ADC #$00
	ASL A	
	ADC #$00
	STA <Temp_Var13	 ; Result -> <Temp_Var13

	TXA		 ; A = X (Map_W8D_X)
	LSR A
	LSR A
	LSR A
	STA <Temp_Var14 ; <Temp_Var14 = Map_W8D_X >> 3

	; Forming a video address into Temp_Var15
	LDA <Temp_Var13	 ; 
	AND #$03	 ; Cap within Name table 2
	ORA #$28	 ; Name Table 2 hi addr
	STA <Temp_Var15  ; Video address -> Temp_Var15

	LDA <Temp_Var13	  
	AND #$e0	  
	ORA <Temp_Var14  
	STA <Temp_Var16
	RTS		 ; Return


W8D_Calc_TileOff:
	LDA Map_W8D_VAddrL2
	AND #$01
	STA Map_W8D_TileOff

	LDA Map_W8D_VAddrL2
	AND #$20
	BNE PRG010_D513

	ASL Map_W8D_TileOff
	JMP PRG010_D517	 ; Jump to PRG010_D517

PRG010_D513:
	SEC
	ROL Map_W8D_TileOff

PRG010_D517:
	RTS		 ; Return


	; FIXME: Anybody want to claim this? (PRG010_D535)
PRG010_D518:
	.byte $16, $36, $0F, $2A, $36, $0F, $2A, $26, $0F, $17, $36, $0F, $30, $36, $0F, $27
	.byte $36, $16, $02, $05, $08, $0B, $0E, $11, $BC, $2A, $D5, $A2, $02

PRG010_D535:
	LDA PRG010_D518,Y	 	; Get palette value
	STA Palette_Buffer+$11,X	; Store into palette buffer

	DEY		 ; Y--
	DEX		 ; X--
	BPL PRG010_D535	 ; While X >= 0, loop

	; Command palette update
	LDA #$06
	STA <Graphics_Queue

	RTS		 ; Return

; Rest of ROM bank was empty


CheckAllowedToPass:
	LDA World_Map_Tile
	CMP #TILE_FORTPARTIAL
	BEQ _allow_pass
	SEC
	SBC #13
	CMP #12			; tiles 0 - 11 (after subtracting 13) are our reenterable tiles
	BCS _judgem_check
_allow_pass:
	LDA #$07
	BNE _cmp7_rts		; branch always
_judgem_check:
	LDA Map_Power_Disp
_cmp7_rts:
	CMP #$07
	RTS

;;; [ORANGE] This section for Map NPCs
CheckForNPCInteraction:
	;;; This function needs to LDA Map_Pan_Count if we're returning
	LDA <Pad_Input
	AND #PAD_SELECT					; If we're pressing select, look for an NPC around us
	BEQ _no_npc_interaction
	JSR FindNPCNearby
	BNE _no_npc_interaction
_do_npc_interaction:
	LDA #$01
	STA World_EnterState
	STA <Map_DoNPC
	LDA #$00
	STA Map_Operation				; Back to opening sequence
	PLA
	PLA								; return to our caller's caller...
	RTS								; We don't want to continue the MO_NormalMoveEnter state (unless to draw?)
_no_npc_interaction:
	LDA Map_Pan_Count
	RTS

;;; [ORANGE] This function checks all the directions around the player on the map for
;;; one of the tiles in the NPCTileIDList. It returns zero flag set if found.
FindNPCNearby:
	LDY #$03
_findnpc_loopdir:
	TYA
	PHA							; Save off Y
	JSR MapTile_Get_By_Offset	; 3 = up, 2 = down, 1 = left, 0 = right, returns the tile in A
	TAX							; Save off A so we can use it to restore Y
	PLA
	TAY							; Restore Y
	TXA							; Restore A
	LDX #(NPC_END-NPCTileIDList-1)
_findnpc_looplist:
	CMP NPCTileIDList,X			; Does the tile around us match an NPC tile?
	BEQ _findnpc_found
	DEX
	BPL _findnpc_looplist
	DEY
	BPL _findnpc_loopdir
	RTS							; Didn't find anything, return with our zero flag not set
_findnpc_found:
	STX <Map_NPCType
	LDA #$00
	RTS							; Found NPC, return with our zero flag set


WorldIntro_Or_NPCInteraction:
	LDA <Map_DoNPC
	BEQ _world_intro
	JSR DoNPCMessage
	PLA
	PLA
	RTS							; Don't return to WorldIntro_EraseAndStars
_world_intro:
	JSR Map_Intro_Erase1Strip
	RTS

DoNPCMessage:
	; TODO: We'll have a state machine here that controls drawing the message box,
	; then drawing the NPC's message, then handling input to scroll the message,
	; then we'll INC Map_Operation
	LDA <Map_NPCTextTimer
	BEQ _post_npctimerdec
	DEC <Map_NPCTextTimer
_post_npctimerdec:
	LDY <Map_DoNPC
	DEY
	TYA
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word NPC_DrawBox
	.word NPC_DialogInit
	.word NPC_DoDialog
	.word NPC_WaitForInput
	.word NPC_Draw1Strip

	LDA #$0e
	JSR Video_Do_Update
	INC World_EnterState
	DEC <Map_DoNPC
	RTS

NPCBox1:
	vaddr $2904
	.byte $01, $A0
	vaddr $2905
	.byte VU_REPEAT | 22, $A1
	vaddr $291B
	.byte $01, $A2
	.byte $FF

NPCBox2:
	vaddr $2924
	.byte $01, $E6
	vaddr $2925
	.byte VU_REPEAT | 22, $FE
	vaddr $293B
	.byte $01, $E7
	vaddr $2944
	.byte $01, $E6
	vaddr $2945
	.byte VU_REPEAT | 22, $FE
	vaddr $295B
	.byte $01, $E7
	.byte $FF

NPCBox3:
	vaddr $2BD1
	.byte $06, $00, $00, $00, $00, $00, $00
	.byte $FF

NPCBox4:
	vaddr $2964
	.byte $01, $E6
	vaddr $2965
	.byte VU_REPEAT | 22, $FE
	vaddr $297B
	.byte $01, $E7
	vaddr $2984
	.byte $01, $E6
	vaddr $2985
	.byte VU_REPEAT | 22, $FE
	vaddr $299B
	.byte $01, $E7
	.byte $FF

NPCBox5:
	vaddr $29A4
	.byte $01, $E6
	vaddr $29A5
	.byte VU_REPEAT | 22, $FE
	vaddr $29BB
	.byte $01, $E7
	vaddr $29C4
	.byte $01, $E6
	vaddr $29C5
	.byte VU_REPEAT | 22, $FE
	vaddr $29DB
	.byte $01, $E7
	.byte $FF

NPCBox6:
	vaddr $2BD9
	.byte $06, $00, $00, $00, $00, $00, $00
	.byte $FF

NPCBox7:
	vaddr $29E4
	.byte $01, $E6
	vaddr $29E5
	.byte VU_REPEAT | 22, $FE
	vaddr $29FB
	.byte $01, $E7
	vaddr $2A04
	.byte $01, $E6
	vaddr $2A05
	.byte VU_REPEAT | 22, $FE
	vaddr $2A1B
	.byte $01, $E7
	.byte $FF

NPCBox8:
	vaddr $2A24
	.byte $01, $E6
	vaddr $2A25
	.byte VU_REPEAT | 22, $FE
	vaddr $2A3B
	.byte $01, $E7
	vaddr $2A44
	.byte $01, $E6
	vaddr $2A45
	.byte VU_REPEAT | 22, $FE
	vaddr $2A5B
	.byte $01, $E7
	.byte $FF

NPCBox9:
	vaddr $2A64
	.byte $01, $E3
	vaddr $2A65
	.byte VU_REPEAT | 22, $E4
	vaddr $2A7B
	.byte $01, $E5
	vaddr $2BE1
	.byte $06, $00, $00, $00, $00, $00, $00
	.byte $FF

NPCBoxTemplate:
	.word NPCBox1, NPCBox2, NPCBox3, NPCBox4, NPCBox5, NPCBox6, NPCBox7, NPCBox8, NPCBox9

NPC_DrawBox:
	LDA <Map_NPCLineNo
	ASL A
	TAX
	LDA NPCBoxTemplate,X
	STA <Temp_Var1
	LDA NPCBoxTemplate+1,X
	STA <Temp_Var2
	JSR _NPC_DrawBoxLine
	RTS

_NPC_DrawBoxLine:
	LDX Graphics_BufCnt
	LDY #$00
_boxline_loop:
	LDA [Temp_Var1],Y
	CMP #$FF
	BNE _store_boxbyte
	LDA #$00
	STA Graphics_Buffer,X
	BEQ _post_box_loop
_store_boxbyte:
	STA Graphics_Buffer,X
	INX
	INY
	BNE _boxline_loop
_post_box_loop:
	INX
	STX Graphics_BufCnt
	LDA Map_NPCLineNo
	CMP #8						; 9 frames total
	BNE _npc_draw_box_cont
	INC <Map_DoNPC				; Go to next NPC state when we've drawn the whole box
	LDA #$FF
	STA <Map_NPCLineNo
_npc_draw_box_cont:
	INC <Map_NPCLineNo
	LDA #$00
	STA <Graphics_Queue
	RTS

NPCTileIDList:
	.byte TILE_NPCGIRL1, TILE_NPCGIRL2, TILE_NPCGIRL3, TILE_NPCBOY1, TILE_NPCBOY2, TILE_NPCDOG
NPC_END

;Welcome,stranger,to
;our town.Are you here
;to help us with the
;orbs?
;Some say Old Man
;Grimm is behind them,
;but no one knows what
;they are.
NPCMessage1:
	.byte $00
	.byte $D8, $DC, $90, $E2, $93, $91, $DC, $B4, $A9, $AA, $A8, $E0, $92, $DE, $DC, $A8, $B4, $AA, $93, $00
	.byte $93, $AB, $A8, $FE, $AA, $93, $B1, $92, $58, $BC, $A8, $DC, $FE, $B3, $93, $AB, $FE, $FA, $DC, $A8, $DC, $00
	.byte $AA, $93, $FE, $FA, $DC, $90, $D9, $FE, $AB, $A9, $FE, $B1, $84, $AA, $FA, $FE, $AA, $FA, $DC, $00
	.byte $93, $A8, $E1, $A9, $56, $00
	.byte $C1, $93, $91, $DC, $FE, $A9, $E0, $B3, $FE, $F0, $90, $EF, $FE, $BA, $E0, $92, $00
	.byte $EB, $A8, $84, $91, $91, $FE, $84, $A9, $FE, $E1, $DC, $FA, $84, $92, $EF, $FE, $AA, $FA, $DC, $91, $B4, $00
	.byte $E1, $AB, $AA, $FE, $92, $93, $FE, $93, $92, $DC, $FE, $85, $92, $93, $B1, $A9, $FE, $B1, $FA, $E0, $AA, $00
	.byte $AA, $FA, $DC, $B3, $FE, $E0, $A8, $DC, $58, $FF

;Please continue
;searching until you
;have found all the
;orbs.
NPCMessage2:
	.byte $00
	.byte $D9, $90, $DC, $E0, $A9, $DC, $FE, $E2, $93, $92, $AA, $84, $92, $AB, $DC, $00
	.byte $A9, $DC, $E0, $A8, $E2, $FA, $84, $92, $DE, $FE, $AB, $92, $AA, $84, $90, $FE, $B3, $93, $AB, $00
	.byte $FA, $E0, $B0, $DC, $FE, $DD, $93, $AB, $92, $EF, $FE, $E0, $90, $90, $FE, $AA, $FA, $DC, $00
	.byte $93, $A8, $E1, $A9, $58, $FF

;It's so sad,what's\n
;happened to Mr. Grimm.\n
;He used to be such a\n
;kind man,but what he's\n
;become now...
NPCMessage3:
	.byte $00
	.byte $FC, $AA, $B5, $A9, $FE, $A9, $93, $FE, $A9, $E0, $EF, $B4, $B1, $FA, $E0, $AA, $B5, $A9, $00
	.byte $FA, $E0, $D9, $D9, $DC, $92, $DC, $EF, $FE, $AA, $93, $FE, $BA, $A8, $58, $FE, $EB, $A8, $84, $91, $91, $58, $00
	.byte $CF, $DC, $FE, $AB, $A9, $DC, $EF, $FE, $AA, $93, $FE, $E1, $DC, $FE, $A9, $AB, $E2, $FA, $FE, $E0, $00
	.byte $85, $84, $92, $EF, $FE, $91, $E0, $92, $B4, $E1, $AB, $AA, $FE, $B1, $FA, $E0, $AA, $FE, $FA, $DC, $B5, $A9, $00
	.byte $E1, $DC, $E2, $93, $91, $DC, $FE, $92, $93, $B1, $58, $58, $58, $FF

;Old Man Grimm?
;
;That dude's lost his
;marbles.
NPCMessage4:
	.byte 00
	.byte $F0, $90, $EF, $FE, $BA, $E0, $92, $FE, $EB, $A8, $84, $91, $91, $56, $00
	.byte $00
	.byte $EA, $FA, $E0, $AA, $FE, $EF, $AB, $EF, $DC, $B5, $A9, $FE, $90, $93, $A9, $AA, $FE, $FA, $84, $A9, $00
	.byte $91, $E0, $A8, $E1, $90, $DC, $A9, $58, $FF

;Aside from the obvious
;orbs in the boxes,I've
;always noticed a
;seemingly out of place
;coin near any well
;hidden orb.
NPCMessage5:
	.byte 00
	.byte $BC, $A9, $84, $EF, $DC, $FE, $DD, $A8, $93, $91, $FE, $AA, $FA, $DC, $FE, $93, $E1, $B0, $84, $93, $AB, $A9, $00
	.byte $93, $A8, $E1, $A9, $FE, $84, $92, $FE, $AA, $FA, $DC, $FE, $E1, $93, $B2, $DC, $A9, $B4, $FC, $B5, $B0, $DC, $00
	.byte $E0, $90, $B1, $E0, $B3, $A9, $FE, $92, $93, $AA, $84, $E2, $DC, $EF, $FE, $E0, $00
	.byte $A9, $DC, $DC, $91, $84, $92, $DE, $90, $B3, $FE, $93, $AB, $AA, $FE, $93, $DD, $FE, $D9, $90, $E0, $E2, $DC, $00
	.byte $E2, $93, $84, $92, $FE, $92, $DC, $E0, $A8, $FE, $E0, $92, $B3, $FE, $B1, $DC, $90, $90, $00
	.byte $FA, $84, $EF, $EF, $DC, $92, $FE, $93, $A8, $E1, $58, $FF

NPCMsgPtr_L:
	.byte LOW(NPCMessage1)
	.byte LOW(NPCMessage2)
	.byte LOW(NPCMessage3)
	.byte LOW(NPCMessage4)
	.byte LOW(NPCMessage5)

NPCMsgPtr_H:
	.byte HIGH(NPCMessage1)
	.byte HIGH(NPCMessage2)
	.byte HIGH(NPCMessage3)
	.byte HIGH(NPCMessage4)
	.byte HIGH(NPCMessage5)

NPC_DialogInit:
	LDA #$29
	STA <Map_NPCMsg_VH
	LDA #$25
	STA <Map_NPCMsg_VL

	LDX <Map_NPCType
	LDA NPCMsgPtr_L,X
	STA <Map_NPCCPos			; current character (low byte of pointer)
	LDA NPCMsgPtr_H,X
	STA <Map_NPCMsgHi			; high byte of current message pointer

NPC_DialogNextState:
	LDA #$00
	STA <Map_NPCLine
	INC <Map_DoNPC
	RTS

NPC_VH_ByLine:
	.byte $29, $29, $29, $29, $29, $29, $2A, $2A, $2A
NPC_VL_ByLine:
	.byte $45, $65, $85, $A5, $C5, $E5, $05, $25, $45

NPC_DoDialog:
	LDA <Map_NPCTextTimer
	BNE _npc_text_rts

	INC <Map_NPCCPos			; Next character
	BNE _npc_post_ptr_inc		; If <Map_NPCCPos did not overflow, jump to PRG027_A4B9
	INC <Map_NPCMsgHi			; Otherwise, apply carry
_npc_post_ptr_inc:

	; Get next character
	LDY #$00
	LDA [Map_NPCCPos],Y
	BEQ _npc_line_brk
	CMP #$FF
	BEQ NPC_DialogNextState

	LDY Graphics_BufCnt		; Y = current graphics buffer count

	; Store character into buffer
	STA Graphics_Buffer+$3,Y

	; Store VRAM high address
	LDA <Map_NPCMsg_VH
	STA Graphics_Buffer,Y

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+$2,Y

	; Terminator
	LSR A				; A = 0
	STA Graphics_Buffer+$4,Y

	; Update Graphics_BufCnt
	TYA
	ADD #$04
	STA Graphics_BufCnt

	; Store VRAM low address
	LDA <Map_NPCMsg_VL
	STA Graphics_Buffer+$1,Y

	INC <Map_NPCMsg_VL			; next column
	BNE _npc_do_character		; Always jump

_npc_line_brk:
	; Line break!
	INC <Map_NPCLine
	LDX <Map_NPCLine
	DEX
	LDA NPC_VL_ByLine,X
	STA <Map_NPCMsg_VL
	LDA NPC_VH_ByLine,X
	STA <Map_NPCMsg_VH

_npc_do_character:
	; Map_NPCTextTimer = 1
	LDA #$01
	STA <Map_NPCTextTimer

_npc_text_rts:
	RTS

NPC_WaitForInput:
	LDA <Pad_Input
	AND #(PAD_A | PAD_B)	; A or B closes the NPC message
	BEQ _npcwait_rts
	LDA #$00
	STA <Map_Intro_CurStripe
	INC <Map_DoNPC			; Close the NPC message box
_npcwait_rts:
	RTS

NPC_ColorStrip:
	.byte $AF, $A8, $9A, $99, $AA, $55, $AA, $A8, $A8, $AA, $AA, $7A, $AA, $AA, $AA, $A8, $68, $A8
NPC_Draw1Strip:
	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA <Map_IntBoxErase
	BNE _PRG010_C5C5	 	; If Map_IntBoxErase <> 0, jump to PRG010_C5A9

	; Map_IntBoxErase is set to offset of upper-left corner of "World X"
	; intro box to tell where to start copying the map tiles from!
	LDA #$32
	STA <Map_IntBoxErase

	LDA <Scroll_ColumnL
	AND #$f0
	LSR A
	LSR A
	LSR A
	TAY		 	; Y = (Scroll_ColumnL & $F0) >> 3 (basically current "screen" of map * 2, for indexing Tile_Mem_Addr)

	; Store starting offset for this map screen into Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,Y
	STA <Map_Tile_AddrH

	INC <Map_Tile_AddrH	; Effectively adds $100 to the address (maps get loaded at screen base + $110)

	; The base offset into the nametable for erasing the NPC box
	LDA #$04
	STA <Map_Intro_NTOff

	; Calculates the corresponding offset to the attribute table
	LDA <Horz_Scroll
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A			; Divide by 32 because EACH attribute BYTE defines FOUR 8x8 tiles (4 * 8 = 32)
	ADD #$d1
	STA <Map_Intro_ATOff		; Map_Intro_ATOff = (Horz_Scroll / 32) + $D2

	;LDA #$02
	;STA <Map_StarsState		; Map_StarsState = 2

_PRG010_C5C5:
	LDA Map_IntBoxErase
	STA <Temp_Var1		 	; Temp_Var1 = Map_IntBoxErase

	LDX #$00	 		; X = 0

_PRG010_C5CC:
	; CHECKME: Isn't Level_Tileset always equal to zero on world maps??
	; Probably wouldn't matter since PAGE_A000 is hard-coded to 12,
	; instead of using Page_Per_Tileset like it ought to :)
	LDA Level_Tileset
	ASL A
	TAY		 		; Y = Level_Tileset << 1 (for indexing TileLayout_ByTileset)

	; Set Temp_Var15 to point to the 16x16 tile 8x8 layout data
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var15
	LDA TileLayout_ByTileset+1,Y
	STA <Temp_Var16

	LDY <Temp_Var1		 	; Get offset to current 16x16 tile we want to grab
	LDA [Map_Tile_AddrL],Y	 	; Grab it!
	TAY		 		; Y = tile

	; The 16x16 tile is laid out in four 256 byte sized "chunks" which define each 8x8
	; in the order of upper-left, lower-left, upper-right, lower-right

	; Upper-left
	LDA [Temp_Var15],Y	 	; Get first 8x8
	STA Scroll_PatStrip,X	 	; Store this 8x8 into the vertical strip

	; Lower-left
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+1,X	; Store this 8x8 into vertical strip, next slot to the right

	; Upper-right
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+$F,X	; Store into vertical strip

	; Lower-right
	INC <Temp_Var16		; Jump to next layout chunk
	LDA [Temp_Var15],Y	 	; Get next 8x8
	STA Scroll_PatStrip+$10,X	; Store into vertical strip

	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1		 	; Temp_Var1 += 16 (get next tile one row down)

	INX
	INX		; X += 2 (next block down in Scroll_PatStrip)

	CPX #12
	BNE _PRG010_C5CC	; If X <> 8 (4 tiles downward in Scroll_PatStrip), loop!

	; Pushes the Scroll_PatStrip memory into the Graphics_Buffer
	LDX #$1A	 		; tile data goes from [03 - 1A] (12 total tiles)
_PRG010_C609:
	LDA Scroll_PatStrip,X
	STA Graphics_Buffer+3,X
	DEX		 		; X--
	BPL _PRG010_C609	 		; If X >= 0, loop!

	; Used VRAM addr $29xx for both strips
	LDA #$29
	STA Graphics_Buffer
	STA Graphics_Buffer+$F

	LDA #(VU_VERT | 12)		; 8 8x8s vertically applied
	STA Graphics_Buffer+2
	STA Graphics_Buffer+$11

_PRG010_C622:
	LDX <Map_Intro_NTOff
	STX Graphics_Buffer+1	 	; Store lower part of VRAM address
	INX
	STX Graphics_Buffer+$10	 	; Store lower part of VRAM address


	; Now it's the attribute table's turn...
	; We hardcoded these for the values we need in W1

	; Store VRAM addr $2Bxx
	LDA #$00
	STA Graphics_Buffer+$1E
	LDA <Map_Intro_CurStripe
	CLC
	ROR A
	TAX							; X = Map_Intro_CurStripe/2
	BCS _PRG010_C66A			; Odd columns skip updating attributes

	LDA #$2b
	STA Graphics_Buffer+$1E
	STA Graphics_Buffer+$22
	STA Graphics_Buffer+$26

	; Store lower part of VRAM address
	LDA <Map_Intro_ATOff
	STA Graphics_Buffer+$1F
	ADD #$08
	STA Graphics_Buffer+$23
	ADD #$08
	STA Graphics_Buffer+$27

	; Just one byte to copy
	LDA #$01
	STA Graphics_Buffer+$20
	STA Graphics_Buffer+$24
	STA Graphics_Buffer+$28

	LDA NPC_ColorStrip,X
	STA Graphics_Buffer+$21

	LDA NPC_ColorStrip+6,X
	STA Graphics_Buffer+$25

	LDA NPC_ColorStrip+12,X
	STA Graphics_Buffer+$29

_PRG010_C66A:
	LDA #$00
	STA Graphics_Buffer+$2A

	; If, on the next increment to Map_IntBoxErase, the lower 4 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_IntBoxErase
	INX
	TXA
	AND #$0f

_PRG010_C689:
	STX <Map_IntBoxErase	; Update Map_IntBoxErase

	TXA
	AND #$01
	BNE _PRG010_C69F	 	; If (Map_IntBoxErase & 1) <> 0 (if we're on an "odd" tile), jump to PRG010_C69F

	; Otherwise need to update the attribute stuff!

	; If, on the next increment to Map_Intro_ATOff, the lower 3 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_Intro_ATOff
	INX
	TXA
	AND #$07

_PRG010_C69D:
	STX <Map_Intro_ATOff	; Update Map_Intro_ATOff


_PRG010_C69F

	; If, on the next +2 to Map_Intro_NTOff, the lower 5 bits are "zero",
	; it has wrapped to a new row.  This should only happen when the "World X"
	; intro is being performed in "halfway off-centered" mode...
	LDX <Map_Intro_NTOff
	INX
	INX
	TXA
	AND #$1f

_PRG010_C6AA:
	STX <Map_Intro_NTOff	; Update Map_Intro_NTOff

	INC <Map_Intro_CurStripe ; Map_Intro_CurStripe++

	LDA <Map_Intro_CurStripe
	CMP #12
	BNE _PRG010_C6BB	 	; If Map_Intro_CurStripe <> 8, jump to PRG010_C6BB

	; Otherwise, we're done!  The stupid box is erased!
	LDA #$00
	STA <Map_IntBoxErase	; Map_IntBoxErase = 0
	STA <Map_DoNPC			; Done with NPC message
	STA <Graphics_Queue		; Push out our last graphics update since we're jumping straight to MO_NORMAL
	JSR GraphicsBuf_Prep_And_WaitVSync
	LDA #$0D
	STA Map_Operation

_PRG010_C6BB:
	; In any case, put page 11 back in at A000
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	RTS		 ; Return