; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-28 13:51:54.652889989 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

; Some constants specific to title screen; they don't really match up with the gameplay
FALL_NORMAL		= 5	; Normal fall rate added to 'Y'
FALL_TAILWAG		= 1	; Adjusted fall rate for when wagging raccoon tail
FALL_OBJECT		= 4	; Fall rate for objects

FALLRATE_TAILWAGMAX	= 8	; Maximum Y velocity falling rate when wagging raccoon tail
FALLRATE_MAX		= $40	; Maximum Y velocity falling rate
FALLRATE_OBJECTMAX	= $60	; Maximum Y velocity falling rate of an object

Cinematic_ToadAndKing:
	LDA Cine_ToadKing
	LSR A
	BNE PRG024_A03A	 ; If Cine_ToadKing > 1, jump to PRG024_A03A

	LDX #$00	 ; X = 0

	JSR Level_PrepareNewObject

	; Disable timer and animations
	LDA #$81	 
	STA Level_TimerEn

	; CineKing_Timer = $20
	LDA #$20
	STA CineKing_Timer

	; Initialize VRAM address for Toad and King Cinematic Dialog Box
	LDA #$28
	STA ToadTalk_VH
	LDA #$46
	STA ToadTalk_VL

	; Initialize the barb get out of my room sound
	LDA #MUS1_TIMEWARNING
	STA Sound_QMusic1

	; Initialize character counter
	LDA #$00
	STA ToadTalk_CPos

	LDA #168
	STA <Objects_X

	LDA #$60	 ; A = $60

	LDY World_Num	 ; Y = World_Num

	CPY #$01
	BNE PRG024_A033	 ; If World_Num <> 1 (World 2), jump to PRG024_A033

	LDA #$20	 ; A = $20

PRG024_A033:
	STA King_Y

	INC Cine_ToadKing ; Cine_ToadKing = 2
	RTS		 ; Return

PRG024_A03A:

	; Keep the Player halted
	;LDA #$02
	;STA Player_HaltTick

	LDA Player_HaltGame
	BNE PRG024_A04A	 ; If gameplay is halted, jump to PRG024_A04A

	JSR King_Animate  ; Do King's animation logic
	JSR King_DoDialog ; Do King's dialog

PRG024_A04A:
	JMP PRG024_A39D	 ; Jump to PRG024_A39D

KingRoom_DisablePlayerInput:
	; Keep the Player halted
	LDA #$02
	STA Player_HaltTick
	LDA <Pad_Holding
	AND #~(PAD_LEFT | PAD_RIGHT | PAD_UP | PAD_DOWN)
	STA <Pad_Holding	; Otherwise, disable all directional inputs
	RTS

King_DoDialog:
	; Load font patterns
	LDA #$5E
	STA PatTable_BankSel+1

	LDA <CineKing_DialogState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TAndK_DrawDiagBox		; 0: Draw the dialog box
	.word TAndK_DoToadText		; 1: Do the text
	.word TAndK_WaitPlayerButtonA	; 2: Wait for Player to push 'A'

	; Patterns that make up the rows of the dialog box
DiagBox_R1:	.byte $94, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $96
DiagBox_R2:	.byte $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $93
DiagBox_R3:	.byte $95, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $97

DiagBox_RowOffs:
	.byte (DiagBox_R1 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1)
	.byte (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R3 - DiagBox_R1)
DiagBox_RowOffs_End

TAndK_DrawDiagBox:
	JSR KingRoom_DisablePlayerInput
	LDA CineKing_Timer 
	BNE PRG024_A119	 ; If CineKing_Timer has not expired, jump to PRG024_A119 (RTS)

	LDA King_Y
	CMP #90
	BLT PRG024_A119	 ; If King is higher than pixel line 90, jump to PRG024_A119 (RTS)

	LDX Graphics_BufCnt	 ; X = buffer count

	; Set current VRAM address 
	LDA ToadTalk_VH
	STA Graphics_Buffer,X
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,X

	; Jump to next video row
	ADD #$20	; 32 bytes to next row
	STA ToadTalk_VL
	BCC PRG024_A0CD
	INC ToadTalk_VH	 ; Apply carry
PRG024_A0CD:

	LDA #(DiagBox_R2 - DiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY ToadTalk_CPos	 ; Y = current dialog box row
	LDA DiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG024_A0DB:
	; Store next pattern in dialog box
	LDA DiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG024_A0DB	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	INC ToadTalk_CPos	 ; Next row

	LDA ToadTalk_CPos
	CMP #(DiagBox_RowOffs_End - DiagBox_RowOffs)
	BLT PRG024_A119	 ; If row count < 8, jump to PRG024_A119

	; Dialog box is complete

	LDA #$00	 ; A = 0 ("The King has been transformed!")

PRG024_A105:
	STA ToadTalk_CPos	 ; Set proper character position

	; Initialize VRAM address for Toad and King Cinematic Dialog Box Text
	LDA #$28
	STA ToadTalk_VH
	LDA #$67
	STA ToadTalk_VL

	; CineKing_Timer = $10
	LDA #$10
	STA CineKing_Timer

	INC <CineKing_DialogState	; CineKing_DialogState = 1

PRG024_A119:
	RTS		 ; Return

	; English: "Oh,it's terrible!" / "The King has been" / "transformed!" / "Please find the" / "Magic Wand so we can" / "change him back"
BadEndingMessage:
KingHelpMsg1:
	;       O    h    ,    i    t    '    s         t    e    r    r    i    b    l    e    !
	;.byte $BE, $D7, $9A, $D8, $CD, $AB, $CC, $FE, $CD, $D4, $CB, $CB, $D8, $D1, $DB, $D4, $EA, $FE, $FE, $FE
	.byte $B2, $CE, $CB, $CC, $D4, $FE, $8C, $DE, $CE, $9A, $8C, $DE, $CE, $FE, $DB, $D8, $CD, $CD, $DB, $D4

	;       T    h    e         K    i    n    g         h    a    s         b    e    e    n
	;.byte $C3, $D7, $D4, $FE, $BA, $D8, $DD, $D6, $FE, $D7, $D0, $CC, $FE, $D1, $D4, $D4, $DD, $FE, $FE, $FE
	.byte $E9, $E9, $E9, $D4, $D7, $9A, $B8, $FE, $DC, $D4, $D0, $DD, $9A, $D3, $D8, $D3, $FE, $8C, $DE, $CE

	;       t    r    a    n    s    f    o    r    m    e    d    !
	;.byte $CD, $CB, $D0, $DD, $CC, $D5, $DE, $CB, $DC, $D4, $D3, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE
	.byte $D5, $D8, $DD, $D3, $FE, $D0, $DB, $DB, $FE, $DC, $8C, $FE, $DC, $D0, $CB, $D1, $DB, $D4, $CC, $EB

	;       P    l    e    a    s    e         f    i    n    d         t    h    e
	;.byte $BF, $DB, $D4, $D0, $CC, $D4, $FE, $D5, $D8, $DD, $D3, $FE, $CD, $D7, $D4, $FE, $FE, $FE, $FE, $FE
	.byte $B8, $AB, $DC, $FE, $D9, $CE, $CC, $CD, $FE, $D0, $DD, $FE, $DE, $DB, $D3, $FE, $DC, $D0, $DD, $FE

	;       M    a    g    i    c         W    a    n    d         s    o         w    e         c    a    n
	;.byte $BC, $D0, $D6, $D8, $D2, $FE, $C6, $D0, $DD, $D3, $FE, $CC, $DE, $FE, $81, $D4, $FE, $D2, $D0, $DD
	.byte $81, $D7, $DE, $FE, $DB, $DE, $CC, $CD, $FE, $DC, $8C, $FE, $DF, $DE, $81, $D4, $CB, $D5, $CE, $DB

	;       c    h    a    n    g    e         h    i    m         b    a    c    k    .
	;.byte $D2, $D7, $D0, $DD, $D6, $D4, $FE, $D7, $D8, $DC, $FE, $D1, $D0, $D2, $DA, $E9, $FE, $FE, $FE, $FE
	.byte $DE, $CB, $E9, $E9, $E9, $CE, $D7, $E9, $E9, $E9, $DC, $D0, $CB, $D1, $DB, $D4, $CC, $E9, $FE, $FE

	; English: "Hurry! Hurry!" / "Get the Magic Wand" / "back from Little" / "Koopa."
KingHelpMsg2:
	;       H    u    r    r    y    !         H    u    r    r    y    !
	;.byte $B7, $CE, $CB, $CB, $8C, $EA, $FE, $B7, $CE, $CB, $CB, $8C, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE
	.byte $B1, $CB, $D8, $DD, $D6, $FE, $DC, $D4, $FE, $D0, $DB, $DB, $FE, $9D, $9E, $FE, $D0, $DD, $D3, $FE

	;       G    e    t         t    h    e         M    a    g    i    c         W    a    n    d
	;.byte $B6, $D4, $CD, $FE, $CD, $D7, $D4, $FE, $BC, $D0, $D6, $D8, $D2, $FE, $C6, $D0, $DD, $D3, $FE, $FE
	.byte $8C, $DE, $CE, $FE, $D2, $D0, $DD, $FE, $DF, $D4, $CD, $FE, $B1, $DE, $FE, $D7, $D4, $CB, $D4, $E9

GoodEndingMessage:
	;Well, I see you've\nfound all my orbs.\nSo nice of you to\nreturn them! I'll\ndefinitely put them\nto good use TO DESTR\ner...thanks.You may\nnow pet the dog.
	.byte $C6, $D4, $DB, $DB, $9A, $FE, $B8, $FE, $CC, $D4, $D4, $FE, $8C, $DE, $CE, $AB, $CF, $D4, $FE, $FE
	.byte $D5, $DE, $CE, $DD, $D3, $FE, $D0, $DB, $DB, $FE, $DC, $8C, $FE, $DE, $CB, $D1, $CC, $E9, $FE, $FE
	.byte $C2, $DE, $FE, $DD, $D8, $D2, $D4, $FE, $DE, $D5, $FE, $8C, $DE, $CE, $FE, $CD, $DE, $FE, $FE, $FE
	.byte $CB, $D4, $CD, $CE, $CB, $DD, $FE, $CD, $D7, $D4, $DC, $EA, $FE, $B8, $AB, $DB, $DB, $FE, $FE, $FE
	.byte $D3, $D4, $D5, $D8, $DD, $D8, $CD, $D4, $DB, $8C, $FE, $DF, $CE, $CD, $FE, $CD, $D7, $D4, $DC, $FE
	.byte $CD, $DE, $FE, $D6, $DE, $DE, $D3, $FE, $CE, $CC, $D4, $FE, $C3, $BE, $FE, $B3, $B4, $C2, $C3, $C1
	.byte $D4, $CB, $E9, $E9, $E9, $CD, $D7, $D0, $DD, $DA, $CC, $E9, $C8, $DE, $CE, $FE, $DC, $D0, $8C, $FE
	.byte $DD, $DE, $81, $FE, $DF, $D4, $CD, $FE, $CD, $D7, $D4, $FE, $D3, $DE, $D6, $E9, $FE, $FE, $FE, $FE

TAndK_DoToadText:
	JSR KingRoom_DisablePlayerInput
	LDA SndCur_Music1
	BNE _TAndK_PostMusic
	LDA SndCur_Music2
	BNE _TAndK_PostMusic
	LDA #MUS2B_BATTLE
	STA Sound_QMusic2
_TAndK_PostMusic:
	LDA CineKing_Timer
	BNE PRG024_A260	 ; If the timer is not expired, jump to PRG024_A260

	LDY ToadTalk_CPos	 ; Y = dialog message character position

	LDA BadEndingMessage,Y	 ; Get next character of message
	LDX Player_Orbs
	CPX #22
	BNE _post_grimm_msg_set
	LDA GoodEndingMessage,Y

_post_grimm_msg_set:
	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	STA Graphics_Buffer+3,Y	 ; Store into buffer

	; Insert one character into graphics buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,Y	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,Y	; run length
	LSR A
	STA Graphics_Buffer+4,Y	; terminator
	TYA
	ADD #$04
	STA Graphics_BufCnt	; count
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,Y	; address low

	INC ToadTalk_CPos	 ; Next character in message
	INC ToadTalk_VL	 ; Next VRAM byte
	AND #$1f	 	; Get current column
	CMP #$1a	 
	BNE PRG024_A25B	 	; If we're not in column 26, jump to PRG024_A25B

	; Line break!

	LDA ToadTalk_VL
	ADC #$0b		; Add enough bytes to get to next row
	STA ToadTalk_VL
	BCC PRG024_A250
	INC ToadTalk_VH	; Apply carry
PRG024_A250:

	CMP #$67	
	BNE PRG024_A25B	 ; If we haven't reached the last character, jump to PRG024_A25B

	INC <CineKing_DialogState		 ; CineKing_DialogState = 2

	LDA #$00
	STA ToadTalk_CPos

PRG024_A25B:
	; Reset tick counter for next character
	LDA #$04
	STA CineKing_Timer

PRG024_A260:
	RTS		 ; Return


TAndK_WaitPlayerButtonA:
	LDA Player_Orbs
	CMP #22
	BNE _bad_ending
_bad_ending:
	JSR KingRoom_DisablePlayerInput
	LDA <Pad_Input
	BPL PRG024_A260				; If Player is not pushing 'A', jump to PRG024_A260 (RTS)

	INC Player_Pet_Dog
	RTS
	;;; [ORANGE] TODO: Logic here:
	;;; Has all orbs?
	;;;    - No, disable input and wait for A press
	;;;    - Yes, do logic to check player X/Y to determine if close enough to dog.
	;;;      - If so, go to pet-the-dog state: freeze player on ground and play petting animation

	LDA <Pad_Input
	BPL PRG024_A282	 ; If Player is not pushing 'A', jump to PRG024_A282 (RTS)

	LDA Map_Objects_IDs
	BEQ PRG024_A27A	 ; If the "HELP!" bubble is gone, jump to PRG024_A27A

	; Level_JctCtl = 3 (switch to airship)
	LDA #$03
	STA Level_JctCtl

	; No more "HELP!" bubble...
	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs

	; Airship is in town now!
	LDA #MAPOBJ_AIRSHIP
	STA Map_Objects_IDs+1

	RTS		 ; Return


PRG024_A27A:
	; Standard exit to map
	LDA #$00
	STA Map_ReturnStatus
	INC Level_ExitToMap

PRG024_A282:
	RTS		 ; Return

	; Sets PatTable_BankSel+5 by world 1-7
King_PatTableByWorld:
	.byte $27

	; Sets King's sprite palette select by world 1-7
King_PalByWorld:
	.byte SPR_PAL2

	; Number of King's patterns (sprites) by world 1-7
King_NumPatsByWorld:
	.byte (King_W1Pat0 - King_W1Pat1)

	; King sprite data offset by world and frame (Left = 0, Right = 1)
King_SprDataOffByWorldAndFrame:
	.byte (King_W1YOff - King_SprDataYOff), (King_W1YOff - King_SprDataYOff)	; World 1

	; Y offset (from King_Y) per King sprite (must be parallel with King_SprDataX)
King_SprDataYOff:
King_W1YOff:	.byte $09, $10, $10, $20, $20

	; X per King sprite (must be parallel with King_SprDataYOff)
King_SprDataX:
King_W1X:	.byte $D7, $B0, $B8, $B0, $B8

King_SprPatOffByWorldAndFrame:
	.byte (King_W1Pat0 - King_SprPats), (King_W1Pat1 - King_SprPats)	; World 1

King_SprPats:
King_W1Pat1:	.byte $E1, $E3, $E5, $E7
King_W1Pat0:	.byte $E1, $E3, $E5, $E7

PRG024_A36C:
	.byte $30, $40, $50, $60

	; Sprites that make up the yelling Toad
KingToad_Sprites:
	.byte $7A, $00, $02, $D0
	.byte $7A, $00, $02, $C8
	.byte $7A, $00, $02, $C0
	.byte $6A, $00, $03, $D0
	.byte $6A, $00, $03, $C8
	.byte $6A, $00, $03, $C0
KingToad_Sprites_End

KingToad_Patterns:
ToadFrame0:	.byte $C1, $C3, $C5, $C7, $C9, $CB
ToadFrame1:	.byte $C1, $C3, $C5, $C7, $C9, $CB
ToadFrame2:	.byte $C1, $C3, $C5, $C7, $C9, $CB

KingToad_PatOffset:
	.byte (ToadFrame0 - KingToad_Patterns), (ToadFrame1 - KingToad_Patterns), (ToadFrame2 - KingToad_Patterns)

PRG024_A39D:
	; Load yelling Toad's graphics
	LDA #$2a
	STA PatTable_BankSel+4

	; Copy in the sprites for yelling Toad
	LDY #(KingToad_Sprites_End - KingToad_Sprites - 1)
PRG024_A3A4:
	LDA KingToad_Sprites,Y
	STA Sprite_RAM+$40,Y

	DEY		 ; Y--
	BPL PRG024_A3A4	 ; While Y >= 0, loop

	LDY Objects_Frame	; Y = yelling Toad's frame
	LDX KingToad_PatOffset,Y ; X = base offset into patterns for this frame

	; Patch the patterns on the yelling Toad for the current frame
	LDY #((KingToad_Sprites_End - KingToad_Sprites - 1) & ~3)
PRG024_A3B5:
	LDA KingToad_Patterns,X
	STA Sprite_RAM+$41,Y

	INX		 ; X++ (index to next patch pattern)

	; Y -= 4 (previous sprite)
	DEY
	DEY
	DEY
	DEY

	BPL PRG024_A3B5	; While Y >= 0, loop

	LDY World_Num	 ; Y = World_Num

	; Set King's pattern table
	LDA King_PatTableByWorld,Y
	STA PatTable_BankSel+5	

	; King's Y -> Temp_Var1
	LDA King_Y
	STA <Temp_Var1

	; King's palette select -> Temp_Var2
	LDA King_PalByWorld,Y
	STA <Temp_Var2

	; King's number of patterns (sprites) -> Temp_Var4 and 5
	LDA King_NumPatsByWorld,Y
	STA <Temp_Var4
	STA <Temp_Var5

	TYA		; A = Y (World_Num)
	ASL A		; A = World_Num * 2
	ORA CineKing_Frame	; OR'd King's frame (0 or 1)
	PHA		; Save value
	TAY		; -> 'Y'

	LDX King_SprDataOffByWorldAndFrame,Y	; X = root index of King Sprite data
	LDY #$60	; Y = $60
PRG024_A3E8:
	; Set King Sprite Y
	LDA <Temp_Var1
	ADD King_SprDataYOff,X
	STA Sprite_RAM,Y

	; Set King Sprite Attributes
	LDA <Temp_Var2
	STA Sprite_RAM+$02,Y

	; Set King Sprite X
	LDA King_SprDataX,X
	STA Sprite_RAM+$03,Y

	INX		 ; X++ (next King sprite data)

	; Y += 4 (Next King sprite)
	INY
	INY
	INY
	INY

	DEC <Temp_Var4	 ; Temp_Var4--
	BPL PRG024_A3E8	 ; While Temp_Var4 >= 0, loop

	PLA		 ; Restore A = (World_Num * 2) | CineKing_Frame
	TAY		 ; -> 'Y'

	; Copy in all the King sprite patterns
	LDX King_SprPatOffByWorldAndFrame,Y	; X = root index of King Sprite patterns
	LDY #$64	 ; Y = $64
PRG024_A40C:
	LDA King_SprPats,X
	STA Sprite_RAM+$01,Y

	INX		 ; X++ (next King Sprite pattern index)

	; Y += 4 (next King Sprite)
	INY
	INY
	INY
	INY

	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG024_A40C	 ; While Temp_Var5 <> 0, loop

	LDY World_Num
	CPY #$05
	BEQ PRG024_A48A	 ; If World_Num = 5 (World 6), jump to PRG024_A48A

	; Not World 6...

	; Just put a stationary crown there
	; [ORANGE] modified to place an empty sprite there
	;LDA #$ab
	;STA Sprite_RAM+$61
	LDA #$F8
	STA Sprite_RAM+$60
	STA Sprite_RAM+$63

	CPY #$06
	BNE PRG024_A439	 ; If World_Num <> 6 (World 7), jump to PRG024_A439

	; World 7 only...

	; Set piranha's body palette to 3
	LDA #SPR_PAL3
	STA Sprite_RAM+$6E
	STA Sprite_RAM+$72

	RTS		 ; Return

PRG024_A439:
	CPY #$01
	BNE PRG024_A4A1	 ; If World_Num <> 1 (World 2), jump to PRG024_A4A1 (RTS)

	; World 2 only...

	; Crown on the floor 
	LDA #$80
	STA Sprite_RAM+$60

	; Temp_Var4 = CineKing_DialogState
	LDA <CineKing_DialogState
	STA <Temp_Var4

	; Temp_Var3 = $10
	LDA #$10
	STA <Temp_Var3

	LDY #$80	 ; Y = $80
PRG024_A44C:
	LDA <Temp_Var4
	BEQ PRG024_A466	 ; If Temp_Var4 (CineKing_DialogState) = 0, jump to PRG024_A466

	LDX #$03	 ; X = 3

	CMP #$00
	BNE PRG024_A45B	 ; Jump (technically always) to PRG024_A45B

	LDA ToadTalk_CPos
	LSR A
	TAX		 ; X = ToadTalk_CPos / 2

PRG024_A45B:
	LDA <Temp_Var3
	CMP #$20
	BLT PRG024_A466	 ; If Temp_Var3 < $20, jump to PRG024_A466

	CMP PRG024_A36C,X
	BLT PRG024_A47E	 ; If Temp_Var3 < PRG024_A36C[X], jump to PRG024_A47E

PRG024_A466:

	; Set web sprite Y
	LDA <Temp_Var3
	STA Sprite_RAM,Y

	; Set web sprite pattern
	LDA #$d7
	STA Sprite_RAM+$01,Y

	; Set web sprite attribute
	LDA <Temp_Var2
	STA Sprite_RAM+$02,Y

	; Set web sprite X
	LDA #$d0
	STA Sprite_RAM+$03,Y

	; Y += 4 (next sprite)
	INY
	INY
	INY
	INY

PRG024_A47E:

	; Temp_Var3 += $10
	LDA <Temp_Var3
	ADD #$10
	STA <Temp_Var3

	CMP <Temp_Var1	
	BLT PRG024_A44C	 ; While Temp_Var3 < Temp_Var1, loop!

	RTS		 ; Return

PRG024_A48A:
	;LDY <CineKing_Frame2

	; Set crown sprite Y
	;LDA <Temp_Var1	; King Sprite Y
	;ADD King_W6Crown_YOff,Y
	;STA Sprite_RAM+$60

	; Set crown sprite pattern
	;LDA King_W6Crown_Pattern,Y
	;STA Sprite_RAM+$61

	; Set crown sprite attributes
	;LDA King_W6Crown_Attr,Y
	;STA Sprite_RAM+$62

PRG024_A4A1:
	;RTS		 ; Return

	; Performs animation logic for the king
King_Animate:
	LDA World_Num
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word King_W1347	; World 1 King (Dog scratching ear)


PRG024_A51A:
	.byte %00100100	; World 1
	.byte %00001000	; World 2
	.byte %00101000	; World 3
	.byte %00101000	; World 4
	.byte %00010000	; World 5
	.byte %00000000	; World 6
	.byte %00010000	; World 7
	
King_W1347:
	LDY World_Num	; Y = World_Num

	LDA <Counter_1
	AND PRG024_A51A,Y ; Mask counter by value from PRG024_A51A
	BEQ PRG024_A52D	 ; If this is the tick to fire on, jump to PRG024_A52D

	LDA #$01	 ; A = 1 (frame)

PRG024_A52D:
	STA CineKing_Frame	 ; Set king frame

	RTS		 ; Return




Debug_DownUp:	.byte 1, -1	; Add 1 or subtract 1 from current world on debug menu

; $A802
	.byte $02, $FF, $00, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GraphicsBuf_Prep_And_WaitVSyn2
;
; This subroutine takes Graphics_Queue and loads and address
; from Video_Upd_Table2 into the Video_Upd_Addr, then waits for
; a VBlank cycle to occur via reading the VBlank_Tick after
; force-setting it to zero.  This gets the system into a state
; where it can actually apply the update!
;
; See also GraphicsBuf_Prep_And_WaitVSync in PRG030
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GraphicsBuf_Prep_And_WaitVSyn2:
	LDA <Graphics_Queue
	ASL A		 	
	TAY		 	; Y = Graphics_Queue << 1

	; Get the address where the video update data is
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	LDA #$01	
	STA <VBlank_TickEn	 ; Enable the VBlank tick
	LDA #$00	 
	STA <VBlank_Tick	 ; Force VBlank_Tick = 0, so we know when a VBlank has occurred

	; Waiting for VBlank...
PRG024_A81C:
	LDA <VBlank_Tick
	BPL PRG024_A81C

	LDA #$00	 
	STA <VBlank_TickEn	 ; Disable the VBlank

	CLI		 ; Enable further masked interrupts
	RTS		 ; Return


IntIRQ_TitleEnding:
	STA MMC3_IRQENABLE

	; Some kind of delay loop?
	LDX #$04	 ; X = 4
PRG024_A82B:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG024_A82B	 ; While X > 0, loop

	LDA PPU_STAT

	LDY #$0b
	LDA #$00
	STY PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

	LDA PPU_VRAM_DATA

	LDA <PPU_CTL1_Copy	
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Stored to the register!

	LDA PPU_STAT

	; H-Scroll locked at 0
	LDA #$00
	STA PPU_SCROLL

	; V-Scroll locked at $EF
	LDA #$ef
	STA PPU_SCROLL

	STA MMC3_IRQDISABLE

	JMP IntIRQ_Finish_NoDis	 ; Jump to IntIRQ_Finish_NoDis

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; Video_Misc_Updates2
;
; This routine is responsible for arbitrary video updates
;
; Loads data as specified from table Video_Upd_Table2 in PRG024 (see Video_Upd_Table in PRG030 for format!)
; Cloned in its entirety in PRG026 (i.e. Video_Misc_Updates)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Video_Misc_Updates2:
	LDY #$00	 	; Start at offset 0
	LDA [Video_Upd_AddrL],Y	; Get next byte from data
	BNE PRG024_A860	 	; If not $00 (terminator), process it @ PRG024_A860
	RTS		 ; Return

PRG024_A860:
	LDX PPU_STAT	 	; Flush video

	STA PPU_VRAM_ADDR	; Store byte into video address high
	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_ADDR	; Store byte into video address low

	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte...

	ASL A		 	; Its uppermost bit dictates whether to use horizontal (1B) or vertical (32B) advancement
	PHA		 	; Save A

	LDA <PPU_CTL1_Copy	; Get PPU_CTL1 settings
	ORA #$04	 	; Set PPU update vertical (each write advances by 32)
	BCS PRG024_A879		; If bit 7 was set, jump to PRG026_B2B2
	AND #$fb		; Otherwise, use horizontal updates! (clears vertical bit)

PRG024_A879:
	STA PPU_CTL1		; Update PPU_CTL1
	STA <PPU_CTL1_Copy	; Update PPU_CTL1_Copy

	PLA		; Restore A

	ASL A		 ; Check next bit...
	BCC PRG024_A885	 ; If not set, jump to PRG026_B2BE
	ORA #$02	 ; Otherwise, remaining value gets bit 1 set (forces skip of first increment)
	INY		 ; Y++ 

PRG024_A885:
	; Restore remainder of byte read (6-bits for value)
	LSR A
	LSR A
	TAX		 ; Keep it in X

	; The following will continuously write bytes from the stream
	; directly into the PPU 'X+1' times
PRG024_A888:
	BCS PRG024_A88B	 ; If carry set, jump to PRG026_B2C4
	INY		 ; Y++

PRG024_A88B:
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_DATA	; Store into PPU
	DEX		 	; X--
	BNE PRG024_A888	 	; While X <> 0, loop! 

	; This advances the current position of the pointer so 'Y' can go
	; back to zero and we begin again...
	INY		 ; Y++
	TYA		 ; A = Y
	ADD <Video_Upd_AddrL
	STA <Video_Upd_AddrL
	LDA <Video_Upd_AddrH
	ADC #$00	 
	STA <Video_Upd_AddrH	; Entire video address value has 'Y' added to it
	JMP Video_Misc_Updates2	; Jump back to start to process next command or terminate!

Title_Obj_InitIdx:	.byte $02, $00, $01, $03, $04, $05	; Indexes into Title_ObjStates, inits to state 1 in this order
Title_ObjInitIdx_Time:	.byte $03, $03, $06, $12, $11, $00	; Timing values to delay the next Title_ObjInitIdx

Do_Title_Screen:	; $A8AF
	JSR Sprite_RAM_Clear		; Clear Sprite RAM Copy
	JSR Reset_PPU_Clear_Nametables

	; Basically just hiding everything
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; Clear the first 245 bytes of RAM
	LDX #$f5	 ; X = 245
PRG024_A8BF:
	LDA #$00	 	; A = $00
	STA <Temp_Var1,X	; Clear this byte
	DEX		 	; X--
	BNE PRG024_A8BF	 	; Loop...


	; Clearing memory used by various title screen objects
	LDX #(Title_ObjFrame - Title_MLAccelCnt + 6)
PRG024_A8C8:
	LDA #$00	 ; A = 0
	STA Title_MLAccelCnt,X	 ; Clear this byte
	DEX		 ; X--
	BPL PRG024_A8C8	 ; Loop while X >= 0...

	; Set Mario and Luigi's lives to 4
	LDA #$04
	STA Player_Lives
	STA Player_Lives+1

	LDA #$ff
	STA <Title_ObjInitIdx	; Title_ObjInitIdx = $FF (Should be 0 - 5, does this have an early increment or something?)

	; Set Mario and Luigi's Y position to 160
	LDA #160
	STA <Title_ObjY
	STA <Title_ObjY+1

	LDA #240
	STA <Title_ObjX		; Set Mario's X coordinate to 240

	LDA #$00
	STA <Title_ObjX+1	; Set Luigi's X coordinate to 0

	; Set Mario and Luigi to "Big" power level
	LDA #$01
	STA <Title_ObjMLPower	
	STA <Title_ObjMLPower+1	

	LDA #$88
	STA Random_Pool		; Seed the randomizer

	LDA #%00101000
	STA PPU_CTL1		; use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Sync with PPU_CTL1_Copy

	JSR Title_Custom_Setup	; [ORANGE] Custom setup stuff (replaced title curtain)

	; Load the palette and checkerboard floor pattern
	LDA #$01	 ; A = 1
	ASL A		 ; A = 2
	TAY		 ; Y = 2 (Palette + Checkerboard floor)
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH
	JSR Video_Misc_Updates2

	; Some kind of hardware thing perhaps
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10	
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$00	
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10	 
	STA PPU_VRAM_ADDR	
	STA PPU_VRAM_ADDR	

	; Wait for V-Blank to end
PRG024_A930:
	LDA PPU_STAT
	AND #$80	
	BNE PRG024_A930	

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA #%00011110
	STA <PPU_CTL2_Copy	; Setup for: No BG or sprite clipping, show BG and sprites

	LDA #00
	STA <Title_Ticker	; Set Title_Ticker = 53 (initial delay prior to curtain raise)

PRG024_A946:
	; Used for VSync
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	LDA <Pad_Input
	AND #PAD_START
	;BEQ PRG024_A955	 ; If Player is NOT pressing Start, jump to PRG024_A955
	NOP
	NOP

	; Player pressed START -- skips rest of intro, if any
	LDA #$06
	STA <Title_State	; Title_State = 6 
	BEQ PRG024_A959	 	; Jump technically never?? to skip title ticker

PRG024_A955: 
	DEC <Title_Ticker	; Decrement title tick counter
	BPL PRG024_A946	 	; If >= 0, loop...

PRG024_A959:
	; Title_Ticker = 0...

	; Used for VSync
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	; There are 6 objects on the title screen that need their states set; if this value hits 6, we're done with that
	LDY <Title_ObjInitIdx	; Y = Title_ObjInitIdx
	CPY #$06	 	
	BGE PRG024_A976	 	; If Title_ObjInitIdx >= 6, jump to PRG024_A976

	; Title_ObjInitIdx < 6... (more objects to go yet)

	; Waiting for event timer to run out
	DEC <Title_ObjInitDly	; Title_ObjInitDly--
	BNE PRG024_A976	 	; If Title_ObjInitDly > 0, jump to PRG024_A976

	; Load next delay for object init
	; Title_ObjInitIdx is 0 to 5
	LDA Title_ObjInitIdx_Time,Y
	STA <Title_ObjInitDly	; Title_ObjInitDly = Title_ObjInitIdx_Time[Title_ObjInitIdx]

	LDA Title_Obj_InitIdx,Y
	TAY		 	; Y = Title_Obj_InitIdx[Title_ObjInitIdx]

	LDA #$01	 	
	STA Title_ObjStates,Y 	; Title_ObjStates[Y] = 1  Set title screen object to state 1

	; Doing next object...
	INC <Title_ObjInitIdx	; Title_ObjInitIdx++

PRG024_A976:
	JSR Title_DoState	; Do whatever this state of the title screen does

	; Title_ResetTrig is the trigger to reset the title screen
	LDA <Title_ResetTrig
	BEQ PRG024_A980	 	; If Title_ResetTrig = 0, jump to PRG024_A980

	JMP Do_Title_Screen	; Reset title screen...

PRG024_A980:
	; Reset trigger is not set...

	LDA <Title_State
	CMP #$05	 
	BNE PRG024_A959	 ; If Title_State <> 5, jump to PRG024_A959

	; When Title_State = 5, we're about to finish and go off to the map!

	; Performs a clearing loop starting from World_Map_Y + $80 ($F5) down and through
	LDX #$80	 ; Clearing $80 bytes
	LDA #$00	 ; Clear value
PRG024_A98A:
	STA <World_Map_Y,X	; Clear this byte
	DEX		 	; X--
	BPL PRG024_A98A	 	; X >= 0, loop!

	RTS		 ; Return


Title_Custom_Setup:
	;;; [ORANGE] Removed title display curtain routine
	LDA #MUS2B_BOSS
	STA Sound_QMusic2

	RTS		 	; Return!


Title_DoState:

	; Clear the queues for Mario/Luigi
	LDA #$00
	STA <Title_ObjMLQueue
	STA <Title_ObjMLQueue+1

	LDA <Title_State	
	JSR DynJump	 	; Dynamically jump based on Title_State...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Title_DoNothing		; 00 - Curtain raise
	.word Title_DoNothing	; 01 - Opening sequence (updates Mario/Luigi's action scripts, the title screen objects, makes the big '3' glow...)
	.word Title_PrepForMenu			; 02 - Prepares some variables before going into 1P/2P menu mode
	.word Title_Do1P2PMenu			; 03 - Runs the 1P/2P menu with the koopas
	.word Title_PrepForWorldMap		; 04 - Final data initialization before going to world map
	.word Title_DoNothing			; 05 - just RTS, bootstraps world map
	.word Title_IntroSkip			; 06 - Skip intro sequence (cleanly jump to 1P/2P menu)
	.word Title_DoNothing			; 07 - Debug menu



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_LoadGraphics
;
; Loads several items from Video_Upd_Table2 in PRG025
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_LoadGraphics:
	LDA #$02
	STA <Title_EventIndex ; Title_EventIndex = $02 (first action taken [load the logo] and continue doing stuff!)

	LDA #$08
	STA <Title_EventGrafX ; Title_EventGrafX = $08 (first item to load from Video_Upd_Table2 in PRG025, up to item $23; see Title_LoadSMB3)

	INC <Title_State ; Next title state...

	LDA #$00	
	STA <Title_ObjMLStop ; Title_ObjMLStop = 0 (releases Mario and Luigi)

	RTS		 ; Return


; This is Mario and Luigi's "action script", which is a simple script to
; dictate their actions on the title screen...
; NOTE: The other objects are mostly autonomous, not scripted.  They respond to
; hardcoded values, timers, or flags from this, but that's it...
;
; Format:
; [DELAY][QUEUE]
;
; Where:
; [DELAY] is normally a tick count until the next event, EXCEPT:
;
;	Mario's script:
;	- $FE to increment Title_State and reset Title_MActScriptPos
;	- $FF to set Title_EventIndex to the value that follows it
;
;	Luigi's script:
;	- $FF is like Mario's $FE, i.e. Title_LActScriptPos = 0, but does not change Title_State
; [QUEUE] is normally a value pumped into Title_MActScriptDirSet (buffer) and Title_ObjMLQueue (acted upon),
; 	except for the prior $FE and $FF values as follows:
;	- For [CMD] $FE (Mario) or $FF (Luigi), it is not used (since Title_MActScriptPos is set to zero)
;	- For [CMD] $FF (Mario), it is the Title_EventIndex value to set

; Mario's action script
Title_MActionScript:
	;.byte $4C, $02, $14, $00, $20, $04, $03, $00, $FF, $03, $BD, $00, $30, $08, $17, $80
	;.byte $05, $00, $23, $82, $02, $00, $25, $80, $20, $00, $35, $01, $05, $10, $04, $01
	;.byte $05, $00, $04, $01, $05, $00, $04, $01, $05, $00, $04, $01, $05, $00, $04, $01
	;.byte $50, $00, $42, $02, $01, $80, $12, $02, $05, $01, $20, $00, $10, $01, $05, $20
	;.byte $20, $01, $05, $40, $C0, $00, $02, $02, $10, $00, $36, $41, $38, $42, $60, $00
	;.byte $60, $51, $FF, $08, $10, $00, $FE, $00

; Luigi's action script
Title_LActionScript:
	;.byte $2C, $01, $50, $80, $F0, $01, $90, $00, $70, $00, $10, $02, $10, $22, $09, $00
	;.byte $15, $02, $34, $00, $02, $42, $90, $00, $65, $01, $F0, $00, $FF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_3Glow
;
; Constantly pushes a palette adjustment into the
; graphics buffer to enable the big '3' on the title
; screen to glow...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_3Glow:
	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_AAA9	 	; If Title_Ticker >= 0, jump to PRG024_AAA9 (RTS)

	LDA #10
	STA <Title_Ticker	; Title_Ticker = 4

	LDY <Title_3GlowIndex		; Y = current 3glow index
	LDA Title_3GlowColors,Y		; Get the cooresponding color
	STA Graphics_Buffer+3		; Put that into the graphics buffer
	;LDA Title_ShadowFade,Y		; Get the cooresponding color
	;STA Graphics_Buffer+4		; Put that into the graphics buffer

	; Address the palette
	LDA #$3f	 
	STA Graphics_Buffer
	LDA #$0e	 
	STA Graphics_Buffer+1

	; 1 byte and terminator
	LDA #$01
	STA Graphics_Buffer+2	
	LDA #$00	 	
	STA Graphics_Buffer+4

	INC <Title_3GlowIndex
	LDA <Title_3GlowIndex
	CMP #$18
	BNE PRG024_AAA9
	LDA #$00
	STA <Title_3GlowIndex
PRG024_AAA9:
	RTS		 ; Return

	; These are the color values used by Title_3Glow for the big '3'
Title_3GlowColors:
	.byte $0a, $1a, $2a, $2a, $1a, $0a, $07, $17, $27, $27, $17, $07, $0b, $1b, $2b, $2b, $1b, $0b, $05, $15, $25, $25, $15, $05
;Title_ShadowFade:
;	.byte $01, $18, $30, $30, $18, $01, $01, $18, $30, $30, $18, $01, $01, $18, $30, $30, $18, $01, $01, $18, $30, $30, $18, $01

Title_IntroSkip:
	LDA #$00
	STA <Vert_Scroll ; Vert_Scroll = 0

	; Disable display a second
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; This will load the title graphics in reverse, $22 to $6
	LDA #$22
	STA <Title_EventGrafX	; Title_EventGrafX = $22 (TitleScreen_Part27)

PRG024_AB04:
	LDA <Title_EventGrafX
	ASL A		 
	TAY		 	; Y = Title_EventGrafX << 1 (2 byte index)

	; Get address, store into [Video_Upd_AddrH][Video_Upd_AddrL]
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL	
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	JSR Video_Misc_Updates2	; Load those graphics!

	DEC <Title_EventGrafX	; Title_EventGrafX--

	LDA <Title_EventGrafX
	CMP #$06	
	BGE PRG024_AB04	 	; If Title_EventGrafX >= 6, loop!

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG + sprites

	LDA #$02	 
	STA <Title_State	; Title_State = 2 (prep for 1P/2P menu)
	RTS		 ; Return


Title_MAS_DoNextEvent:
	LDA #$00	 
	STA <Title_MActScriptDirSet		; Clear Title_MActScriptDirSet 
	STA <Title_ObjMLQueue		; Clear Mario's action queue

	LDY <Title_MActScriptPos	; Get current position in action script
	LDA Title_MActionScript,Y	; Get byte from action script

	CMP #$ff	 
	BEQ Title_MAS_CmdFF	 	; If equal to $FF (set Title_EventIndex), jump to Title_MAS_CmdFF

	CMP #$fe	 
	BEQ Title_MAS_CmdFE	 	; If equal to $FE, jump to Title_MAS_CmdFE

	; Not $FF or $FE...

	; Otherwise, just a tick delay
	STA <Title_MActScriptDelay	; Store into Title_MActScriptDelay
	INY		 	; Y++

	LDA Title_MActionScript,Y	; Get next byte
	STA <Title_MActScriptDirSet		; Store into Title_MActScriptDirSet
	STA <Title_ObjMLQueue		; ... and into the Queue

	; Two bytes read, so Title_MActScriptPos += 2
	INC <Title_MActScriptPos
	INC <Title_MActScriptPos
	RTS		 		; Return...!

Title_MAS_CmdFF:
	; Action script command $FF (set Title_EventIndex)...

	INY		 
	LDA Title_MActionScript,Y	 ; Get next byte
	STA <Title_EventIndex		 ; Store this into Title_EventIndex

	; Title_MActScriptPos += 2
	INC <Title_MActScriptPos
	INC <Title_MActScriptPos

	LDA #$00
	STA <Title_MActScriptDelay	; Title_MActScriptPos = 0

	RTS		 ; Return

Title_MAS_CmdFE:
	; Action script command $FE (increment Title_State, reset Title_MActScriptPos)...

	INC <Title_State		; Next title state...

	LDA #$00
	STA <Title_MActScriptPos	; Set Title_MActScriptPos = 0

	RTS		 ; Return


Title_LAS_DoNextEvent:
	LDA #$00
	STA <Title_LActScriptDirSet		; Clear Title_LActScriptDirSet 
	STA <Title_ObjMLQueue+1		; Clear Luigi's action queue

	LDY <Title_LActScriptPos	; Get current position in action script
	LDA Title_LActionScript,Y	; Get byte from action script

	CMP #$ff
	BEQ Title_LAS_CmdFF		; If equal to $FF (set Title_EventIndex), jump to Title_LAS_CmdFF

	
	; Otherwise, just a tick delay
	STA <Title_LActScriptDelay	; Store into Title_LActScriptDelay
	INY		 		; Y++

	LDA Title_LActionScript,Y	; Get next byte
	STA <Title_LActScriptDirSet		; Store into Title_LActScriptDirSet
	STA <Title_ObjMLQueue+1		; ... and into the Queue

	; Two bytes read, so Title_LActScriptPos += 2
	INC <Title_LActScriptPos
	INC <Title_LActScriptPos
	RTS		 		; Return...!


Title_LAS_CmdFF:

	; Title_LActScriptPos = 0
	LDA #$00
	STA <Title_LActScriptPos

	RTS		 ; Return

	
Title_DoEvent:
	LDA <Title_EventIndex	; Get Title_EventIndex
	JSR DynJump	 	; Dynamically jump based on the value of Title_EventIndex...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Title_DoNothing		; 00 - Do nothing
	.word Title_DoNothing		; 01 - Do nothing (never used I don't think!)
	.word Title_LoadSMB3		; 02 - Load title screen into the nametable
	.word Title_DoNothing;Title_Drop		; 03 - "Drops" the logo onto the screen
	.word Title_DoNothing;Title_LogoShakeUp		; 04 - Logo shake up
	.word Title_DoNothing;Title_LogoShakeDown	; 05 - Logo shake down, and check if we're done doing that
	.word Title_DoNothing;Title_InitObjects		; 06 - Prepare all title screen objects
	.word Title_PalFadeIn		; 07 - Palette fade in
	.word Title_DoNothing		; 08 - Adds the 1P/2P select menu to the title screen
	.word Title_DoNothing		; 09 - Do nothing, we're done!
	
Title_DoNothing:
	RTS		 

; Title_LoadSMB3
;
; This loads the title screen, specifically items $08 thru $23 of Video_Upd_Table2
; The title screen is too complex to be loaded in one shot, so it's done over
; several frames, in pieces
Title_LoadSMB3:

	; Queue next item to load
	LDA <Title_EventGrafX
	STA Graphics_Queue	

	; Increment Title_EventGrafX
	INC <Title_EventGrafX	

	
	LDA <Title_EventGrafX	
	CMP #$23
	BNE PRG024_ABAC	 ; If not at item $23 yet, keep going...

	; We're done, stop doing background event!
	LDA #$00	 
	STA <Title_EventIndex

PRG024_ABAC:
	RTS		 ; Return


; Title_Drop
;
; The logo comes falling down...
Title_Drop:
	LDY #$04

	; Basically drops logo 4 pixels at a time, with a precise safety catch!
PRG024_ABAF:
	DEC <Vert_Scroll
	LDA <Vert_Scroll
	BEQ PRG024_ABB9	 ; If Vert_Scroll = 0, jump to PRG024_ABB9
	DEY		 ; Y--
	BPL PRG024_ABAF	 ; If Y >= 0, loop!

	RTS		 ; Return

PRG024_ABB9:
	; The logo has landed!

	LDA #$10	 
	STA <Title_Ticker	; Title_Ticker = $10

	INC <Title_EventIndex	; Perform next event...
	RTS		 	; Return...

; Title_LogoShakeUp
;
; Shake the logo up, go to the next state
Title_LogoShakeUp:

	; Subtract 2 from Vert_Scroll
	LDA <Vert_Scroll
	SUB #$02	
	STA <Vert_Scroll

	INC <Title_EventIndex	; Shake down next
	RTS			; Return!

; Title_LogoShakeDown
;
; Shake the logo down, go to the previous state, 
; or see if we're done yet...
Title_LogoShakeDown:

	; Add 2 to Vert_Scroll
	LDA <Vert_Scroll
	ADD #$02	
	STA <Vert_Scroll

	DEC <Title_EventIndex	; Shake up next

	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_ABE3	 	; If we're not done yet, jump to PRG024_ABE3 (no change, shake away)

	; Shaking is complete!
	INC <Title_EventIndex
	INC <Title_EventIndex	; Title_EventIndex += 2 (to make up for the decrement above), moving on to object init...

	LDA #$03	 	
	STA <Title_EventGrafX	; Title_EventGrafX = 3 (to fade in the palette, starting with Video_Upd_Table2 item $03)

	LDA #$02	 
	STA <Title_Ticker	; Title_Ticker = 2

PRG024_ABE3:
	RTS		 ; Return


; Title_InitObjects
;
; Queues the title screen objects to prepare themselves for appearing
Title_InitObjects:
	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_ABF6	 	; If Title_Ticker >= 0, do nothing yet...

	; Preparing to initialize objects that fall in the beginning...
	LDA #$00
	STA <Title_ObjInitIdx	; Title_ObjInitIdx = 0

	LDA #$01
	STA <Title_ObjInitDly	; Title_ObjInitDly = 1

	INC <Title_EventIndex	; On to the next event (the palette fade-in)

	LDA #$16
	STA <Title_Ticker	; Title_Ticker = 16

PRG024_ABF6:
	RTS		 	; Return


; Title_PalFadeIn
;
; Loads palette colors to produce a "fade in" effect, 
; specifically items $03 thru $06 of Video_Upd_Table2
Title_PalFadeIn:
	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_AC0F	 	; If Title_Ticker >= 0, do nothing yet...

	LDA #$04
	STA <Title_Ticker	; Title_Ticker = 4

	LDA <Title_EventGrafX	
	STA <Graphics_Queue	; Graphics_Queue = Title_EventGrafX
	CMP #$06	 
	BNE PRG024_AC10	 	; If not at item $06 yet, keep going...

	; Done with the fade in!
	LDA #$00	
	STA <Title_EventIndex	; Stop doing anything

	LDA #$01	 	
	STA <Title_3GlowFlag	; Title_3GlowFlag = 1

PRG024_AC0F:
	RTS			; Return

PRG024_AC10:
	INC <Title_EventGrafX	; Next palette fade
	RTS			; Return 


; Title_DrawMenu
;
; Loads in the tiles for the 1/2 PLAYER GAME and Nintendo copyright
Title_DrawMenu:
	LDA #$07
	STA <Graphics_Queue
	INC <Title_EventIndex	; Do next thing (which is actually nothing; on purpose??)
	RTS		 	; Return...

Title_PrepForMenu:

	; Clear objects 1-4 states
	LDA #$00
	STA <Title_ObjStates+1
	STA <Title_ObjStates+2	
	STA <Title_ObjStates+3	
	STA <Title_ObjStates+4	

	; Set object 0's state to 1 (this is the leader koopa, he starts first, brings in the next)
	LDA #$01
	STA <Title_ObjStates

	; This is the counter for when to reset the title sequence
	LDA #20
	STA <Title_ResetCnt ; Title_ResetCnt = 20

	; This is the "fine" part of the reset count; when it goes to zero, it decrements Title_ResetCnt
	LDA #60
	STA <Title_ResetCnt2 ; Title_ResetCnt2 = 60

	INC <Title_State ; Next title state...
	RTS		 ; Return

Title_Menu_1P2PCursorY:
	.byte 151, 167	 ; Y position for the 1P/2P select cursor

Title_Do1P2PMenu:
	LDA <Controller2
	AND #(PAD_A | PAD_B)
	CMP #(PAD_A | PAD_B)	
	BNE PRG024_AC42	 ; If Player 2 is not holding A+B, jump to PRG024_AC42

	; NOTE: This probably WAS the debug menu activation...
	NOP
	NOP
	NOP
	NOP
	NOP

PRG024_AC42:
	; Title_ResetCnt and Title_ResetCnt2 gang together to form a large countdown timer

	DEC <Title_ResetCnt2	; Title_ResetCnt2--
	BNE PRG024_AC52	 	; If <> 0, jump to PRG024_AC52

	LDA #96
	STA <Title_ResetCnt2 	; Title_ResetCnt2 = 96

	DEC <Title_ResetCnt	; Title_ResetCnt--
	BNE PRG024_AC52	 	; If <> 0, jump to PRG024_AC52

	; Title_ResetCnt and Title_ResetCnt2 have reached zero!
	; Trigger the reset!
	;LDA #$ff
	;STA <Title_ResetTrig	; Title_ResetTrig = $ff

PRG024_AC52:
	;JSR Title_Menu_UpdateKoopas	 ; Update and draw koopas

	;LDA <Pad_Input		 
	;AND #PAD_SELECT
	;BEQ PRG024_AC6B	 	; If Player is not pressing SELECT, jump to PRG024_AC6B

	;LDA #SND_MAPPATHMOVE	 
	;STA Sound_QMap	 	; "Path move" sound (in this case, the "bleep" for the menu)

	; Basically makes sure that the value of Total_Players is 0 or 1 
	;INC Total_Players
	;LDA Total_Players
	;AND #$01	 
	;STA Total_Players

PRG024_AC6B:
	;LDY Total_Players	 ; Y = Total_Players (0 or 1)
	;LDA Title_Menu_1P2PCursorY,Y	 ; Get proper Y value for where cursor is at
	;STA Sprite_RAM+$F0	 ; Store into sprite

	;LDA #$df	 
	;STA Sprite_RAM+$F1	 ; Store pattern value into sprite

	;LDA #$00	 
	;STA Sprite_RAM+$F2	 ; Store attribute value into sprite

	;LDA #72
	;STA Sprite_RAM+$F3	 ; Store X value into sprite

	JSR Title_3Glow	 	; Keep the big '3' glowing!

	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG024_ACBA	 	; If Player is not pressing START, jump to PRG024_ACBA (RTS)

	LDA <Pad_Holding
	AND #PAD_SELECT		; If player is holding select during start press, don't display user messages
	BEQ	_post_skip_usermsg
	LDX #(UserMsgPtr_LEnd-UserMsgPtr_L-1)
_clear_usermsg_loop:
	INC UserMsg_Completions,X
	DEX
	BGS _clear_usermsg_loop

_post_skip_usermsg:

	;LDA #SND_LEVELCOIN
	;STA Sound_QLevel1	; Play coin sound (in this case, selected and begin!)
	LDA #MUS2A_WORLD2
	STA Sound_QMusic2

	LDA Sprite_RAM+$F0	; Get Y value of title screen cursor sprite
	STA <Title_EventGrafX	; Reuse as a temp...

PRG024_AC96:
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	INC <Title_ResetCnt	; Title_ResetCnt++

	LDY #$f8	 	; Y = $f8 (hide title screen cursor)

	LDA <Title_ResetCnt
	AND #$18	 
	BEQ PRG024_ACA5	 ; Periodically jump to PRG024_ACA5

	LDY <Title_EventGrafX	; Y = reappear title screen cursor

PRG024_ACA5:
	STY Sprite_RAM+$F0	 ; Set it!

	JSR Title_3Glow	 		; Make the big '3' glow!

	;LDA SndCur_Level1
	LDA SndCur_Music2
	BNE PRG024_AC96	 ; If the "gling" sound has not ended, loop!

	INC <Title_State ; Title_State++

	; World_Num = 0 (World 1)
	LDA #$00
	STA World_Num

	; Debug_Flag = 0 (no debug mode)
	STA Debug_Flag

PRG024_ACBA:
	RTS		 ; Return

Title_PrepForWorldMap:
	LDA #$00
	STA World_Map_Power	 ; Mario starts as small on world map
	STA World_Map_Power+1	 ; Luigi starts as small on world map
	INC Total_Players	 ; Total_Players should be 1/2, not 0/1
	INC <Title_State	 ; Next title state...
	RTS		 ; Return


Rescue_Princess:
	; NOTE: Debug menu jump to princess rescue jumps here

	; Princess housing block graphics
	LDA #$5c
	STA PatTable_BankSel

	; Princess housing background graphics
	LDA #$5e
	STA PatTable_BankSel+1

	JSR Reset_PPU_Clear_Nametables

	; Disable display
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; Disable raster effects
	LDA #$80
	STA Raster_Effect

	; Clears RAM $00-$F5
	LDX #$f5	 ; X = $F5
PRG024_B876:
	LDA #$00
	STA <Temp_Var1,X

	DEX		 ; X--
	BNE PRG024_B876	 ; While X <> 0, loop!

	; Scroll at lowest point
	LDA #$ef
	STA <Vert_Scroll

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	; Entry $55 of Video_Upd_Table2
	LDA #$55
	ASL A
	TAY

	; Load base address of graphics
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL	
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	JSR Video_Misc_Updates2	; Load those graphics!

	LDA #%10101000	; In addition to anything else specified by PPU_CTL1_Mod, Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

PRG024_B8A0:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; VSync

	JSR Ending_ChamberScene	 ; Do the Princess Chamber scene, up through the Fade Out

	LDA <Ending_State
	CMP #$07
	BNE PRG024_B8A0	 ; If Princess Chamber scene is still going on, loop!

	JMP Ending_Credits	 ; Jump to credits


	; Quick and dirty sprite RAM "clear" function (pushes the Y component out of visible range)
PRG024_SpriteClear:
	LDY #$1c
	LDA #$f8

PRG024_AF48:
	STA Sprite_RAM,Y
	STA Sprite_RAM+$20,Y
	STA Sprite_RAM+$40,Y
	STA Sprite_RAM+$60,Y
	STA Sprite_RAM+$80,Y
	STA Sprite_RAM+$A0,Y
	STA Sprite_RAM+$C0,Y
	STA Sprite_RAM+$E0,Y
	DEY	
	DEY	
	DEY	
	DEY	
	BPL PRG024_AF48

	RTS		 ; Return


Ending_ChamberScene:
	JSR PRG024_SpriteClear	; Clear sprites

	LDA #$10	
	STA <Title_ObjMLSprRAMOff	; Mario's sprite RAM starts at Sprite_RAM + $10

	LDA #$28	
	STA <Title_ObjMLSprRAMOff+1	; Princess's sprite RAM starts at Sprite_RAM + $28

	LDX #$02	 ; X = 2
PRG024_B8BC:
	LDA <Ending_Timer,X
	BEQ PRG024_B8C2		; If this ending timer = 0, jump to PRG024_B8C2

	DEC <Ending_Timer,X	; Otherwise, decrement it

PRG024_B8C2:
	DEX		 ; X--
	BPL PRG024_B8BC	 ; While X >= 0, loop

	JSR Ending_DoChamberScene	 ; Perform actions for the Princess's Chamber

	; Title_CurMLIndex = 0
	LDX #$00
	STX <Title_CurMLIndex

	;JSR Title_DrawMarioLuigi	 ; Draws Mario officially, but may be modified after this to Luigi

	LDA Player_Current
	BEQ PRG024_B8E6	 ; If Player is Mario, jump to PRG024_B8E6

	; Luigi only...

	; This is meant to colorize the Player as Luigi, but I think the loop condition is wrong
	; Seems to work anyway.  Sort of a Schroedinbug without the fact that it will stop working
	; just because I pointed it out...
	LDY #$24	 ; Y = $24
PRG024_B8D6:
	; Use the Luigi palette
	LDA Sprite_RAM+$02,Y
	ORA #SPR_PAL2
	STA Sprite_RAM+$02,Y

	; Y -= 4 (previous sprite)
	DEY
	DEY
	DEY
	DEY

	CMP <Title_ObjMLSprRAMOff ; I think this is a mistake!  Will compare to the attribute value!
	BPL PRG024_B8D6	 ; While ??, loop

PRG024_B8E6:

	; Title_CurMLIndex = 1
	INX		 ; X = 1
	STX <Title_CurMLIndex

	;JSR Title_DrawMarioLuigi	 ; Actually draws the Princess

	RTS		 ; Return

Ending_DoChamberScene:
	LDA <Ending_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Ending_Init		; 0: Prepare the Princess chamber scene
	.word Ending_FadeIn		; 1: Fade in
	.word Ending_MarioAppears	; 2: Mario appears, music starts
	.word Ending_LightsOn		; 3: Lights come on, Princess stands up
	.word Ending_WalkToCenter	; 4: Mario and Princess walk to the center
	.word Ending_PrincessSpeech	; 5: Princess's departing message
	.word Ending_FadeOut		; 6: Fade out

Ending_Init:
	; Set Mario's X
	LDA #32
	STA <Title_ObjX

	; Set Princess's X
	LDA #200
	STA <Title_ObjX+1

	; Set both Y = 160
	LDA #160
	STA <Title_ObjY
	STA <Title_ObjY+1

	; Mario standing
	LDA #$18
	STA <Title_ObjMLSprite

	; Princess sobbing
	LDA #$19
	STA <Title_ObjMLSprite+1

	; Mario turned to face, Princess turned away
	LDA #SPR_HFLIP
	STA <Title_ObjMLFlags
	STA <Title_ObjMLFlags+1

	; Super Mario
	LDA #$01
	STA <Title_ObjMLPower

	; Set first ending timer to $0F
	LDA #$0f
	STA <Ending_Timer

	INC <Ending_State	; Ending_State = 1

	; Initialize the princess speech dialog box

	; EndText_CPos = 0
	LDA #$00
	STA <EndText_CPos

	; EndText_VH = $29
	LDA #$29
	STA <EndText_VH

	; EndText_VL = $48
	LDA #$48
	STA <EndText_VL

	RTS		 ; Return

Ending_FadeIn:
	LDA <Ending_Timer
	BNE PRG024_B93D	 ; If the first ending timer has not expired, jump to PRG024_B93D

	INC <Ending_State	 ; Ending_State = 2

	; Set first ending timer to $30
	LDY #$30
	STY <Ending_Timer

PRG024_B93D:


	; Ending timer was init'ed to $F (15) so ...
	LSR A
	LSR A		; Ending timer / 4
	ADD #$56	; ... run command scripts $59, $58, $57, $56 (the "fade in" effect)

	STA Graphics_Queue	 ; Execute appropriate scripe

	RTS		 ; Return

Ending_MarioAppears:
	LDA <Ending_Timer
	CMP #$01
	BNE PRG024_B959	 ; If ending timer does not have one tick left, jump to PRG024_B959

	; Mario standing there
	LDA #$02
	STA <Title_ObjMLSprite

	; Set ending timer 2 = $80
	LDA #$80
	STA <Ending_Timer+1

	; Play finale music
	LDA #MUS2A_ENDING
	STA Sound_QMusic2

PRG024_B959:
	LDA <Ending_Timer+1
	CMP #$01
	BNE PRG024_B965	 ; If second ending timer does not have one tick left, jump to PRG024_B965

	; Set first ending timer = $13
	LDA #$13
	STA <Ending_Timer

	INC <Ending_State ; Ending_State = 3

PRG024_B965:
	RTS		 ; Return

	; The "lights on" effect palette levels
Ending_LightsOnPalSet:
	.byte $0F, $35, $30, $3B
	.byte $0F, $23, $35, $3B
	.byte $0F, $11, $3C, $3B
	.byte $0F, $1C, $2C, $3B
	.byte $0F, $0C, $1C, $3B

Ending_LightsOn:
	LDA <Ending_Timer
	BEQ PRG024_B9BB	 ; If ending timer has expired, jump to PRG024_B9BB

	; Second ending timer = $30
	LDY #$30
	STY <Ending_Timer+1

	AND #%00001100
	TAY		 ; Y = 0, 4, 8, 12 (Ending_LightsOnPalSet level offset)

	LDX Graphics_BufCnt	 ; X = current graphics buffer count
	TXA
	ADD #$07
	STA Graphics_BufCnt	; Make room for 7 bytes

	; VRAM High/Low (for palette)
	LDA #$3f
	STA Graphics_Buffer,X
	LDA #$04
	STA Graphics_Buffer+1,X

	; Run length of 4
	LDA #$04
	STA Graphics_Buffer+2,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+7,X

	; The four palette colors for the "lights on" effect
	LDA Ending_LightsOnPalSet,Y
	STA Graphics_Buffer+3,X
	LDA Ending_LightsOnPalSet+1,Y
	STA Graphics_Buffer+4,X
	LDA Ending_LightsOnPalSet+2,Y
	STA Graphics_Buffer+5,X
	LDA Ending_LightsOnPalSet+3,Y
	STA Graphics_Buffer+6,X

PRG024_B9BB:
	LDA <Ending_Timer+1
	BNE PRG024_B9C9	 ; If second ending timer has not expired, jump to PRG024_B9C9 (RTS)

	INC <Ending_State	 ; Ending_State = 4

	; First ending timer = $80
	LDA #$80
	STA <Ending_Timer

	; Princess stands up
	LDA #$1a
	STA <Title_ObjMLSprite+1

PRG024_B9C9:
	RTS		 ; Return


Ending_WalkToCenter:
	LDA <Ending_Timer
	BEQ PRG024_B9D7	 ; If first ending timer has not expired, jump to PRG024_B9D7

	CMP #$60
	BGE PRG024_B9D6	 ; If ending timer >= $60, jump to PRG024_B9D6 (RTS)

	; Princess turns around
	LDA #$00
	STA <Title_ObjMLFlags+1

PRG024_B9D6:
	RTS		 ; Return

PRG024_B9D7:
	LDA <Title_ObjX
	CMP #104
	BLT PRG024_B9EC	 ; If Mario's X < 104, jump to PRG024_B9EC

	; Mario stands
	LDA #$02
	STA <Title_ObjMLSprite

	; Princess stands
	LDA #$1a
	STA <Title_ObjMLSprite+1

	INC <Ending_State	; Ending_State = 5

	; First Ending Timer = $B0
	LDA #$b0
	STA <Ending_Timer

	RTS		 ; Return

PRG024_B9EC:

	; Second ending timer = $50
	LDA #$50
	STA <Ending_Timer+1

	; Mario steps to the right
	INC <Title_ObjX

	; Princess steps to the left
	DEC <Title_ObjX+1

	LDA <Counter_1
	AND #%00001100
	LSR A
	LSR A
	TAY	; Y = 0 to 3

	; Set Mario's walk frame
	;LDA Title_ObjMLWalkSprite+4,Y
	STA <Title_ObjMLSprite	

	; Set Princess's walk frame
	;LDA Title_ObjMLWalkSprite+12,Y
	STA <Title_ObjMLSprite+1

	RTS		 ; Return


Ending_PrincessSpeech:
	LDA <Ending_Timer
	BNE PRG024_BA0D	 ; If timer not expired, jump to PRG024_BA0D (RTS)

	JMP PRG024_BA2B	 ; Otherwise, jump to PRG024_BA2B

PRG024_BA0D:
	RTS		 ; Return


Ending_FadeOut:
	LDA <Ending_Timer
	BNE PRG024_BA19	 ; If first ending timer has not expired, jump to PRG024_BA19

	LDA <Ending_Timer+1
	BNE PRG024_BA18	 ; If second ending timer has not expired, jump to PRG024_BA18 (RTS)

	INC <Ending_State ; Ending_State = 7

PRG024_BA18:
	RTS		 ; Return

PRG024_BA19:

	; Ending timer was init'ed to $F (15) so ...
	LSR A
	LSR A		; Ending timer / 4
	STA <Temp_Var1	 ; Temp_Var1 = 0 to 3

	; Execute $5A, $59, $58, $57 (fade out)
	LDA #$5a
	SUB <Temp_Var1
	STA Graphics_Queue

	; Second ending timer = $10
	LDA #$10
	STA Ending_Timer+1

	RTS		 ; Return

PRG024_BA2B:
	LDA <EndText_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word EndText_DrawDiagBox	; 0: Draw the dialog box
	.word EndText_DoPrincessText	; 1: Do the text
	.word EndText_Wait		; 2: Waits for timer to expire, then advances Ending_State


PDiagBox_R1:	.byte $94, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $96
PDiagBox_R2:	.byte $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $93
PDiagBox_R3:	.byte $95, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $97

PDiagBox_RowOffs:
	.byte (PDiagBox_R1 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1)
	.byte (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R3 - PDiagBox_R1)
PDiagBox_RowOffs_End


EndText_DrawDiagBox:

	LDX Graphics_BufCnt	 ; X = buffer count

	; Set current VRAM address 
	LDA <EndText_VH
	STA Graphics_Buffer,X
	LDA <EndText_VL	
	STA Graphics_Buffer+1,X

	ADD #$20	; 32 bytes to next row
	STA <EndText_VL
	BCC PRG024_BA87
	INC <EndText_VH	 ; Apply carry
PRG024_BA87:
	LDA #(PDiagBox_R2 - PDiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY <EndText_CPos	 ; Y = current dialog box row
	LDA PDiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG024_BA94:
	; Store next pattern in dialog box
	LDA PDiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG024_BA94	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	INC <EndText_CPos	 ; Next row

	LDA <EndText_CPos
	CMP #(PDiagBox_RowOffs_End - PDiagBox_RowOffs)
	BLT PRG024_BAC8	 ; If rows to go, jump to PRG024_BAC8 (RTS)

	LDY #$00	 ; Y = 0

	; This basically just amounts to a zero; kind of strange?
	LDA PRG024_BB23,Y
	STA <EndText_CPos

	; EndText_VH = $92
	LDA #$29
	STA <EndText_VH

	; EndText_VL = $69
	LDA #$69
	STA <EndText_VL

	; EndText_Timer = $10
	LDA #$10
	STA <EndText_Timer

	INC <EndText_State	 ; EndText_State = 1

PRG024_BAC8:
	RTS		 ; Return

	; English: "Thank you. But" / "our Princess is" / "in another" / "castle!...Just" / "kidding! Ha ha" / "ha! Bye bye."
EndText:

	;       T    h    a    n    k         y    o    u    .         B    u    t
	.byte $C3, $D7, $D0, $DD, $DA, $FE, $8C, $DE, $CE, $E9, $FE, $B1, $CE, $CD, $FE

	;       o    u    r         P    r    i    n    c    e    s    s         i    s    
	.byte $DE, $CE, $CB, $FE, $BF, $CB, $D8, $DD, $D2, $D4, $CC, $CC, $FE, $D8, $CC

	;       i    n         a    n    o    t    h    e    r    
	.byte $D8, $DD, $FE, $D0, $DD, $DE, $CD, $D7, $D4, $CB, $FE, $FE, $FE, $FE, $FE

	;       c    a    s    t    l    e    !    .    .    .    J    u    s    t
	.byte $D2, $D0, $CC, $CD, $DB, $D4, $EA, $E9, $E9, $E9, $B9, $CE, $CC, $CD, $FE

	;       k    i    d    d    i    n    g    !         H    a         h    a    
	.byte $DA, $D8, $D3, $D3, $D8, $DD, $D6, $EA, $FE, $B7, $D0, $FE, $D7, $D0, $FE

	;       h    a    !         B    y    e         b    y    e    .
	.byte $D7, $D0, $EA, $FE, $B1, $8C, $D4, $FE, $D1, $8C, $D4, $E9, $FE, $FE, $FE

PRG024_BB23:
	; Terminator
	.byte $00

EndText_DoPrincessText:
	LDA <EndText_Timer
	BNE PRG024_BB70	 ; If the timer is not expired, jump to PRG024_BB70 (RTS)

	LDX Graphics_BufCnt	 ; X = current graphics buffer count

	LDY <EndText_CPos	 ; Y = dialog message character position

	; Insert one character into graphics buffer
	LDA <EndText_VH
	STA Graphics_Buffer,X	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,X	; run length
	LDA EndText,Y
	STA Graphics_Buffer+3,X	 ; Next character from Princess speech
	LDA #$00
	STA Graphics_Buffer+4,X	; terminator

	; Update Graphics_BufCnt
	TXA
	ADD #$04
	STA Graphics_BufCnt

	; VRAM low address
	LDA <EndText_VL
	STA Graphics_Buffer+1,X

	INC <EndText_CPos	; Next character in message
	INC <EndText_VL	 	; Next VRAM byte

	AND #$1f	 	; Get current column
	CMP #$17
	BNE PRG024_BB6C	 	; If we're not in column 23, jump to PRG024_BB6C

	; Line break!

	LDA <EndText_VL	
	ADC #$10		; Add enough bytes to get to next row
	STA <EndText_VL	
	BCC PRG024_BB62
	INC <EndText_VH		; Apply carry
PRG024_BB62:

	CMP #$29
	BNE PRG024_BB6C	 ; If we haven't reached the last character, jump to PRG024_BB6C

	INC <EndText_State	 ; EndText_State = 2

	; Second ending timer = $4A
	LDA #$4a
	STA <Ending_Timer+1

PRG024_BB6C:

	; First ending timer = $0B
	LDA #$0b
	STA <Ending_Timer

PRG024_BB70:
	RTS		 ; Return


EndText_Wait:
	LDA <Ending_Timer+1
	BNE PRG024_BB7B	 ; If second ending timer has not expired, jump to PRG024_BB7B (RTS)

	; First ending timer = $0F
	LDA #$0f
	STA <Ending_Timer

	INC <Ending_State	 ; Ending_State = 6

PRG024_BB7B:
	RTS		 ; Return

Ending_Credits:
	; Debug menu credits jump here

	; Curtain and floor top
	LDA #$7c
	STA PatTable_BankSel

	; Rest of floor
	LDA #$76
	STA PatTable_BankSel+1

	; Disable display
	LDA #$00
	STA PPU_CTL2

	; Clear everything
	JSR Sprite_RAM_Clear
	JSR Reset_PPU_Clear_Nametables

	; Stop Update_Select activity temporarily
	LDA #$01
	STA UpdSel_Disable

	; Raster_Effect = $20 (Title/Ending style)
	LDA #$20
	STA Raster_Effect

	; Clears a lot of page 0 RAM
	LDX #$f4	 ; X = $F4
PRG024_BB9D:
	LDA #$00
	STA <Temp_Var1,X

PRG024_BBA1:
	DEX		 ; X--

	; Range between $6B-$75 is not cleared ... mainly protecting sound engine I think

	CPX #Music_Base_L
	BLT PRG024_BBAA	 ; If X < Music_Base_L, jump to PRG024_BBAA

	CPX #World_Map_Y
	BLT PRG024_BBA1	 ; If X < World_Map_Y, jump to PRG024_BBA1

PRG024_BBAA:
	CPX #-1
	BNE PRG024_BB9D	 ; While X >= 0, loop!

	; This clears some of the title screen area memory
	LDX #$15	 ; X = $15
PRG024_BBB0:
	LDA #$00
	STA Title_MLAccelCnt,X

	DEX		 ; X--
	BPL PRG024_BBB0	 ; While X >= 0, loop

	;;;JSR Title_Display_Curtain	; Put up the curtain!

	; Push in the Checkerboard floor
	;LDA #$23
	;ASL A
	;TAY
	;LDA Video_Upd_Table2,Y
	;STA <Video_Upd_AddrL
	;LDA Video_Upd_Table2+1,Y
	;STA <Video_Upd_AddrH
	;JSR Video_Misc_Updates2

	; Set scroll at lowest point (technically, curtain fully raised)
	LDA #$ef
	STA <Vert_Scroll

	; Clip sprites/BG, show sprites/BG, and enable intensity
	LDA #%00011110
	STA <PPU_CTL2_Copy

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Curtain extension
	LDA #$24
	STA Graphics_Queue

	JSR GraphicsBuf_Prep_And_WaitVSyn2


	; This will push graphics command sets $5C, $5D, and $5E

	; Title_EventGrafX = $5C
	LDA #$5c
	STA <Title_EventGrafX 

	; Title_Ticker = 5
	LDA #$05
	STA <Title_Ticker
PRG024_BBE9:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	; Push out graphics or just VSync

	DEC <Title_Ticker
	BPL PRG024_BBE9	; If Title_Ticker >= 0, loop!

	; Title_Ticker = 3
	LDA #$03
	STA <Title_Ticker

	; Queue next event
	LDA <Title_EventGrafX
	STA Graphics_Queue

	INC <Title_EventGrafX	 ; Title_EventGrafX++

	LDA <Title_EventGrafX
	CMP #$5f
	BNE PRG024_BBE9	 ; While Title_EventGrafX <> $5F, loop!

	; Ending2_TimerH = $F
	LDA #$0f
	STA <Ending2_TimerH

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	; Commit the dynamic graphics buffer
	LDA #$00
	STA <Title_EventGrafX

PRG024_BC0D:
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	LDA <Title_EventGrafX
	BNE PRG024_BC21	 ; If Title_EventGrafX <> 0 (curtain at the bottom), jump to PRG024_BC21

	; Lowering curtain
	LDA <Vert_Scroll
	SUB #$01
	STA <Vert_Scroll

	CMP #$3f
	BNE PRG024_BC21	 ; If Vert_Scroll <> $3F (curtain all the way down), jump to PRG024_BC21

	INC <Title_EventGrafX		 ; Title_EventGrafX = 1 (flags curtain at the bottom)

PRG024_BC21:

	; Ending2_TimerL--
	LDA <Ending2_TimerL
	SUB #$01
	STA <Ending2_TimerL
	BCS PRG024_BC0D	 ; If Ending2_TimerL didn't underflow, loop

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	DEC <Ending2_TimerH	 ; Ending2_TimerH--
	BPL PRG024_BC0D	 ; While Ending2_TimerH >= 0, loop

PRG024_BC32:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; Probably mainly for VSync

	JSR Ending2_DoEndPic	 ; Update and draw end picture per world

	LDA <Ending2_CurWorld
	CMP #$08
	BNE PRG024_BC32	 ; While Ending2_CurWorld <> 8, loop!

	; Ending2_CurWorld = 0
	LDA #$00
	STA <Ending2_CurWorld

	LDY #$44	 ; Y = $44 (all sprites used in ending)
PRG024_BC44:

	; Clear this sprite
	LDA #$f8
	STA Sprite_RAM,Y

	; Y -= 4 (previous sprite)
	DEY
	DEY
	DEY
	DEY

	BPL PRG024_BC44	 ; While Y >= 0, loop

PRG024_BC4F:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync 

	DEC <Vert_Scroll ; Vert_Scroll-- (lowering curtain for finale)

	LDA <Vert_Scroll
	CMP #$3f
	BNE PRG024_BC4F	 ; While curtain not completely lowered, loop!

	; Title_Ticker = $55
	LDA #$55
	STA <Title_Ticker

PRG024_BC5E:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; Vsync

	DEC <Title_Ticker	 ; Title_Ticker--
	BPL PRG024_BC5E		; While Title_Ticker >= 0, loop

	; Load graphics for "THE END"
	LDA #$1b
	STA PatTable_BankSel+5

	; Copy in sprite bytes to form THE END
	LDY #(Ending2_THEEND_End - Ending2_THEEND - 1)
PRG024_BC6C:
	LDA Ending2_THEEND,Y
	STA Sprite_RAM,Y

	DEY		 ; Y--
	BPL PRG024_BC6C	 ; While Y >= 0, loop

	; Title_Ticker = 3
	LDA #$03
	STA <Title_Ticker

	; Title_EventGrafX = 3 (going to cycle through all palettes for THE END to fade in)
	LDA #$03
	STA <Title_EventGrafX

	; Graphics_Queue = $5B
	LDA #$5b
	STA Graphics_Queue

PRG024_BC82:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync

	DEC <Title_Ticker ; Title_Ticker--
	BNE PRG024_BC82	 ; While Title_Ticker <> 0, loop

	DEC <Title_EventGrafX	 ; Title_EventGrafX--
	BMI PRG024_BCAE		; If Title_EventGrafX < 0, jump to PRG024_BCAE

	; Title_Ticker = 3
	LDA #$03
	STA <Title_Ticker

	; Set attribute on all THE END sprites
	LDA <Title_EventGrafX
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06
	STA Sprite_RAM+$0A
	STA Sprite_RAM+$0E
	STA Sprite_RAM+$12
	STA Sprite_RAM+$16
	STA Sprite_RAM+$1A
	STA Sprite_RAM+$1E

	JMP PRG024_BC82	 ; Jump to PRG024_BC82 (loop)

PRG024_BCAE:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync

	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG024_BCAE	 ; While Player has not pressed START, loop

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync

	; Disable display
	LDA #$00
	STA PPU_CTL2
	STA PPU_CTL1

	; Map_Unused7992 = 0 (used only in dead code it seems)
	LDA #$00
	STA Map_Unused7992

	; Temp_Var1 = 0
	LDY #$00
	STY <Temp_Var1

	; Temp_Var2 = $7F
	LDA #$7f
	STA <Temp_Var2

	; Clearing RAM $7FFF through $6000
PRG024_BCD4:
	LDA #$00
	STA [Temp_Var1],Y

	DEY		 ; Y--
	BNE PRG024_BCD4	 ; While Y <> 0 (come full circle), loop

	DEC <Temp_Var2	 ; Temp_Var2-- (previous page of RAM)

	LDA <Temp_Var2
	CMP #$5f
	BNE PRG024_BCD4	 ; While Temp_Var2 <> $5F, loop


	; P-Wings for everybody!
	LDX #$01	 ; X = 1
	LDY #(Inventory_Cards - Inventory_Items - 1)
PRG024_BCE7:

	LDA #(Inventory_Cards - Inventory_Items - 1)
	STA <Temp_Var1

	LDA #$08	 ; A = 8 (P-Wing)
PRG024_BCED:
	STA Inventory_Items,Y	 ; Here's another P-Wing

	DEY		 ; Y--

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG024_BCED	 ; While Temp_Var1 >= 0, loop

	DEX		 ; X--
	BMI PRG024_BD01	 ; If X < 0, jump to PRG024_BD01

	LDA #(Inventory_Cards - Inventory_Items - 1)
	ADD #(Inventory_Items2 - Inventory_Items)

	TAY		 ; Reset 'Y'
	JMP PRG024_BCE7	 ; Loop

PRG024_BD01:


	; Clear $07FF - $0000, excluding $01xx
	LDY #$07
	JSR Clear_RAM_thru_ZeroPage

	; Reset_Latch = $5A (magic value that prevents reset vector from being run)
	LDA #$5a
	STA Reset_Latch

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	LDA #HIGH(8000)
	STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	LDA #LOW(8000)
	STA Map_NSpade_NextScore+2

	; If they jumped a little earlier, they could've included the N-Spade score init, strangely
	JMP PRG030_845A		; Jump to PRG030_845A

	; THE END sprites
Ending2_THEEND:
	.byte $60, $F1, $03, $60
	.byte $60, $F3, $03, $68
	.byte $60, $F5, $03, $70
	.byte $60, $F7, $03, $78
	.byte $60, $F9, $03, $80
	.byte $60, $FB, $03, $88
	.byte $60, $FD, $03, $90
	.byte $60, $FF, $03, $98
Ending2_THEEND_End

Do_Ending2_IntCmd:
	DEC <Ending2_IntCmd	; Ending2_IntCmd-- (because it is zero based, and zero is "Do nothing")
	LDA <Ending2_IntCmd
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Ending2_ClearScreen
	.word Ending2_CommitPicture
 
Ending2_DoEndPic:
	; Ending2_IntCmd = 0 (disable interrupt routine command)
	LDA #$00
	STA <Ending2_IntCmd

	LDA <Ending2_PicState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Ending2_CurtainRaise	; 0: Raise the curtain back up
	.word Ending2_PrepClear		; 1: Prepare for screen clear
	.word Ending2_SetFlag1		; 2: Sets Ending2_IntCmd = 1 and waits for interrupt context (which will call Do_Ending2_IntCmd)
	.word Ending2_PrepEndPic	; 3: Load up the Ending_CmdBuffer, set starting VRAM address for world end picture
	.word Ending2_SetFlag2		; 4: Sets Ending2_IntCmd = 2 and waits for interrupt context (which will call Do_Ending2_IntCmd)
	.word Ending2_SeriesQueue	; 5: Queue a series of Graphics_Command (Ending2_QueueCmd++ until Ending2_QCmdEnd)
	.word Ending2_AddSprites	; 6: Add sprites that are part of the end picture
	.word Ending2_FadeIn		; 7: Fade in the palette
	.word Ending2_Wait		; 8: Wait on current world picture
	.word Ending2_FadeOut		; 9: Fade out the palette

Ending2_CurtainRaise:
	LDY #$01	; Y = 1 (two stabs at curtain being fully raised)
PRG024_BD62:
	INC <Vert_Scroll ; Vert_Scroll++ (raising the curtain)

	LDA <Vert_Scroll
	CMP #$ef
	BEQ PRG024_BD6E	 ; If curtain is fully raised, jump to PRG024_BD6E

	DEY		 ; Y--
	BPL PRG024_BD62	 ; While Y >= 0, loop

	RTS		 ; Return

PRG024_BD6E:
	INC <Ending2_PicState		 ; Ending2_PicState = 1
	RTS		 ; Return

Ending2_PrepClear:
	; Set Ending2_PicVRAMH/L
	LDA #$28
	STA <Ending2_PicVRAMH
	LDA #$60
	STA <Ending2_PicVRAML

	; Ending2_ClearLen = $14
	LDA #$14
	STA <Ending2_ClearLen

	; Ending2_ClearPat = $5C
	LDA #$5c
	STA <Ending2_ClearPat

	INC <Ending2_PicState	; Ending2_PicState = 2

	RTS		 ; Return

Ending2_SetFlag1:
	; Ending2_IntCmd = 1
	LDA #$01
	STA <Ending2_IntCmd

	RTS		 ; Return


Ending2_ClearScreen:
	LDA <Ending2_PicVRAMH
	CMP #$2b
	BEQ PRG024_BDBB	 ; If Ending2_PicVRAMH = $2b, jump to Ending2_PicVRAMH

	LDA PPU_STAT

	; Set VRAM Address to Ending2_PicVRAMH/L
	LDA <Ending2_PicVRAMH
	STA PPU_VRAM_ADDR
	LDA <Ending2_PicVRAML
	STA PPU_VRAM_ADDR

	LDY #$1f	 ; Y = $1F
	LDA <Ending2_ClearPat	; Get the clearing pattern
PRG024_BDA0:
	STA PPU_VRAM_DATA	; Store pattern

	DEY		 ; Y--
	BPL PRG024_BDA0	 ; While Y >= 0, loop

	DEC <Ending2_ClearLen	; Ending2_ClearLen--
	BPL PRG024_BDB7		; If Ending2_ClearLen >= 0, jump to PRG024_BDB7

	; Set Ending2_PicVRAMH 
	LDA #$2b
	STA <Ending2_PicVRAMH
	LDA #$c8
	STA <Ending2_PicVRAML

	; Ending2_ClearLen = 4
	LDA #$04
	STA <Ending2_ClearLen

	RTS		 ; Return

PRG024_BDB7:
	JSR Ending2_PicVRAM_NextLineWrap

	RTS		 ; Return

PRG024_BDBB:
	LDA PPU_STAT

	; Set VRAM Address to Ending2_PicVRAMH/L
	LDA <Ending2_PicVRAMH
	STA PPU_VRAM_ADDR
	LDA <Ending2_PicVRAML
	STA PPU_VRAM_ADDR

	LDY #$07	 ; Y = $07
	LDA #$aa	 ; Pattern $AA
PRG024_BDCC:
	STA PPU_VRAM_DATA	; Store pattern

	DEY		 ; Y--
	BPL PRG024_BDCC	 ; While Y >= 0, loop

	DEC <Ending2_ClearLen	; Ending2_ClearLen----
	BPL PRG024_BDD8	 	; If Ending2_ClearLen >= 0, jump to PRG024_BDD8

	INC <Ending2_PicState	; Ending2_PicState++

PRG024_BDD8:

	; Ending2_PicVRAML += 8
	LDA <Ending2_PicVRAML
	ADD #$08
	STA <Ending2_PicVRAML

	RTS		 ; Return

Ending2_PrepEndPic:
	LDY <Ending2_CurWorld	; Y = current world we're depicting

	; Temp_Var2/1 hold the address to the end world picture
	LDA EndPicByWorld_H,Y
	STA <Temp_Var2
	LDA EndPicByWorld_L,Y
	STA <Temp_Var1

	LDY #$00	 ; Y = 0 (EndPic command index)
	LDX #$00	 ; X = 0 (Ending_CmdBuffer index)
PRG024_BDF0:
	; Next command byte -> Temp_Var16
	LDA [Temp_Var1],Y
	STA <Temp_Var16	

	AND #$80
	BEQ PRG024_BE02	 ; If bit 7 is NOT set, jump to PRG024_BE02

	; Bit 7 set...

	; Clear bit 7
	LDA <Temp_Var16
	AND #$7f
	STA <Temp_Var16

	; Store byte into buffer
	STA Ending_CmdBuffer,X
	INX		 ; X++ (next buffer byte)

PRG024_BE02:

	; Bit 7 not set (or just continued)

	; Store byte into buffer
	LDA <Temp_Var16	
	STA Ending_CmdBuffer,X
	INX		 ; X++ (next buffer byte)

	INY		 ; Y++ (next EndPic command byte)

	CPX #$c1
	BLT PRG024_BDF0	 ; While buffer index < $C1, loop!

	; Buffer filled...

	LDY <Ending2_CurWorld	; Y = current world we're depicting

	; Set starting VRAM address
	LDA EndPic_VRAMStart_H,Y
	STA <Ending2_PicVRAMH
	LDA EndPic_VRAMStart_L,Y
	STA <Ending2_PicVRAML

	INC <Ending2_PicState		 ; Ending2_PicState = 4

	; Ending2_ClearLen = $B
	LDA #$0b
	STA <Ending2_ClearLen

	; Ending2_QCmdEnd = 0
	LDA #$00
	STA <Ending2_QCmdEnd

	RTS		 ; Return

Ending2_SetFlag2:
	; Ending2_IntCmd = 2
	LDA #$02
	STA <Ending2_IntCmd

	RTS		 ; Return


PRG024_BE29:
	.byte $2A, $2E, $32, $36, $3A, $3E, $44, $49
PRG024_BE31:
	.byte $2D, $31, $35, $39, $3D, $43, $48, $4C

Ending2_CommitPicture:
	LDA PPU_STAT	

	; Set VRAM Address to Ending2_PicVRAMH/L
	LDA <Ending2_PicVRAMH
	STA PPU_VRAM_ADDR
	LDA <Ending2_PicVRAML
	STA PPU_VRAM_ADDR

	LDX #$0f	 	; X = 4
	LDY <Ending2_QCmdEnd	; Y = Ending2_QCmdEnd
PRG024_BE4A:

	; Buffer -> PPU_VRAM_DATA
	LDA Ending_CmdBuffer,Y
	STA PPU_VRAM_DATA

	INY		 ; Y++
	DEX		 ; X--
	BPL PRG024_BE4A	 ; While X >= 0, loop

	STY <Ending2_QCmdEnd	; Update Ending2_QCmdEnd

	JSR Ending2_PicVRAM_NextLineWrap	; Next line

	DEC <Ending2_ClearLen	; Ending2_ClearLen--
	BPL PRG024_BE6B	 	; If Ending2_ClearLen >= 0, jump to PRG024_BE6B (RTS)

	INC <Ending2_PicState	; Ending2_PicState++

	LDX <Ending2_CurWorld	; X = current world we're depicting

	LDA PRG024_BE29,X
	STA <Ending2_QueueCmd

	LDA PRG024_BE31,X
	STA <Ending2_QCmdEnd

PRG024_BE6B:
	RTS		 ; Return

Ending2_SeriesQueue:
	; Execute next command
	LDA <Ending2_QueueCmd
	STA <Graphics_Queue

	CMP <Ending2_QCmdEnd
	BNE PRG024_BE76	 ; If this is not the last series command to execute, jump to PRG024_BE76

	; Last command executed!
	INC <Ending2_PicState		 ; Ending2_PicState = 6

PRG024_BE76:
	INC <Ending2_QueueCmd		 ; Ending2_QueueCmd++

	RTS		 ; Return

Ending2_AddSprites:

	; Clear ending sprites
	LDA #$f8
	STA Sprite_RAM+$24
	STA Sprite_RAM+$28
	STA Sprite_RAM+$2C
	STA Sprite_RAM+$30
	STA Sprite_RAM+$34
	STA Sprite_RAM+$38
	STA Sprite_RAM+$3C
	STA Sprite_RAM+$40
	STA Sprite_RAM+$44

	LDY <Ending2_CurWorld	; Y = current world we're depicting

	; Load pattern tables required for this world picture sprites
	LDA Ending2_EndPicPatTable2,Y
	STA PatTable_BankSel+2
	LDA Ending2_EndPicPatTable3,Y
	STA PatTable_BankSel+3
	LDA Ending2_EndPicPatTable4,Y
	STA PatTable_BankSel+4
	LDA Ending2_EndPicPatTable5,Y
	STA PatTable_BankSel+5

	; Load starting address for sprite list
	LDA Ending2_EndPicSpriteListH,Y
	STA <Temp_Var2
	LDA Ending2_EndPicSpriteListL,Y
	STA <Temp_Var1

	; Load length of sprite list
	LDA Ending2_EndPicSpriteListLen,Y
	TAY

	; Copy sprite data in
PRG024_BEBE:
	LDA [Temp_Var1],Y
	STA Sprite_RAM,Y

	DEY		 ; Y--
	BPL PRG024_BEBE	 ; While Y >= 0, loop

	INC <Ending2_PicState	 ; Ending2_PicState = 7

	; Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

	; Ending2_QueueCmd = $26
	LDA #$26
	STA <Ending2_QueueCmd

	RTS		 ; Return


Ending2_FadeIn:
	DEC <Ending2_FadeTimer	; Ending2_FadeTimer--
	BPL PRG024_BEFB	 	; If Ending2_FadeTimer >= 0, jump to PRG024_BEFB (RTS)

	; Reload Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

	; Queue graphics command
	LDA <Ending2_QueueCmd
	STA Graphics_Queue

	CMP #$2a
	BNE PRG024_BEF9	 ; If Ending2_QueueCmd <> $2A, jump to PRG024_BEF9

	INC <Ending2_PicState	 ; Ending2_PicState = 8

	; Queue the full palette (fade in is common)
	LDA <Ending2_CurWorld	; A = current world we're depicting
	ADD #$4d
	STA Graphics_Queue

	; Ending2_TimerH = $F
	LDA #$0f
	STA <Ending2_TimerH

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	; Ending2_QueueCmd = $06
	LDA #(Ending2_FadeOutQs_End - Ending2_FadeOutQs - 1)
	STA <Ending2_QueueCmd

	RTS		 ; Return

PRG024_BEF9:
	INC <Ending2_QueueCmd		 ; Ending2_QueueCmd++

PRG024_BEFB:
	RTS		 ; Return

Ending2_Wait:
	; Ending2_TimerL--
	LDA <Ending2_TimerL
	SUB #$01
	STA <Ending2_TimerL
	BCS PRG024_BF13	 ; If Ending2_TimerL >= 0, jump to PRG024_BF13 (RTS)

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	DEC <Ending2_TimerH	 ; Ending2_TimerH--
	BPL PRG024_BF13	 	; If Ending2_TimerH >= 0, jump to PRG024_BF13 (RTS)

	INC <Ending2_PicState		 ; Ending2_PicState = 9

	; Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

PRG024_BF13:
	RTS		 ; Return

	; Fade out command queues
Ending2_FadeOutQs:
	.byte $25, $26, $27, $28, $28, $28, $28
Ending2_FadeOutQs_End
	
Ending2_FadeOut:
	DEC <Ending2_FadeTimer
	BPL PRG024_BF37	 ; If Ending2_FadeTimer >= 0, jump to PRG024_BF37 (RTS)

	; Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

	LDX <Ending2_QueueCmd	 ; X = Ending2_QueueCmd (current index)

	; Queue next fade command
	LDA Ending2_FadeOutQs,X
	STA Graphics_Queue

	CMP #$25
	BNE PRG024_BF35	 ; If current queue command <> $25, jump to PRG024_BF35

	; Restart ending picture generation
	LDA #$01
	STA <Ending2_PicState	; Ending2_PicState = 1

	INC <Ending2_CurWorld		 ; Ending2_CurWorld++ (display next world in series)

PRG024_BF35:
	DEC <Ending2_QueueCmd		 ; Ending2_QueueCmd--

PRG024_BF37:
	RTS		 ; Return


; FIXME: Anybody want to claim this??
; Seems to be called by dead code, would advance to next row or wrap around; maybe a clearing routine?
Ending2_PicVRAM_NextLineWrap:

	; Add 32 to VRAM address for next row
	LDA <Ending2_PicVRAML
	ADD #32
	STA <Ending2_PicVRAML
	LDA <Ending2_PicVRAMH
	ADC #$00
	STA <Ending2_PicVRAMH

	CMP #$28
	BGE PRG024_BF5D	; If VRAM High address >= $28, jump to PRG024_BF5D (RTS)

	CMP #$23
	BLT PRG024_BF5D	; If VRAM High address < $23, jump to PRG024_BF5D (RTS)

	LDA <Ending2_PicVRAML
	CMP #$c0
	BLT PRG024_BF5D	; If VRAM Low address < $C0, jump to PRG024_BF5D (RTS)

	; This will wrap the VRAM address to the top (???)

	; Ending2_PicVRAMH = $28
	LDA #$28
	STA <Ending2_PicVRAMH

	; Column on top row
	LDA <Ending2_PicVRAML
	AND #$1f
	STA <Ending2_PicVRAML

PRG024_BF5D:
	RTS		 ; Return

PRG024_FREE_SPACE:
	.ds 0xFE0

	; PatTable_BankSel+X values (sprite pattern tables) loaded per "world" of ending picture
Ending2_EndPicPatTable2:	.byte $57, $53, $51, $00, $43, $02, $44, $54
Ending2_EndPicPatTable3:	.byte $00, $04, $00, $76, $76, $76, $04, $76
Ending2_EndPicPatTable4:	.byte $57, $4E, $1A, $1A, $00, $0B, $00, $00
Ending2_EndPicPatTable5:	.byte $4F, $4F, $00, $00, $4F, $4F, $4F, $00

	; Split address, parallel tables for the starting address of the end picture sprite lists for each world
Ending2_EndPicSpriteListH:	
	.byte HIGH(Ending2_EndPicSprites1)
	.byte HIGH(Ending2_EndPicSprites2)
	.byte HIGH(Ending2_EndPicSprites3)
	.byte HIGH(Ending2_EndPicSprites4)
	.byte HIGH(Ending2_EndPicSprites5)
	.byte HIGH(Ending2_EndPicSprites6)
	.byte HIGH(Ending2_EndPicSprites7)
	.byte HIGH(Ending2_EndPicSprites8)

Ending2_EndPicSpriteListL:
	.byte LOW(Ending2_EndPicSprites1)
	.byte LOW(Ending2_EndPicSprites2)
	.byte LOW(Ending2_EndPicSprites3)
	.byte LOW(Ending2_EndPicSprites4)
	.byte LOW(Ending2_EndPicSprites5)
	.byte LOW(Ending2_EndPicSprites6)
	.byte LOW(Ending2_EndPicSprites7)
	.byte LOW(Ending2_EndPicSprites8)

	; Length of the sprite list per world - 1 (or last index, if you prefer)
Ending2_EndPicSpriteListLen:	
	.byte (Ending2_EndPicSprites1_End - Ending2_EndPicSprites1 - 1)
	.byte (Ending2_EndPicSprites2_End - Ending2_EndPicSprites2 - 1)
	.byte (Ending2_EndPicSprites3_End - Ending2_EndPicSprites3 - 1)
	.byte (Ending2_EndPicSprites4_End - Ending2_EndPicSprites4 - 1)
	.byte (Ending2_EndPicSprites5_End - Ending2_EndPicSprites5 - 1)
	.byte (Ending2_EndPicSprites6_End - Ending2_EndPicSprites6 - 1)
	.byte (Ending2_EndPicSprites7_End - Ending2_EndPicSprites7 - 1)
	.byte (Ending2_EndPicSprites8_End - Ending2_EndPicSprites8 - 1)

Ending2_EndPicSprites1:
	.byte $81, $19, $00, $B0
	.byte $81, $1B, $00, $B8
	.byte $91, $1D, $00, $B0
	.byte $91, $21, $00, $B8
	.byte $B1, $EB, $01, $B8
	.byte $B1, $EB, $41, $C0
	.byte $B1, $D9, $01, $80
	.byte $B1, $DB, $41, $88
	.byte $B1, $D9, $01, $90
	.byte $B1, $DB, $41, $98
Ending2_EndPicSprites1_End

Ending2_EndPicSprites2:
	.byte $79, $1B, $40, $38
	.byte $79, $19, $40, $40
	.byte $99, $67, $01, $50
	.byte $B1, $65, $01, $70
	.byte $A9, $85, $01, $88
	.byte $A9, $87, $01, $90
	.byte $B9, $A5, $01, $88
	.byte $B9, $A7, $01, $90
	.byte $91, $8D, $02, $A8
	.byte $91, $8F, $02, $B0
	.byte $99, $B1, $02, $D0
	.byte $99, $B3, $02, $D8
	.byte $A9, $B5, $02, $D0
	.byte $A9, $B7, $02, $D8
Ending2_EndPicSprites2_End

Ending2_EndPicSprites3:
	.byte $3F, $B1, $01, $30
	.byte $3F, $B1, $41, $38
	.byte $47, $B5

	; List continued in PRG025



