; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012

; DMC sounds are here!
; Note that due to limitation of the register, these sounds must be aligned on 64-byte ($40) boundaries

DMC01:
DMC01_End

DMC02:
DMC02_End

	;
;; 0xE bytes
DoWallslidePoof:
	LDA <Counter_1
	AND #%00001111
	BNE _no_wallslide_poof
	LDA #$0a
	STA <Temp_Var1
	JSR WalljumpPoof
_no_wallslide_poof:
	RTS

;;
WalljumpPoof:				; (see CannonFire_NoiseAndSmoke)
	JSR BrickBust_MoveOver		; Make room in first "brick bust" slot for poof

	; Brick bust, poof style
	LDA #$01
	STA BrickBust_En

	; Set poof X			; We want the poof at the edge of the wall
	LDA #-6
	STA <Temp_Var2
	LDA <Player_X
	AND #$0f
	CMP #$08
	BPL _set_poofx
	LDA #6
	STA <Temp_Var2
_set_poofx:
	LDA <Player_X
	SUB <Horz_Scroll		; Make relative to horizontal scroll
	ADD <Temp_Var2
	STA BrickBust_X			; Set X

	LDA <Player_Y
	ADD #$0C
	SUB Level_VertScroll		; Make relative to vertical scroll
	STA BrickBust_YUpr		; Set Y

	; Set poof counter
	LDA <Temp_Var1
	STA BrickBust_HEn

	RTS		 ; Return

CheckForRegrab:
	;; This needs to load Pad_Input AND'd with PAD_A before returning
	LDA <Player_Regrabbing		; Regrab only allowed once every few frames
	BMI _regrab_lda_rts		; Regrab only allowed once per jump
	BNE _regrab_do_spin

	LDA <Player_InAir		; Regrab only done if in air
	BEQ _regrab_lda_rts

	;LDA <Player_YVel		; Regrab only done if YVel is > some small negative value, so you can regrab toward the top of your jump
	;BMI _regrab_lda_rts
	LDA <Player_Wallsliding		; Regrab only done for non-walljumps
	BNE _regrab_lda_rts

	LDA <Pad_Input
	AND #PAD_A			; Regrab while falling in air by pressing A while holding Up
	BEQ _regrab_rts
	LDA <Pad_Holding		; Pressed A, are we holding Up?
	AND #PAD_UP
	BEQ _regrab_lda_rts

	LDA #30				; Spin for 30 frames
	STA <Player_Regrabbing
	BNE _regrab_lda_rts

_regrab_do_spin:
	LDA <Counter_1
	AND #%00000001
	BNE _regrab_dec_rts
	LDA <Player_FlipBits
	EOR #$40
	STA <Player_FlipBits
_regrab_dec_rts:
	DEC <Player_Regrabbing
	BEQ _regrab_dec_rts		;  If we hit zero, go to 0xFF
_regrab_lda_rts:
	LDA <Pad_Input
	AND #PAD_A
_regrab_rts:
	RTS

	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF

Music_PlayDMC:
	LDA DMC_Queue	 ; Get value queued for DMC
	CMP #$7e	 
	BEQ Music_StopDMC	; If rest value was queued, jump to Music_StopDMC
	LDA DMC_Queue	 	; A = queue value
	BNE PRG031_E2E1	 	; If something was queued, jump to PRG031_E2E1

	; Nothing queued...
	LDA DMC_Current 
	BEQ Music_StopDMC	; If nothing is playing, jump to Music_StopDMC
	DEC DMC_Time	 	; DMC_Time--
	BNE PRG031_E2E0	 	; If time has not expired on DMC, jump to PRG031_E2E0 (RTS)

Music_StopDMC:
	LDA #$00	 
	STA DMC_Current ; Stop any current DMC sound
	LDA #$0f	 
	STA PAPU_EN	 ; Disable DMC

PRG031_E2E0:
	RTS		 ; Return

PRG031_E2E1:
	STA DMC_Current 
	TAY		 ; Y = DMC_Current

	LDA DMC_MODCTL_LUT-1,Y		; Subtract 1 from LUT address since $00 is disabled and $01 is first DMC sound
	STA PAPU_MODCTL	 		; Update PAPU_MODCTL
	STA PAPU_MODCTL_Copy		; ... and it's copy

	LDA DMC_MODADDR_LUT-1,Y	; Subtract 1 from LUT address since $00 is disabled and $01 is first DMC sound
	STA PAPU_MODADDR	 	; Set PAPU_MODADDR (address of sound)

	LDA DMC_MODLEN_LUT-1,Y		; Subtract 1 from LUT address since $00 is disabled and $01 is first DMC sound
	STA PAPU_MODLEN	 		; Set PAPU_MODLEN (length of sound)

	LDA #$a0	 
	STA DMC_Time	 ; DMC_Time = $A0 (always apparently)

	LDA #$0f	 
	STA PAPU_EN	 ; Disable DMC
	LDA #$1f	 
	STA PAPU_EN	 ; Enable DMC
	RTS		 ; Return

	; The address are $C000 | (value << 6)
MADR .func ((\1 & $3FFF) >> 6)

	; The length is (value << 4) + 1 (minimum 1 byte long to $FF1 bytes long)
MLEN .func ((\2 - \1) >> 4)


	; Sample 3: "BAD SAMPLE LENGTH"
	; Seems there is an errorenous, very long/very wrong sample length on
	; Sample 3.  Whether this is a mistake or a "lost DMC sample" I don't
	; know.  In any case, Sample 1 plays DMC02 correctly, Sample 3 would
	; play DMC02 and just continue on through code, which would be noisy.
DMC_MODADDR_LUT:
	.byte MADR(DMC_ORB)		; Sample  0 (DMC_ORB)
	.byte MADR(DMC_SILENCE)	; Sample  1 (DMC_SILENCE)
	.byte MADR(DMC_MOTHER1)
	.byte MADR(DMC_MOTHER2)
	.byte MADR(DMC_GRADIUS1)


DMC_MODLEN_LUT:
	; these are (value << 4) + 1, that is minimum 1 byte long to FF1 bytes
	.byte MLEN(DMC_ORB, DMC_ORB_End)		; Sample  0 (DMC_ORB)
	.byte MLEN(DMC_SILENCE, DMC_ORB_End)	; Sample  1 (DMC_SILENCE)
	.byte MLEN(DMC_MOTHER1, DMC_MOTHER1_End)	; Sample 2 (DMC_MOTHER1)
	.byte MLEN(DMC_MOTHER2, DMC_MOTHER2_End)	; Sample 2 (DMC_MOTHER2)
	.byte MLEN(DMC_GRADIUS1, DMC_GRADIUS1_End)


DMC_MODCTL_LUT:
	.byte $0E	; Sample  0 (DMC_ORB)
	.byte $0E	; Sample  0 (DMC_SILENCE)
	.byte $0F	; Sample  0 (DMC_MOTHER1)
	.byte $0F	; Sample  0 (DMC_MOTHER2)
	.byte $0F


Music_GetRestTicks:
	; A is a byte from the music segment, $80-$fe/$ff on non-squares
	; Only the lower 4 bits are used here
	;
	; The rest value returned is:
	; Music_RestH_LUT[Music_RestH_Base + Music_RestH_Off + (0 to 15)]
	;
	; Note that Music_RestH_Base is always divisible by $10 and
	; Music_RestH_Off is always $00 or $10 (low time warning)

	AND #$0f	 	; Get lower 4 bits
	ADD <CurrRestOff
	;ADD Music_RestH_Base	; Add this to Music_RestH_Base
	;;;ADC Music_RestH_Off	; Add this to Music_RestH_Off

	TAY			; Y = A
	LDA [Music_Rest_PtrL],Y 	; Get value from the rest array 
	RTS		 	; Return

SndMus_QueueCommonJ:
	JMP SndMus_QueueCommon

; FIXME: Anybody want to claim this?
; $E34C
	JMP Music_StopAll	 

Sound_PlayMusic:
	LDA Sound_QMusic1
	BNE SndMus_QueueCommonJ	; If music from set 1 has been queued, jump to SndMus_QueueCommonJ

	; Music has not been queued from set 1...
	LDA SndCur_Music1	 
	BEQ PRG031_E364	 	; If no music is currently playing in set 1, jump to PRG031_E364

	LDA Sound_QMusic2
	BEQ PRG031_E361	 	; If music from set 2 has NOT been queued, jump to PRG031_E361


	; Music from set 2 has been queued!
	STA Music2_Hold	 	; Store it into the hold until the Set 1 song has expired!

PRG031_E361:
	JMP Music_Sq2Track

PRG031_E364:
	; No music in *Set 1* is currently playing
	; Music from Set 2 MAY have been queued

	; The following check is probably superfluous, as Set 1 should have
	; already been handled above...
	LDA Sound_QMusic1
	BNE SndMus_QueueCommonJ	; If music from set 1 has been queued, jump to SndMus_QueueCommonJ  

	; Set 2 is funny; it uses index in low bit and high bit.  ($01-$0F and $10-$F0)
	; Not really sure what the point of that is, except perhaps to break it up into two sets.
	; Allows 16 values though not all are used ($D0, $E0, $F0)

	; I'm breaking the Set 2 into Set 2A ($01-$0F) and Set 2B ($10-$F0)
	LDA Sound_QMusic2	
	AND #MUS2B_MASK	
	BEQ SndMus_QueueCommonJ	; If music selection is not Set 2B (or none queued), jump to SndMus_QueueCommonJ

	; If you're here, that means that there is a Set 2B queue
	; somewhere between $10 and $F0...
	LDA Sound_QMusic2
	BNE SndMus_QueueSet2B	; Whatever was queued, jump to SndMus_QueueSet2B

	LDA SndCur_Music2	 
	BNE PRG031_E3EB	 ; If something is playing in Set 2, jump to PRG031_E3EB

	RTS		 ; Return

	;;;; 
SndMus_QueueSet2B:
	; For queuing any Set 2B music $10 - $F0

	STA SndCur_Music2	; Store which Set 2 song we're playing
	LDY #$00	 	
	STY SndCur_Music1	; Stop any Set 1 song

	; Shift it down 4 bits to make it a 1-15 index
	LSR A
	LSR A
	LSR A
	LSR A

	TAY		 		; Y = A
	LDA Music_Set2B_Starts-1,Y	; Because Y starts at '1', we must subtract 1 from the LUT address
	STA Music_Start	 		; Set Music_Start

	LDA Music_Set2B_Ends-1,Y	; Because Y starts at '1', we must subtract 1 from the LUT address
	ADD #$02	 		; A += 2 (Reason for adding two: The index counter is always one ahead, and the end index is INCLUSIVE!)
	STA Music_End			; Set Music_End

	LDA Music_Set2B_Loops-1,Y	; Because Y starts at '1', we must subtract 1 from the LUT address
	STA Music_Loop	 		; Set Music_Loop

	LDA Music_Start		; A = Music_Start


SndMus2B_NextOrStop:
	STA Music_NextIndex	; Update Music_NextIndex

SndMus2B_Next:
	INC Music_NextIndex	; Music_NextIndex++	(This makes the index always 1 ahead)

	LDY Music_NextIndex	; 
	CPY Music_End		; 
	BNE SndMus2B_LoadNext 	; If Music_NextIndex <> Music_End, jump to SndMus2B_LoadNext

	; We've reached the end of the song!
	LDA Music_Loop		; Reload with the loop start value
	BNE SndMus2B_NextOrStop		; Jump back so we play this index (unless loop = 0, in which case we stop)

	; If loop = 0, stop music
	JMP Music_StopAll

PRG031_E3EB:
	JMP Music_Sq2Track

SndMus2B_LoadNext:
	; Load next "index" (Y) of Music Set 2 song...
	TYA
	ASL A
	TAY
	LDA Music_Set2B_IndexOffs-2,Y	; Get offset for the current index; it is always one ahead, so -1 from the LUT
	;TAY		 ; Use this offset value in Y
	STA <Temp_Var1
	LDA Music_Set2B_IndexOffs-1,Y	; Get offset for the current index; it is always one ahead, so -1 from the LUT
	STA <Temp_Var2

	; Get and store rest lookup base index for this segment in Music_RestH_Base
	;LDA Music_Set2B_Headers,Y
	LDY #$00
	LDA [Temp_Var1],Y
	STA <Music_Rest_PtrL
	INY
	;LDA Music_Set2B_Headers+1,Y
	LDA [Temp_Var1],Y
	STA <Music_Rest_PtrH
	INY

	; Get and store the base address into [Music_Base_H][Music_Base_L]
	LDA [Temp_Var1],Y
	STA <Music_Base_L
	INY
	LDA [Temp_Var1],Y
	STA <Music_Base_H
	INY

	; Get and store triangle track offset
	LDA [Temp_Var1],Y
	STA <Music_TriTrkLo
	INY
	LDA [Temp_Var1],Y
	STA <Music_TriTrkHi
	INY

	; Get and store square 1 track offset
	LDA [Temp_Var1],Y
	STA Music_Sq1TrkOff
	INY

	; Set and store noise track offset
	LDA [Temp_Var1],Y
	STA <Music_NSETrkLo
	STA Music_NseStartLo
	INY
	LDA [Temp_Var1],Y
	STA <Music_NSETrkHi
	STA Music_NseStartHi
	INY
	;STA Music_NseStart	; Retain starting position for possible restoration later

	; Set and store DMC track offset
	LDA [Temp_Var1],Y
	STA <Music_PCMTrkLo
	STA Music_PCMStartLo
	INY
	LDA [Temp_Var1],Y
	STA <Music_PCMTrkHi
	STA Music_PCMStartHi
	INY
	;STA Music_PCMTrkPos
	;STA Music_PCMStart	; Retain starting position for possible restoration later

	LDA [Temp_Var1],Y
	STA Sq1RestOff
	INY
	LDA [Temp_Var1],Y
	STA TriRestOff
	INY
	LDA [Temp_Var1],Y
	STA NseRestOff
	INY

	JMP PRG031_E48C


SndMus_QueueCommon:
	; Music has been queued!

	; This entry point is also used by Music Set 2A, so we
	; need to figure out which one we're doing!
	LDA Sound_QMusic1
	BNE SndMus_Queue1	; Queuing Music Set 1, jump to SndMus_Queue1


	; For queuing any Set 2A music $00 - $0F
	LDA Sound_QMusic2
	BNE PRG031_E401	 	; To queue Music Set 2A, jump to PRG031_E401

	LDA SndCur_Music1
	ORA SndCur_Music2
	BNE PRG031_E3EB	 	; If something is playing in Music Set 1 or Music Set 2A/B, jump to PRG031_E3EB

	; Nothing playing
	RTS		 ; Return

PRG031_E401:
	STA SndCur_Music2	; Store what set 2 song we're playing
	CMP #$09	 	
	BEQ PRG031_E411	 ; If queueing song $09 (coin heaven, sky map, etc.), jump to PRG031_E411
	CMP #$0a
	BEQ PRG031_E411	 ; If queueing song $0A Invincibility, jump to PRG031_E411

	;LDY #$00
	;STY Music_RestH_Off	 ; Reset the rest lookup offset adjust value

PRG031_E411:
	LDY #$00	
	STY SndCur_Music1 ; Stop any Set 1 song playing

	TAY		  		; Y = A
	LDA Music_Set2A_Starts-1,Y	; Because Y starts at '1', we must subtract 1 from the LUT address
	STA Music_Start	  		; Set Music_Start

	LDA Music_Set2A_Ends-1,Y	; Because Y starts at '1', we must subtract 1 from the LUT address
	ADD #$02	 		; A += 2 (Reason for adding two: The index counter is always one ahead, and the end index is INCLUSIVE!)
	STA Music_End	 		; Set Music_End

	LDA Music_Set2A_Loops-1,Y	; Because Y starts at '1', we must subtract 1 from the LUT address 
	STA Music_Loop	 		; Set Music_Loop

	LDA Music_Start	 		; A = Music_Start

SndMus2A_NextOrStop:
	STA Music_NextIndex	 	; Update Music_NextIndex

SndMus2A_Next:
	INC Music_NextIndex	 	; Music_NextIndex++

	LDY Music_NextIndex	 	; 
	CPY Music_End	 		; 
	BNE SndMus2A_LoadNext	 	; If Music_NextIndex <> Music_End, jump to SndMus2A_LoadNext

	; We've reached the end of the song!
	LDA Music_Loop			; Reload with the loop start value
	BNE SndMus2A_NextOrStop		; Jump back so we play this index (unless loop = 0, in which case we stop)

	; If loop = 0, stop music
	JMP Music_StopAll

SndMus_Queue1:
	STA SndCur_Music1	; SndCur_Music1 = queued music
	LDY SndCur_Music2	; Y = SndCur_Music2
	STY Music2_Hold	 	; If a "set 2" song is playing, back up which one it is; we'll restart it after this song finishes (only really used for the "time low" song)
	LDY #$00	 	; 
	STY SndCur_Music2	; Stop "set 2" song (if any)
	;STY Music_RestH_Off	; Clear the rest lookup base offset value

	; The following loop transforms the queue value into an index value.
	; This is the same basic procedure used for sound effects, and even
	; gives "priority" to different tunes, but that feature is probably
	; not really used at all...
PRG028_E456:
	INY		 ; Y++
	LSR A		 ; 
	BCC PRG028_E456	 ; If we haven't hit a bit, go around again...

SndMus2A_LoadNext:
	; Both Set 1 and 2A enter here...
	; The only difference is that Set 1 enters directly with an index in mind
	; Set 2A enters using the index counting system like 2B.  So it works since
	; 2B's lowest index is 08!

	; 'Y' is the next 1/2A index we're going to play
	LDA Music_Set1_Set2A_IndexOffs-1,Y	 ; This selects the offset to the track offset headers for this song; we subtract 1 since 'Y' starts at 1
	TAY

	; Set rest lookup base index
	LDA Music_Set1_Set2A_Headers,Y
	STA <Music_Rest_PtrL
	LDA Music_Set1_Set2A_Headers+1,Y
	STA <Music_Rest_PtrH

	; Set music base address
	LDA Music_Set1_Set2A_Headers+2,Y
	STA <Music_Base_L
	LDA Music_Set1_Set2A_Headers+3,Y
	STA <Music_Base_H

	; Set triangle track position
	LDA Music_Set1_Set2A_Headers+4,Y
	STA <Music_TriTrkLo
	LDA Music_Set1_Set2A_Headers+5,Y
	STA <Music_TriTrkHi

	; Set square 1 track position
	LDA Music_Set1_Set2A_Headers+6,Y
	STA Music_Sq1TrkOff

	; Set noise track position
	LDA Music_Set1_Set2A_Headers+7,Y
	STA <Music_NSETrkLo
	STA Music_NseStartLo
	LDA Music_Set1_Set2A_Headers+8,Y
	STA <Music_NSETrkHi
	STA Music_NseStartHi

DMC02_Bad:	; Sample 3 in the DMC table suggests a sample ending here; likely a mistake or lost DMC sound?

	;STA Music_NseStart

	; Set PCM track position
	LDA Music_Set1_Set2A_Headers+9,Y
	STA <Music_PCMTrkLo
	STA Music_PCMStartLo
	LDA Music_Set1_Set2A_Headers+10,Y
	STA <Music_PCMTrkHi
	STA Music_PCMStartHi

	;STA Music_PCMTrkPos
	;STA Music_PCMStart


PRG031_E48C:
	; New index has been loaded

	; Set all rests to 1; this forces them all to update next cycle
	LDA #$01
	STA Music_Sq2Rest
	STA Music_Sq1Rest
	STA Music_TriRest
	STA Music_NoiseRest
	STA Music_DMCRest

	; Square 2's track offset is always assumed to be at zero
	LDA #$00
	STA Music_Sq2TrkOff

	STA Music_Sq1AltRamp	; No alternate ramp on Square 1 yet..
	STA Music_Sq1Bend 	; Clear bend effect on Square 1
	STA Music_Sq2Bend	; Clear bend effect on Square 2

	LDA SndCur_Music1
	CMP #$01
	BNE PRG031_E4BB	 ; If we're not playing Set 1 $01 Player Death, jump to PRG031_E4BB

	; SndCur_Player = 0
	LDA #$00
	STA SndCur_Player

	LDA #$08	 ; Enable only noise channel
	BNE PRG031_E4BD	 ; (technically always) jump to PRG031_E4BD

PRG031_E4BB:
	; Almost all songs enter here...
	LDA #$0b	 ; Both squares + noise only

PRG031_E4BD:
	STA PAPU_EN
	LDA #$0f
	STA PAPU_EN	 ; Enable all channels

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Square 2's music track code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Music_Sq2Track:

	DEC Music_Sq2Rest	; Music_Sq2Rest--
	BEQ PRG031_E4CD	 	; If Music_Sq2Rest = 0, time to update Track Square 2!
	JMP PRG031_E57A	 	; Otherwise, jump to PRG031_E57A

PRG031_E4CD:
	LDY Music_Sq2TrkOff	; Y = Music_Sq2TrkOff

	INC Music_Sq2TrkOff	; Music_Sq2TrkOff++

	LDA [Music_Base_L],Y	; Get next byte from music segment data
	BEQ Music_EndSegment 	; If byte is zero, jump to Music_EndSegment
	BPL Music_Sq2NoteOn	; If byte is $01 - $7f, jump to Music_Sq2NoteOn
	BNE PRG031_E51E	 	; $80 - $ff, jump to PRG031_E51E

Music_EndSegment:
	LDA SndCur_Music1	; Are we playing something from Set 1?
	BEQ PRG031_E4F7		; If not, jump to PRG031_E4F7

	; Set 1 music...
	CMP #$40	 
	BNE Music_StopAll	; If we NOT were playing the "time warning" song, jump to Music_StopAll

	; If we were playing the "time warning" song, we need to restart the song which was playing...
	;LDA #$10
	;STA Music_RestH_Off	; Set the rest lookup offset to $10 (should play song slightly faster!)
	LDA Music2_Hold	 	; Get which song we ought to be playing right now

	; OF NOTE: Since this jumps straight to SndMus_QueueSet2B, this prevents "time warning" from
	; working on any of the world map songs, music box, king's room, etc., places that normally
	; wouldn't get a time warning anyway.  However, exceptions are made for coin heaven and
	; invincibility, since both sit in Set 2A but ARE subject to time warning.  This behavior
	; could be fixed (and even simplified) with a minor tweak, but oh well...
	CMP #$09
	BEQ PRG031_E51B	 	; If prior song playing was Coin Heaven / Sky / etc., jump to PRG031_E51B
	CMP #$0a
	BEQ PRG031_E51B	 	; If prior song playing was Invincibility, jump to PRG031_E51B
	JMP SndMus_QueueSet2B	; Otherwise, jump to SndMus_QueueSet2B

PRG031_E4F7:
	; Segment ended on a Set 2A/B song...
	LDA SndCur_Music2
	AND #$f0	 
	BEQ PRG031_E518	 	; If we're NOT playing something from Set 2B, jump to PRG031_E518 (SndMus2A_Next)
	JMP SndMus2B_Next 	; Otherwise, jump to SndMus2B_Next

Music_StopAll:
	LDA #$00
	STA SndCur_Music1	; Stop any Set 1 song
	STA SndCur_Music2	; Stop any Set 2 song
	STA Music2_Hold	 	; Clear any hold on a Set 2 song
	;STA Music_RestH_Off	; Clear any rest lookup offset
 
	STA PAPU_EN	 ; Disable all tracks
	LDX #$0f	 
	STX PAPU_EN	 ; Enable all tracks
	RTS		 ; Return

PRG031_E518:
	JMP SndMus2A_Next ; Jump to SndMus2A_Next

PRG031_E51B
	JMP PRG031_E401	 ; Jump to PRG031_E401

PRG031_E51E:
	; Music segment byte is $80 - $ff

	; $ff is only valid after a "note on" event!
	; This is not the right time for it, so it is simply skipped over
	CMP #$ff	 
	BNE PRG031_E528	 	; If byte is NOT $ff, jump to PRG031_E528

	INC Music_Sq2TrkOff	; Music_Sq2TrkOff++
	JMP PRG031_E4CD		; Jump to PRG031_E4CD

PRG031_E528:
	TAX			 ; X = A (saving A)

	AND #$f0
	STA Music_Sq2Patch	 ; Music_Sq2Patch is just the upper 4 bits

	TXA			 ; A = X (restoring A)
	LDY #$00
	STY <CurrRestOff	; Sq2 rest offset is always 0
	JSR Music_GetRestTicks
	STA Music_Sq2RestH	 ; Update Music_Sq2RestH

PRG031_E535:
	LDY Music_Sq2TrkOff	 ; Y = Music_Sq2TrkOff

	INC Music_Sq2TrkOff	 ; Music_Sq2TrkOff++

	LDA [Music_Base_L],Y	; Get next byte from music segment data

Music_Sq2NoteOn:
	TAX			 ; X = A (saving A)
	LDA SndCur_Level1	 ; 
	BNE PRG031_E574		 ; If a "level 1" sound is playing, you can't use Square 2!

	; Level 1 sound is not playing...
	TXA			 ; A = X (restoring A)
	JSR Sound_Sq2_NoteOn_NoPAPURAMP	 ; Play this note!

	TAY		 ; Y = A -- NOTE: Sound_Sq2_NoteOn_NoPAPURAMP sets 'A' to zero if a rest note was last played!
	BNE PRG031_E550	 ; If last note was NOT a rest, jump to PRG031_E550

	; Music_LOST4FB ($04FB) apparently was some kind of note length override, but it appears to now be unused
	LDA Music_LOST4FB
	JMP PRG031_E559	 ; Jump to PRG031_E559... 

PRG031_E550:
	LDA Music_Sq2RestH
	LDX Music_LOST4FB 	; X = Music_LOST4FB (Music_CalcNoteLen is going to override it anyway though??)
	JSR Music_CalcNoteLen	; X = $82  A = $3f or $16

PRG031_E559:
	STA Music_Sq2NoteLen	; Set new note length 

	LDY Music_Sq2TrkOff	; Y = Music_Sq2TrkOff
	INC Music_Sq2TrkOff	; Music_Sq2TrkOff++
	LDA [Music_Base_L],Y	; Get next byte from music segment..
	CMP #$ff	 
	BNE PRG031_E571	 	; If value is NOT $FF, jump to PRG031_E571

	; Value was $FF!  This activates the bend effect used on a few songs
	LDA Sound_Sq2_CurFL
	STA Music_Sq2Bend
	JMP PRG031_E535	

PRG031_E571:
	; Value was not $ff, forget it...
	DEC Music_Sq2TrkOff	; Music_Sq2TrkOff--

PRG031_E574:
	LDA Music_Sq2RestH
	STA Music_Sq2Rest	; Music_Sq2Rest = Music_Sq2RestH

PRG031_E57A:
	LDA SndCur_Level1
	BNE PRG031_E5A7	 	; If we're playing any "level 1" sounds, jump to PRG031_E5A7

	LDA Music_Sq2Bend
	BEQ PRG031_E58C	 	; If no bend is active, jump to PRG031_E58C

	LDA Music_Sq2Rest	; A = rest time remaining
	LDX #$04	 	; X = 4 (Square 2)
	JSR Music_UpdateBend 	; Updates bend effects, if any

PRG031_E58C:
	LDY Music_Sq2NoteLen	; Y = Square 2's note length counter
	BEQ PRG031_E594	 	; If note length is zero, jump to PRG031_E594
	DEC Music_Sq2NoteLen	; Music_Sq2NoteLen--

PRG031_E594:
	LDA Music_Sq2RestH	; A = current rest value
	LDX Music_Sq2Patch 	; X = current "patch"
	JSR Music_PatchGetCTL 	; Gets a PAPU_CTLx value for the current patch -> A
	STA PAPU_CTL2		; Store patch value into PAPU_CTL2
	LDX #$7f
	STX PAPU_RAMP2	 	; Everything but the actual ramping
	BNE Music_Sq1Track

PRG031_E5A7:
	LDA #$00	
	STA Music_Sq2Bend	 ; When playing a level 1 sound, prevent bend effects!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Square 1's music track code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Music_Sq1Track:
	DEC Music_Sq1Rest	; Music_Sq1Rest--
	BNE PRG031_E62B	 	; If still resting, jump to PRG031_E62B

PRG031_E5B1:
	; Rest is complete!
	LDY Music_Sq1TrkOff	; Y = Music_Sq1TrkOff
	INC Music_Sq1TrkOff	; Music_Sq1TrkOff++
	LDA [Music_Base_L],Y	; Get next byte from music segment data
	BPL PRG031_E5DA	 	; If byte is $00 - $7f, jump to PRG031_E5DA 
	CMP #$ff	
	BNE PRG031_E5C5	 	; If not $ff, jump to PRG031_E5C5

	; $ff only works after a "note on" event
	INC Music_Sq1TrkOff	; Music_Sq1TrkOff++
	JMP PRG031_E5B1	 	; Get next byte...

PRG031_E5C5:
	; Byte was $80 - $fe ...
	TAX		 	; Save A
	AND #$f0		; A &= $f0 
	STA Music_Sq1Patch	; Result -> Music_Sq1Patch
	TXA		 	; Restore A (current byte of music data)
	LDY Sq1RestOff
	STY <CurrRestOff
	JSR Music_GetRestTicks
	STA Music_Sq1RestH	; Store new rest value (returned by Music_GetRestTicks)

PRG031_E5D2:
	LDY Music_Sq1TrkOff	; Y = Music_Sq1TrkOff
	INC Music_Sq1TrkOff	; Music_Sq1TrkOff++
	LDA [Music_Base_L],Y	; Get next byte from music segment...

PRG031_E5DA:
	TAY		 ; Y = A
	BNE Music_Sq1NoteOn	 ; If next byte is NOT $00, jump to Music_Sq1NoteOn

	; Next byte in segment was $00...
	; Activates a ramp effect
	LDA #$83
	STA PAPU_CTL1

	LDA #$94
	STA PAPU_RAMP1
	STA Music_Sq1AltRamp	; Music_Sq1AltRamp holds this alternate ramp value

	BNE PRG031_E5B1	 ; (technically always) jump to PRG031_E5B1

Music_Sq1NoteOn:
	; Value in range $01 - $7f
	TAX
	LDA SndCur_Player
	ORA SndCur_Map	
	BNE PRG031_E625	 ; If Player or Map sounds active, you can't play on this track!  Jump to PRG031_E625
	TXA		 ; Restore A

	JSR Sound_Sq1_NoteOn_NoPAPURAMP	; Play note!  Returns 0 if $7e rest was played...
	BNE PRG031_E601	 ; If last note was NOT a rest, jump to PRG031_E601
 
	LDA Music_LOST4FB	; A = Music_LOST4FB
	JMP PRG031_E60A	 	; Jump to PRG031_E60A...

PRG031_E601:
	LDA Music_Sq1RestH
	LDX Music_LOST4FC 	; X = Music_LOST4FC (Music_CalcNoteLen is going to override it anyway though??)
	JSR Music_CalcNoteLen	; X = $82  A = $3f or $16

PRG031_E60A:
	STA Music_Sq1NoteLen	; Set new note length 

	LDY Music_Sq1TrkOff	; Y = Music_Sq1TrkOff
	INC Music_Sq1TrkOff	; Music_Sq1TrkOff++
	LDA [Music_Base_L],Y	; Get next byte from music segment
	CMP #$ff	 
	BNE PRG031_E622	 	; If byte <> $ff, jump to PRG031_E622

	; Activate bend effects on square 1!

	; Music_Sq1Bend = Sound_Sq1_CurFL
	LDA Sound_Sq1_CurFL 
	STA Music_Sq1Bend 

	JMP PRG031_E5D2	 	; Jump to PRG031_E5D2

PRG031_E622:
	DEC Music_Sq1TrkOff	 ; Music_Sq1TrkOff--

PRG031_E625:

	; Restore Music_Sq1Rest from hold value
	LDA Music_Sq1RestH
	STA Music_Sq1Rest

PRG031_E62B:
	LDA SndCur_Player
	ORA SndCur_Map	 
	BNE PRG031_E660	 ; If playing "player" or "map" sounds, jump to PRG031_E660

	LDA Music_Sq1Bend
	BEQ PRG031_E640	 ; If Music_Sq1Bend = 0, jump to PRG031_E640

	LDX #$00	 	; X = 0 (Square 1)
	LDA Music_Sq1Rest	; A = rest time remaining
	JSR Music_UpdateBend	; Update bend effects!

PRG031_E640:
	LDY Music_Sq1NoteLen	; Y = Music_Sq1NoteLen
	BEQ PRG031_E648	 	; If Music_Sq1NoteLen = 0, jump to PRG031_E648
	DEC Music_Sq1NoteLen	; Music_Sq1NoteLen--

PRG031_E648:
	LDA Music_Sq1RestH	; A = current rest value
	LDX Music_Sq1Patch 	; X = current "patch"
	JSR Music_PatchGetCTL 	; Gets a PAPU_CTLx value for the current patch -> A
	STA PAPU_CTL1		; Store patch value into PAPU_CTL1
	LDA Music_Sq1AltRamp	
	BNE PRG031_E65B	 	; If the alternate ramp value is in effect, don't lose it!
	LDA #$7f		; Standard ramp value

PRG031_E65B:
	STA PAPU_RAMP1	 	; Use appropriate ramp value
	BNE Music_TriTrack	; (technically always) jump to Music_TriTrack

PRG031_E660:
	; "Player" or "Map" sound in effect; cancel bend effects
	LDA #$00	 
	STA Music_Sq1Bend

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Triangle's music track code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Music_TriTrack:
	LDA <Music_TriTrkHi	; Music_TriTrackHi
	BEQ Music_NseTrack	; If Music_TriTrackHi = 0 (Disabled!), jump to Music_NseTrack

	DEC Music_TriRest	; Music_TriRest--
	BNE Music_NseTrack	; If not done resting, jump to the noise track

	LDY #$00
	LDA [Music_TriTrkLo],Y	; Get next byte from triangle track
	INC <Music_TriTrkLo
	BNE _tri_post_inc
	INC <Music_TriTrkHi
_tri_post_inc:
	CMP #$00			; compare the byte we read to 0

	BPL Music_TriNoteOn	; Byte $00 - $7f, jump to Music_TriNoteOn

	; Byte $80 - $ff... goes directly to the rest value routine
	; No "patches" available on the triangle track
	LDY TriRestOff
	STY <CurrRestOff
	JSR Music_GetRestTicks	
	STA Music_TriRestH		; Update rest hold value

	LDA #$1f	 
	STA PAPU_TCR1	 ; $1f written to PAPU_TCR1

	LDY #$00
	LDA [Music_TriTrkLo],Y	; Get next byte from triangle track
	INC <Music_TriTrkLo
	BNE _tri_post_inc2
	INC <Music_TriTrkHi
_tri_post_inc2:
	CMP #$00			; compare the byte we read to 0
	BEQ PRG031_E6B4	 	; If $00 came up, jump to PRG031_E6B4

Music_TriNoteOn:
	; Triangle track, value $00 - $7f
	JSR Sound_Tri_NoteOn	; Play note!  (Will return $00 if $7e rest was played)
	BEQ PRG031_E6B2	 	; If last note was a rest, jump to PRG031_E6B2 

	LDA Music_TriRestH
	CMP #$0a
	BLT PRG031_E6A6	 ; If Music_TriRestH < $0A, jump to PRG031_E6A6 (A = $18)
	CMP #$13
	BLT PRG031_E6AA	 ; If Music_TriRestH < $13, jump to PRG031_E6AA (A = $20)
	CMP #$25
	BGE PRG031_E6AE	 ; If Music_TriRestH >= $25, jump to PRG031_E6AE (A = $ff)

	; Music_TriRestH >= $13 && Music_TriRestH < $25
	LDA #$50
	BNE PRG031_E6B4	 ; (technically always) jump to PRG031_E6B4

PRG031_E6A6:
	LDA #$18
	BNE PRG031_E6B4	 ; (technically always) jump to PRG031_E6B4

PRG031_E6AA:
	LDA #$20
	BNE PRG031_E6B4	 ; (technically always) jump to PRG031_E6B4

PRG031_E6AE:
	LDA #$ff
	BNE PRG031_E6B4	 ; (technically always) jump to PRG031_E6B4

PRG031_E6B2:
	LDA #$80

PRG031_E6B4:
	STA PAPU_TCR1	 	; Start (if note played) or Stop (if $00 after $80-$ff) the triangle sound
	LDX Music_TriRestH
	STX Music_TriRest	; Music_TriRest = Music_TriRestH


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Noise's music track code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Music_NseTrack:
	LDA <Music_NSETrkHi	; Music_NseTrack 
	BEQ Music_PCMTrack	; If Music_NseTrack = 0 (disabled), jump to Music_PCMTrack

	DEC Music_NoiseRest	; Music_NoiseRest--
	BNE Music_PCMTrack	; If track is not done resting, just jump to Music_PCMTrack
 
PRG031_E6C7:
	LDY #$00
	LDA [Music_NSETrkLo],Y
	INC <Music_NSETrkLo
	BNE _nse_post_inc
	INC <Music_NSETrkHi
_nse_post_inc:
	CMP #$00			; compare the byte we read to 0

	BEQ PRG031_E700	 	; If next byte is $00, jump to PRG031_E700
	BPL Music_NseNoteOn 	; $01 - $7f is note on, jump to Music_NseNoteOn

	; Byte $80 - $ff... goes directly to the rest value routine
	; No "patches" available on the noise track
	LDY NseRestOff
	STY <CurrRestOff
	JSR Music_GetRestTicks
	STA Music_NseRestH	 ; Update rest hold

	LDY #$00
	LDA [Music_NSETrkLo],Y
	INC <Music_NSETrkLo
	BNE _nse_post_inc2
	INC <Music_NSETrkHi
_nse_post_inc2:
	CMP #$00			; compare the byte we read to 0
	BEQ PRG031_E700	 	; If byte $00 comes up, jump to PRG031_E700

Music_NseNoteOn:
	; Noise isn't really a "note" event, but it has a LUT for a "note" value...
	LSR A		 	; Shift in half (because notes are usually a 2-byte index)
	TAY		 	; Y = A

	; Note that the normal $7E Note Off is not implemented here; instead, use $01

	; Plug in appropriate noise values for this "note"
	LDA Music_NoiseLUTA,Y
	STA PAPU_NCTL1	 	
	LDA Music_NoiseLUTB,Y	
	STA PAPU_NFREQ1	 	
	LDA Music_NoiseLUTC,Y	
	STA PAPU_NFREQ2		

	; Reset rest value
	LDA Music_NseRestH
	STA Music_NoiseRest


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DMC's music track code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Music_PCMTrack:
	JMP PRG031_E709

PRG031_E700:
	; When byte $00 read, Reset noise track to start
	LDA Music_NseStartLo
	STA <Music_NSETrkLo
	LDA Music_NseStartHi
	STA <Music_NSETrkHi
	JMP PRG031_E6C7	 ; Back into the fray...

PRG031_E709:
	LDA <Music_PCMTrkHi
	BEQ PRG031_E738	 	; If Music_PCMTrkPos = 0 (disabled), jump to PRG031_E738

	DEC Music_DMCRest	; Music_DMCRest--
	BNE PRG031_E738	 	; If not done resting, jump to PRG031_E738

PRG031_E713:
	LDY #$00
	LDA [Music_PCMTrkLo],Y
	INC <Music_PCMTrkLo
	BNE _pcm_post_inc
	INC <Music_PCMTrkHi
_pcm_post_inc:
	CMP #$00			; compare the byte we read to 0
	BEQ PRG031_E741		; If next byte is $00, jump to PRG031_E741
	BPL PRG031_E72F		; If byte is $01 - $7f, jump to PRG031_E72F

	LDY PCMRestOff
	STY <CurrRestOff
	JSR Music_GetRestTicks
	STA Music_DMCRestH	; Update rest hold value

	LDY #$00
	LDA [Music_PCMTrkLo],Y
	INC <Music_PCMTrkLo
	BNE _pcm_post_inc2
	INC <Music_PCMTrkHi
_pcm_post_inc2:
	CMP #$00			; compare the byte we read to 0
	BEQ PRG031_E741	 	; If next byte is $00, jump to PRG031_E741

PRG031_E72F:
	STA DMC_Queue	 	; Store note into DMC queue
	LDA Music_DMCRestH	
	STA Music_DMCRest	; Music_DMCRest = Music_DMCRestH

PRG031_E738:
	JSR Music_PlayDMC	 ; Play DMC sound!

	LDA #$00	 
	STA DMC_Queue	 ; Clear the DMC queue
	RTS		 ; Return

PRG031_E741:
	; When byte $00 read, reset DMC track to start
	LDA Music_PCMStartLo
	STA <Music_PCMTrkLo
	LDA Music_PCMStartHi
	STA <Music_PCMTrkHi
	JMP PRG031_E713	 	; Back into the fray...


	; Noise track values per "note"; the note is shifted down by 1,
	; (because for other channels, note is a 2-byte lookup, but here it is
	; only 1.) The first note value is $01 (which shifted becomes zero),
	; so basically $01, $02-$03, $04-$05, $06-$07 are the only valid "notes"
	; $01 (first triple) is used as a "rest" / Note Off
Music_NoiseLUTA:	.byte $10, $17, $18, $19	; ctl
Music_NoiseLUTB:	.byte $00, $03, $0A, $06	; freq1
Music_NoiseLUTC:	.byte $00, $18, $18, $48	; freq2 ($18 = 3, $58 = 11, $48 = 9)

	; ctl is $400C			--LC.VVVV	Noise channel volume/envelope (write)
	; bit 5		--L- ----	APU Length Counter halt flag/envelope loop flag
	; bit 4		---C ----	Constant volume flag (0: use volume from envelope; 1: use constant volume)
	; bits 3-0	---- VVVV	Used as the volume in constant volume (C set) mode. Also used as the reload value for the envelope's divider (the period becomes V + 1 quarter frames).

	; freq1 is $400E	M---.PPPP	Mode and period (write)
	; Period setting	Sample rate	Fundamental	MIDI note	Pitch
	; $0	447443.2 Hz	4811.2 Hz	110.41	d'''''
	; $1	223721.6 Hz	2405.6 Hz	98.41	d''''
	; $2	111860.8 Hz	1202.8 Hz	86.41	d'''
	; $3	55930.4 Hz	601.4 Hz	74.41	d''
	; $4	27965.2 Hz	300.7 Hz	62.41	d'
	; $5	18643.5 Hz	200.5 Hz	55.39	g
	; $6	13982.6 Hz	150.4 Hz	50.41	d
	; $7	11186.1 Hz	120.3 Hz	46.55	a#,
	; $8	8860.3 Hz	95.3 Hz	42.51	f#,
	; $9	7046.3 Hz	75.8 Hz	38.55	d,
	; $A	4709.9 Hz	50.6 Hz	31.57	g,,
	; $B	3523.2 Hz	37.9 Hz	26.55	d,,
	; $C	2348.8 Hz	25.3 Hz	19.53	g,,,
	; $D	1761.6 Hz	18.9 Hz	14.55	d,,,
	; $E	879.9 Hz	9.5 Hz	2.53	d,,,,
	; $F	440.0 Hz	4.7 Hz	-9.47	d,,,,,

	; freq2 is $400F	llll.l---	Length counter load and envelope restart (write)


Music_CalcNoteLen:
	; Just played a note which was not a rest
	; A = current time between events (RestH)

	CMP #19
	BLT PRG031_E75E	 ; If A < 19, jump to PRG031_E75E (use A = $16)
	LDA #$3f	 ; Otherwise, use A = $3F
	BNE PRG031_E760	 ; (technically always) jump to PRG031_E760

PRG031_E75E:
	LDA #$16

PRG031_E760:

	; These values appear to be unused??
	LDX #$82
	LDY #$7f

	RTS		 ; Return


Music_PatchTableLong:	; playing notes greater than 19 in length
	.word PatL1, PatL2, PatL3, PatL4, PatL5, PatL6, PatL2, PatL8

Music_PatchTableShort:	; shorter notes
	.word PatS1, PatS2, PatS3, PatS4, PatS5, PatS6, PatS2, PatS8

Music_PatchGetCTL:
	; A = Rest hold value (< 19 considered "short" patches)
	; X = Patch #
	; Y = Note length

	PHA		 ; Save A

	; X = (X & $70) >> 3
	; This takes the lower 3 bits of the upper nibble in the
	; patch value to make an index into the patch table...
	; This amounts to the value $0, $2, $4, $6, $8, $A, $E, $10
	TXA
	AND #$70
	LSR A
	LSR A
	LSR A
	TAX

	PLA		 ; Restore A

	CMP #19	
	BLT PRG031_E79E	 ; If rest value < 19, jump to PRG031_E79E

	; Music playing not too quickly uses the "long" set

	; Copy address for this patch from the LUT to [Music_PatchAdrH][Music_PatchAdrL]
	LDA Music_PatchTableLong,X
	STA <Music_PatchAdrL
	LDA Music_PatchTableLong+1,X
	STA <Music_PatchAdrH

	BNE PRG031_E7A8	 ; (technically always) jump to PRG031_E7A8

PRG031_E79E:
	; Music playing "rapidly" uses the "short" set

	; Copy address for this patch from the LUT to [<Music_PatchAdrH][<Music_PatchAdrL]
	LDA Music_PatchTableShort,X
	STA <Music_PatchAdrL
	LDA Music_PatchTableShort+1,X
	STA <Music_PatchAdrH

PRG031_E7A8:
	; In any case, current note length selects a value from the patch data...
	LDA [Music_PatchAdrL],Y	
	RTS		 


	; Quick and dirty function that writes X to the CTL and Y to the RAMP of Square 1
Sound1_XCTL_YRAMP:
	STY PAPU_RAMP1
	STX PAPU_CTL1
	RTS		 ; Return

	; Quick and dirty function that writes X to the CTL and Y to the RAMP of Square 2
Sound2_XCTL_YRAMP:
	STX PAPU_CTL2
	STY PAPU_RAMP2
	RTS		 ; Return

Sound_Sq1_NoteOn:
	; Note On event for Square 1
	; 'A' is input note to play
	STX PAPU_CTL1
	STY PAPU_RAMP1

Sound_Sq1_NoteOn_NoPAPURAMP:
	LDX #$00

PRG031_E7C1:
	CMP #$7e	 
	BNE PRG031_E7C8	 ; If note <> $7E, jump to PRG031_E7C8

	; If note is $7E (rest), then we're done!
	LDA #$00	; To alert music system we just played a "rest"
	RTS		; Return

PRG031_E7C8:
	LDY #$01
	STY Sound_Octave ; Sound_Octave = 1 (interestingly, this sets a "center octave", so at 0 everything is lower, at 2 everything is higher...)
	PHA		 ; Save original note
	TAY		 ; Y = Note
	BMI PRG031_37D9	 ; If Note & $80, skip the octave adjust??

	; Note:
	; Notes are stored as double value for convenience here (spares a shift)
	; So "24" is an entire octave for doubled note values, get it?

	; The following loop transforms a note into a relative 
	; "octave lookup" for the note base frequency; essentially,
	; this is (Note MOD 12), just no such instruction available
PRG031_E7D1:
	INC Sound_Octave ; Sound_Octave++ (Sound_Octave will have the octave level after this, essentially Note / 12)
	SUB #24	 	  ; A -= 24 (down an octave)
	BPL PRG031_E7D1	  ; While above zero, loop! 

PRG031_37D9:
	ADD #24	 	  ; A += 24 (recover from last subtraction)
	TAY		  ; Y = A (Y is now the offset into the LUT to get the base frequency for this note)

	; Y should now be a lookup into the note table!
	; Store this resultant frequency into Sound_Sqr_FreqL/H
	LDA Square1_Table_Notes,Y
	STA <Sound_Sqr_FreqL		
	LDA Square1_Table_Notes+1,Y
	STA <Sound_Sqr_FreqH		

	; Sound_Octave now holds the octave level
	; This loops to adjust the base frequency to the proper octave
PRG031_E7E7:
	LSR <Sound_Sqr_FreqH	
	ROR <Sound_Sqr_FreqL	
	DEC Sound_Octave	; Sound_Octave--
	BNE PRG031_E7E7	 ; While Sound_Octave > 0, loop!

	PLA		 ; Retrieve original note
	CMP #56		 ; 
	BCC PRG031_E7F7	 ; If note is less than 56, skip the decrement
	DEC <Sound_Sqr_FreqL	 ; Minor adjustment to resultant frequency?
PRG031_E7F7:
	TXA		 ; A = X  (0 = square 1, 4 = square 2)
	CMP #$04	 ;  
	BNE PRG031_E808	 ; If on Square 1, jump to PRG031_E808

	; Square 2 only...
	LDA Music_Sq1Patch
	CMP #$e0	 ; 
	BEQ PRG031_E818	 ; If Music_Sq1Patch = $E0, jump to PRG031_E818 (some alternate SQ2 routine??)

	LDA Music_Sq1Bend,X	
	BNE PRG031_E851	 	; If bend in effect on this track, jump to PRG031_E851

PRG031_E808:
	; This is used by Square 1/2 or triangle
	; 'X' is 0 (Square 1), 4 (Square 2), 8 (Triangle)

	LDA <Sound_Sqr_FreqL
	STA PAPU_FT1,X	 ; Store low part of frequency in appropriate register
	STA Sound_Sq1_CurFL,X	 ; Store low frequency in appropriate backup variable

	LDA <Sound_Sqr_FreqH
	ORA #$08	 ; Sets sort of a minimal frequency level
	STA PAPU_CT1,X	 ; Store high frequency in appropriate register
	RTS		 ; Return

PRG031_E818:
	; For Square Wave 2 only!
	LDA <Sound_Sqr_FreqL
	SUB #$02	 	; Sound_Sqr_FreqL -= 2
	STA PAPU_FT2	 	; Store low part of frequency in register
	STA Sound_Sq2_CurFL

	LDA <Sound_Sqr_FreqH
	ORA #$08	 ; Sets sort of a minimal frequency level
	STA PAPU_CT2	 ; Store high frequency in register

	RTS		 ; Return

Sound_Sq2_NoteOn:
	; Note On event for Square 2
	; 'A' is input note to play
	STX PAPU_CTL2
	STY PAPU_RAMP2

Sound_Sq2_NoteOn_NoPAPURAMP:
	LDX #$04	 ; Offset from Square 1 regs to Square 2
	BNE PRG031_E7C1	 ; Common waveform routine

Sound_Tri_NoteOn:
	LDX #$08	 ; Offset from Square 1 regs to Triangle
	BNE PRG031_E7C1	 ; Common waveform routine

	; 12 notes LUT for Square Wave channels
Square1_Table_Notes:
	.word $1AB8, $1938, $17CC, $1678, $1534, $1404, $12E4, $11D4, $10D4, $0FE0, $0EFC, $0E24

PRG031_E851:
	; If bend is in effect, this stores the last set frequency
	LDA <Sound_Sqr_FreqL
	STA Sound_Sq1_CurFL,X
	RTS

Music_UpdateBend:
	; A = rest time remaining
	; X = 0 or 4, Square 1 or 2

	; Basically if (rest & 3) <> 3, jump to PRG031_E860
	LSR A
	BCC PRG031_E860
	LSR A	
	BCC PRG031_E860

	; Diminish the bend
	DEC Music_Sq1Bend,X

PRG031_E860:
	LDA Music_Sq1Bend,X 	; Get current bend
	CMP Sound_Sq1_CurFL,X	; Compare to current frequency 
	BGE PRG031_E870		; If bend >= Sound_Sq1_CurFL, jump to PRG031_E870

	LDA #$00	 	
	STA Music_Sq1Bend,X	; Clear/disable bend
	LDA Sound_Sq1_CurFL,X	; Just get current frequency

PRG031_E870:
	STA PAPU_FT1,X	 ; Update PAPU_FT1/2!
	RTS		 ; Return


;;; [ORANGE] Moved the rest lookup table to prg029.asm

FALLRATE_SPIN = $20
FallrateHook:
	LDA <Player_Regrabbing
	BMI _compare_normal
	BEQ _compare_normal
	LDA <Player_YVel
	CMP #FALLRATE_SPIN
	BMI _j_apply_vel		; we're < FALLRATE_SPIN, just apply the velocity
	; we're regrabbing and > FALLRATE_SPIN, cap it
	LDA #FALLRATE_SPIN
	STA <Player_YVel
	BNE _j_apply_vel		; jmp always to _j_apply_vel
_compare_normal:
	LDA <Player_YVel
	CMP #FALLRATE_MAX
	BPL _j__cap_fallrate_max
_j_apply_vel:
	JMP PRG008_BFF9			; apply velocities
_j__cap_fallrate_max:
	JMP _cap_fallrate_max


Player_TryHoldShell:
	LDA Player_Regrabbing
	BMI _normal_hold
	BNE _j_Player_KickObject	; If we're regrabbing, kick the object away
_normal_hold:
	BIT <Pad_Holding
	BVS _j_PRG000_D34F		; If Player is holding B, jump to PRG000_D34F
_j_Player_KickObject:
	JMP Player_KickObject		; Kick away the object and don't come back!
_j_PRG000_D34F:
	JMP PRG000_D34F

DoNotMidair:
	; Once we hit the ground, we can regrab again
	LDA #$00
	STA <Player_InAir
	STA <Player_Regrabbing
	RTS

DoBounceYVel:
	LDA Level_ObjectID,X
	CMP #OBJ_PARATROOPAGREENHOP
	BEQ _do_green_vel
	CMP #OBJ_REDTROOPA
	BEQ _do_red_vel
	CMP #OBJ_SPINY
	BNE _norm_bounce_vel
_do_spiny_vel:
	LDA #$10
	STA <Objects_XVel,X
	BNE __neg30rts
_do_red_vel:
	LDA #$0e
	STA <Objects_XVel,X
__neg30rts:
	LDA #-$30
	STA <Objects_YVel,X
	RTS
_do_green_vel:
	LDA #-$53
	STA <Objects_YVel,X
	RTS
_norm_bounce_vel:
	LDA #-$30
	STA <Objects_YVel,X
	JSR Level_ObjCalcXDiffs		; Detect which side object is on versus Player
	; Store proper X velocity
	LDA PRG000_D16B,Y
	STA <Objects_XVel,X
	RTS

.mother1_align: DMCAlign .mother1_align
DMC_MOTHER1:
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $B6, $42, $04, $00, $00, $00, $00, $00, $20, $49, $B5, $AA, $AA, $4A, $24, $01, $51, $DA, $B6, $AA, $6D, $F7, $FF, $FF, $FF
	.byte $FF, $FF, $F6, $76, $DB, $AB, $55, $A5, $44, $10, $20, $00, $00, $04, $08, $90, $28, $51, $AA, $5A, $B5, $6D, $7B, $F7, $EE, $DD, $B7, $77, $5B, $5B, $B5, $52
	.byte $49, $12, $12, $09, $12, $22, $49, $48, $A5, $2A, $55, $65, $B5, $B5, $AD, $B6, $6D, $DB, $B6, $6D, $DB, $B6, $B5, $AD, $D6, $AA, $2A, $55, $4A, $A5, $24, $49
	.byte $2A, $09, $95, $A2, $54, $49, $53, $B5, $44, $6A, $D5, $6A, $AD, $D6, $44, $00, $AB
DMC_MOTHER1_End

.mother2_align: DMCAlign .mother2_align
DMC_MOTHER2:
	.byte $FF, $B7, $20, $0B, $00, $00, $00, $00, $C0, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $00, $00, $00, $00, $00, $00, $C0, $0B, $00, $00, $80, $FD, $FF, $FF, $FF
	.byte $FF, $FF, $FF, $FF, $FF, $17, $00, $00, $00, $00, $00, $00, $00, $F0, $FF, $FF, $FF, $FF, $FF, $7E, $51, $ED, $44, $81, $10, $01, $82, $18, $2B, $42, $53, $81
	.byte $6F, $D8, $DB, $EB, $E7, $BF, $EB, $1F, $FB, $95, $24, $48, $00, $02, $00, $E0, $C5, $C0, $BF, $F8, $FF, $FF, $BA, $0E, $7E, $C4, $50, $68, $2A, $56, $02, $6F
	.byte $77, $4E, $F8, $45, $95, $20, $56, $50, $63, $3F, $F4, $FF, $F0, $9D, $F8, $21, $B2, $20, $8E, $0D, $18, $CF, $82, $AF, $8A, $E3, $3F, $78, $FD, $18, $CE, $02
	.byte $87, $58, $E0, $C4, $47, $E9, $DF, $F1, $53, $3B, $8A, $97, $38, $08, $A9, $03, $DE, $E2, $F8, $0F, $9E, $EC, $89, $B2, $07, $38, $E2, $63, $F1, $E3, $C3, $7B
    .byte $42, $AF, $28, $8E, $2A, $8E, $42, $83, $5A, $1D, $FA, $B1, $EB, $AB, $D6, $62, $DA, $A1, $E2, $D0, $34, $9C, $85, $8E, $AE, $C4, $7A, $72, $1D, $A6, $55, $1C
	.byte $B9, $52, $3D, $8B, $9E, $9D, $4E, $96, $2A, $0B, $E2, $A8, $A4, $95, $2D, $BB, $72, $AD, $F4, $91, $5A, $8B, $52, $25, $4E, $9C, $5A, $79, $6A, $D7, $A4, $8E
	.byte $9C, $74, $B0, $A2, $B4, $89, $67, $35, $6D, $2B, $37, $B6, $45, $A5, $A9, $C5, $A4
DMC_MOTHER2_End

.gradius1_align: DMCAlign .gradius1_align
DMC_GRADIUS1:
	.byte $AA, $AA, $AA, $AA, $AA, $AF, $F0, $9E, $9F, $F0, $06, $AE, $7C, $1B, $98, $F0, $00, $03, $00, $0C, $01, $CE, $01, $80, $00, $00, $00, $00, $00, $0F, $1F, $FF
	.byte $FB, $F3, $CF, $F3, $EF, $DE, $B8, $F9, $A6, $A2, $24, $39, $81, $43, $80, $86, $19, $02, $38, $51, $87, $86, $15, $39, $8C, $A6, $55, $4D, $16, $8C, $A3, $45
	.byte $45, $90, $CA, $56, $22, $52, $70, $D6, $53, $16, $D3, $54, $D7, $4B, $37, $4B, $5B, $6B, $56, $CE, $B5, $5B, $5D, $59, $B6, $D5, $AB, $D6, $B5, $D7, $6B, $6D
	.byte $AD, $AE, $B6, $D6, $B5, $B5, $AA, $D6, $AA, $AC, $AA, $A9, $54, $A9, $94, $A4, $A9, $4A, $4A, $8A, $92, $54, $A5, $49, $29, $4A, $54, $A5, $29, $52, $A5, $4A
	.byte $A5, $54, $A9, $54, $AA, $95, $2A, $AA, $94, $95, $2A, $AA, $55, $55, $2A, $56, $66, $AA, $9A, $AA, $B5, $5A, $AD, $AB, $5A, $B5, $6B, $6B, $6B, $5A, $B5, $AA
	.byte $B5, $56, $AA, $D5, $55, $56, $AA, $AA, $AA, $AA, $AA, $AA, $AA, $95, $55, $55, $B5, $56, $AA, $D5, $55, $56, $AA, $AA, $AA, $AA, $AA, $AA, $AA, $95, $55, $55
	.byte $AD
DMC_GRADIUS1_End

.dmc_orb_align: DMCAlign .dmc_orb_align
DMC_ORB:
	.byte $55, $55, $55, $55, $65, $D5, $AA, $AA, $D2, $D4, $D5, $94, $00, $81, $EF, $FF, $DF, $02, $02, $25
	.byte $97, $85, $A3, $5F, $FF, $57, $01, $03, $4B, $15, $01, $00, $FE, $FF, $FF, $1F, $00, $00, $9C, $8F
	.byte $0F, $FF, $FF, $FF, $0F, $00, $00, $00, $00, $E0, $FF, $FF, $FF, $03, $00, $00, $E0, $FF, $FF, $FF
	.byte $FF, $0F, $00, $00, $00, $00, $E0, $FF, $FF, $FF, $01, $00, $00, $F0, $FF, $FF, $FF, $FF, $07, $00
	.byte $00, $00, $00, $E0, $FF, $FF, $FF, $03, $00, $00, $F3, $E7, $FF, $FF, $FF, $03, $00, $00, $00, $00
	.byte $C0, $FF, $FF, $FF, $1F, $00, $00, $FC, $FC, $FE, $FF, $FF, $27, $00, $00, $04, $00, $00, $E0, $FF
	.byte $FF, $FF, $1F, $00, $40, $BD, $7A, $F9, $FF, $FF, $2B, $00, $A0, $14, $01, $00, $00, $FF, $FF, $FF
	.byte $3F, $00, $00, $E7, $E3, $C3, $FF, $FF, $5F, $01, $00, $4B, $49, $00, $00, $E0, $FF, $FF, $FF, $03
	.byte $00, $E0, $7B, $3C, $FA, $FB, $FF, $13, $40, $60, $D9, $0A, $00, $00, $F0, $FF, $FF, $FF, $01, $00
	.byte $F8, $3C, $36, $FB, $F7, $EF, $20, $20, $DA, $DD, $12, $00, $00, $00, $FF, $FF, $FF, $0F, $00, $86
	.byte $97, $46, $AB, $BF, $FF, $2F, $02, $85, $AE, $96, $00, $00, $00, $F0, $FF, $FF, $FF, $03, $C0, $E0
	.byte $B1, $B4, $FA, $EB, $FF, $47, $60, $60, $A5, $45, $04, $00, $00, $FE, $FF, $FF, $3F, $02, $10, $7C
	.byte $2C, $9B, $FE, $FE, $7F, $08, $0C, $BA, $B8, $08, $01, $00, $80, $FF, $FF, $FF, $1F, $00, $0C, $1E
	.byte $CB, $EA, $B7, $FF, $3E, $84, $42, $2D, $36, $08, $00, $00, $F0, $FF, $FF, $FF, $07, $00, $C1, $C7
	.byte $6A, $FA, $ED, $BF, $8F, $50, $C2, $86, $0B, $02, $00, $00, $FC, $FF, $FF, $FF, $00, $60, $F0, $54
	.byte $AD, $F6, $FB, $FF, $21, $28, $D4, $E1, $02, $01, $00, $00, $FF, $FF, $FF, $3F, $00, $0C, $3C, $D5
	.byte $AA, $7F, $FE, $3F, $21, $0A, $6D, $B8, $40, $00, $00, $E0, $FF, $FF, $FF, $07, $00, $83, $47, $AD
	.byte $DA, $AF, $FF, $8F, $90, $42, $17, $1E, $10, $00, $00, $F8, $FF, $FF, $FF, $01, $C0, $E0, $51, $2B
	.byte $F7, $EB, $FF, $23, $24, $D1, $C3, $05, $01, $00, $00, $FC, $FF, $FF, $FF, $01, $20, $F0, $D1, $CA
	.byte $F6, $FB, $EF, $83, $12, $B2, $E1, $41, $01, $00, $00, $FE, $FF, $FF, $FF, $00, $20, $78, $B8, $C9
	.byte $ED, $FD, $F7, $91, $22, $72, $E1, $C1, $00, $00, $00, $FC, $FF, $FF, $FF, $01, $00, $F8, $B8, $CA
	.byte $F5, $F5, $FF, $51, $22, $D1, $E2, $A1, $10, $00, $00, $F8, $FF, $FF, $FF, $01, $40, $F0, $B8, $CA
	.byte $F5, $F5, $FF, $25, $11, $D1, $E2, $A1, $10, $00, $00, $F0, $FF, $FF, $FF, $07, $00, $E0, $D5, $AA
	.byte $D6, $F7, $DF, $A7, $88, $44, $E3, $49, $41, $00, $00, $E0, $FF, $FF, $FF, $0F, $00, $C0, $D5, $9A
	.byte $56, $DF, $FF, $57, $12, $11, $8B, $47, $45, $00, $00, $00, $FF, $FF, $FF, $7F, $00, $00, $5E, $6D
	.byte $59, $7D, $FD, $FF, $A4, $20, $34, $BA, $4C, $02, $00, $00, $F0, $FF, $FF, $FF, $03, $40, $70, $AD
	.byte $C6, $E5, $DB, $FF, $4F, $12, $C2, $E2, $AA, $24, $00, $00, $00, $FF, $FF, $FF, $3F, $00, $08, $3E
	.byte $75, $5C, $7E, $FD, $FF, $28, $21, $2C, $6E, $4A, $02, $00, $00, $F0, $FF, $FF, $FF, $07, $00, $C0
	.byte $97, $AB, $E6, $D7, $FF, $97, $14, $22, $8B, $97, $14, $04, $00, $00, $FC, $FF, $FF, $FF, $01, $00
	.byte $78, $E9, $6A, $F5, $F5, $FF, $45, $11, $D1, $E8, $49, $05, $00, $00, $80, $FF, $FF, $FF, $3F, $00
	.byte $00, $9F, $76, $5A, $5F, $FF, $7E, $A2, $10, $56, $5E, $AA, $04, $00, $00, $C0, $FF, $FF, $FF, $1F
	.byte $00, $80, $A7, $5E, $56, $9F, $FF, $9F, $18, $84, $16, $9F, $36, $08, $00, $00, $C0, $FF, $FF, $FF
	.byte $1F, $00, $80, $A7, $5D, $AE, $67, $FF, $2F, $1A, $88, $46, $AF, $9B, $10, $00, $00, $80, $FF, $FF
	.byte $FF, $3F, $00, $00, $AB, $5E, $2E, $5F, $7F, $3F, $1A, $48, $46, $AF, $5B, $14, $00, $00, $00, $FE
	.byte $FF, $FF, $FF, $00, $00, $AC, $BA, $DA, $7C, $FD, $FD, $A4, $20, $2A, $7D, $DD, $22, $01, $00, $00
	.byte $C0, $FF, $FF, $FF, $1F, $00, $40, $53, $4F, $D7, $D7, $DF, $4F, $0A, $A2, $D2, $D7, $2E, $12, $00
	.byte $00, $00, $FC, $FF, $FF, $FF, $13, $00, $40, $E9, $75, $7D, $F5, $F7, $A3, $10, $B1, $F4, $76, $93
	.byte $20, $00, $00, $00, $FE, $FF, $FF, $FF, $03, $00, $50, $DA, $BA, $7D, $FD, $FE, $A8, $20, $34, $DE
	.byte $F6, $92, $00, $00, $00, $00, $FF, $FF, $FF, $FF, $03, $00, $50, $EC, $7A, $7D, $FD, $FD, $A8, $40
	.byte $A8, $FA, $F6, $29, $08, $00, $00, $00, $FE, $FF, $FF, $FF, $17, $00, $00, $E4, $F5, $7D, $FD, $F7
	.byte $C2, $40, $50, $ED, $FB, $55, $01, $00, $00, $00, $F8, $FF, $FF, $FF, $3F, $00, $00, $A0, $E7, $FB
	.byte $FD, $B7, $87, $02, $50, $D5, $BF, $DF, $04, $00, $00, $00, $C0, $FF, $FF, $FF, $FF, $00, $00, $00
	.byte $AF, $EF, $EF, $7F, $1B, $01, $02, $55, $FF, $FF, $0B, $01, $00, $00, $00, $FC, $FF, $FF, $FF, $03
	.byte $00, $00, $BA, $7E, $FF, $FE, $57, $02, $00, $58, $FD, $FF, $7F, $00, $00, $00, $00, $E0, $FF, $FF
	.byte $FF, $2F, $00, $00, $70, $EB, $FF, $FF, $BB, $40, $00, $80, $FA, $FF, $FF, $07, $00, $00, $00, $00
	.byte $FE, $FF, $FF, $FF, $00, $00, $40, $BF, $FE, $BF, $BF, $13, $00, $00, $AC, $FF, $FF, $3F, $04, $00
	.byte $00, $00, $E0, $FF, $FF, $FF, $07, $00, $00, $DD, $EF, $F7, $FF, $55, $00, $00, $C0, $FF, $FF, $FF
	.byte $03, $00, $00, $00, $00, $F8, $FF, $FF, $FF, $01, $00, $F0, $FA, $7D, $FF, $BF, $02, $00, $00, $F8
	.byte $FF, $FF, $3F, $00, $00, $00, $00, $C0, $FE, $FF, $FF, $7F, $00, $00, $7C, $B7, $FD, $FF, $1F, $00
	.byte $00, $40, $FD, $FF, $FF, $17, $00, $08, $10, $00, $80, $FB, $FF, $FF, $7F, $00, $00, $DB, $EA, $DB
	.byte $FF, $3F, $01, $00, $80, $FF, $FD, $FF, $36, $00, $40, $50, $02, $00, $E0, $FF, $FF, $FF, $07, $00
	.byte $9A, $3A, $EA, $FF, $FF, $03, $00, $00, $7F, $EB, $BF, $FF, $09, $00, $10, $4B, $02, $00, $E0, $FF
	.byte $FF, $FF, $00, $70, $0B, $D0, $FD, $FF, $7F, $00, $00, $56, $75, $55, $FF, $FF, $43, $00, $54, $A1
	.byte $10, $00, $C0, $FF, $FF, $FF, $81, $40, $90, $A0, $FF, $FF, $7F, $00, $20, $AA, $92, $FD, $FF, $FF
	.byte $00, $28, $1A, $0B, $01, $00, $00, $FE, $FF, $FF, $1F, $14, $00, $0B, $ED, $FF, $FF, $07, $00, $94
	.byte $B0, $BE, $FF, $FF, $11, $08, $49, $93, $10, $49, $00, $80, $FF, $FF, $FF, $03, $2A, $01, $A8, $FE
	.byte $FF, $7F, $00, $40, $36, $91, $FE, $FF, $9B, $84, $EA, $2A, $44, $52, $48, $02, $00, $F8, $FF, $FF
	.byte $1F, $B0, $02, $00, $FF, $FF, $FF, $00, $54, $40, $52, $FD, $FF, $0F, $54, $D7, $AA, $40, $B4, $15
	.byte $01, $00, $00, $FF, $FF, $FF, $0F, $50, $02, $C0, $FF, $FF, $7F, $00, $28, $01, $DC, $FF, $FF, $0A
	.byte $64, $6F, $11, $A9, $2A, $4A, $00, $00, $C0, $FF, $FF, $FF, $07, $10, $00, $F4, $FF, $FF, $27, $04
	.byte $11, $82, $FC, $FF, $2F, $52, $AA, $6D, $89, $74, $1B, $02, $12, $01, $00, $FC, $FF, $FF, $3F, $42
	.byte $00, $80, $FF, $FF, $1F, $95, $88, $00, $F2, $FF, $3F, $A4, $6D, $29, $55, $B5, $2A, $41, $80, $04
	.byte $00, $F8, $FF, $FF, $FF, $01, $00, $00, $FF, $FF, $9F, $BD, $02, $00, $F0, $FF, $3F, $A8, $BE, $02
	.byte $F4, $DF, $44, $91, $00, $00, $00, $C0, $FF, $FF, $FF, $7F, $00, $00, $F0, $FF, $7F, $FE, $07, $00
	.byte $80, $AF, $F7, $EB, $F5, $00, $C0, $FF, $05, $EC, $06, $00, $00, $00, $FE, $FF, $FF, $FF, $03, $00
	.byte $80, $FF, $FF, $F9, $1F, $00, $00, $1E, $EC, $FF, $9F, $02, $41, $FF, $11, $E8, $1F, $00, $00, $00
	.byte $E0, $FF, $FF, $FF, $1F, $00, $00, $FE, $FF, $CF, $FF, $00, $00, $A8, $C0, $FE, $FF, $29, $0A, $7A
	.byte $0F, $51, $7F, $01, $00, $00, $00, $FF, $FF, $FF, $FF, $00, $00, $70, $FF, $FF, $FE, $03, $00, $D0
	.byte $00, $FC, $FF, $8F, $AA, $92, $72, $AA, $7D, $0A, $00, $11, $00, $E0, $FF, $FF, $FF, $1F, $00, $00
	.byte $ED, $FE, $FF, $3F, $00, $00, $0B, $00, $FF, $FF, $63, $B7, $20, $D4, $7B, $4D, $48, $52, $00, $00
	.byte $E0, $FF, $FF, $FF, $3F, $00, $80, $21, $F9, $FF, $FF, $00, $A0, $16, $00, $FE, $FF, $D1, $7F, $01
	.byte $60, $7F, $42, $DA, $2D, $10, $00, $00, $FC, $FF, $FF, $FF, $07, $00, $10, $91, $FF, $FF, $97, $00
	.byte $54, $05, $C0, $FF, $9F, $F8, $3D, $01, $54, $BB, $95, $54, $2D, $09, $51, $09, $00, $FE, $FF, $F7
	.byte $FF, $01, $00, $A8, $4C, $EF, $DD, $7F, $01, $60, $4D, $00, $FD, $DF, $54, $6D, $2B, $49, $54, $6D
	.byte $95, $AA, $56, $45, $11, $01, $C0, $FF, $FF, $B5, $BF, $02, $00, $45, $D5, $ED, $6A, $FB, $55, $10
	.byte $55, $52, $A9, $AA, $76, $BB, $94, $6A, $2D, $49, $55, $55, $55, $55, $55, $A5, $52, $52, $DA, $B6
	.byte $56, $95, $5A, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55
	.byte $55, $AB, $54, $55, $55, $55, $B5, $AA, $52, $55, $A5, $A4, $AA, $AA, $AA, $D5, $5A, $55, $AD, $4A
	.byte $B5, $AA, $AA, $AA, $AA, $4A, $55, $55, $55, $55, $55, $55, $55, $55, $55, $B5, $AA, $6A, $55, $55
	.byte $AA, $52, $55, $55, $95, $4A, $55, $55, $55, $55, $AB, $55, $B5, $AA, $56, $55, $55, $95, $AA, $AA
	.byte $4A, $55, $55, $55, $55, $55, $55, $55, $D5, $AA, $AA, $5A, $55, $A5, $AA, $AA, $54, $55, $95, $52
	.byte $A9, $AA, $AA, $5A, $B5, $5A, $55, $D5, $AA, $56, $95, $AA, $AA, $2A, $55, $55, $55, $55, $A5, $AA
	.byte $AA, $55, $55, $55, $D5, $AA, $AA, $AA, $AA, $2A, $55, $55, $A5, $4A, $A9, $D2, $54, $D5, $6A, $AD
	.byte $55, $55, $B5, $AA, $AA, $2A, $55, $55, $55, $55, $55, $55, $AA, $AA, $AA, $56, $55, $55, $55, $55
	.byte $AD, $AA, $AA, $54, $55, $55, $A9, $54, $A9, $AA, $AA, $AA, $56, $AD, $5A, $55, $B5, $AA, $AA, $AA
	.byte $AA, $2A, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $AB, $AA, $AA, $AA, $AA, $52, $55
	.byte $95, $4A, $A5, $AA, $AA, $AA, $56, $AB, $55, $D5, $6A, $55, $55, $55, $55, $95, $AA, $54, $55, $55
	.byte $55, $55, $55, $55, $55, $AB, $6A, $55, $55, $55, $95, $2A, $55, $A9, $54, $4A, $55, $55, $AD, $5A
	.byte $6B, $55, $B5, $5A, $D5, $AA, $AA, $54, $A5, $2A, $55, $55, $55, $55, $55, $55, $D5, $AA, $AA, $AA
	.byte $2A, $55, $55, $A9, $54, $AA, $54, $55, $B5, $5A, $AD, $56, $55, $AB, $5A, $55, $55, $A9, $AA, $54
	.byte $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $95, $AA, $AA, $AA, $AA, $52, $55, $55, $55
	.byte $55, $D5, $AA, $5A, $55, $55, $B5, $AA, $AA, $AA, $52, $55, $55, $55, $55, $55, $55, $55, $B5, $AA
	.byte $AA, $AA, $AA, $54, $55, $95, $4A, $A5, $4A, $55, $AD, $5A, $AD, $56, $D5, $6A, $55, $AB, $AA, $2A
	.byte $55, $95, $AA, $54, $55, $55, $55, $55, $55, $55, $55, $55, $AB, $6A, $55, $55, $55, $55, $95, $2A
	.byte $55, $55, $A9, $54, $A5, $AA, $AA, $56, $AD, $56, $55, $AB, $55, $AB, $AA, $AA, $AA, $4A, $95, $2A
	.byte $55, $55, $AA, $54, $95, $AA, $56, $D5, $6A, $55, $B5, $56, $AB, $6A, $95, $AA, $52, $A9, $54, $95
	.byte $2A, $55, $AA, $6A, $55, $AB, $56, $55, $6B, $D5, $AA, $5A, $A5, $AA, $52, $A5, $52, $55, $A9, $54
	.byte $A5, $AA, $AA, $55, $AD, $56, $55, $AB, $56, $B5, $AA, $AA, $54, $A5, $2A, $55, $55, $AA, $52, $55
	.byte $55, $55, $B5, $6A, $55, $B5, $6A, $55, $55, $55, $55, $AA, $54, $55, $2A, $95, $AA, $AA, $AA, $56
	.byte $AD, $56, $55, $AD, $6A, $55, $55, $55, $A5, $AA, $52, $55, $55, $55, $95, $AA, $AA, $AA, $AA, $56
	.byte $6A, $55, $55, $5D, $B5, $17, $AD, $2A, $52, $29, $55, $AA, $54, $A5, $75, $B5, $55, $AD, $AA, $54
	.byte $55, $55, $55, $29, $55, $4A, $29, $A5, $AA, $54, $A9, $B6, $DB, $56, $AB, $52, $A9, $AC, $6A, $D5
	.byte $AA, $4A, $55, $55, $55, $D5, $56, $4B, $55, $AA, $AA, $AA, $AA, $2A, $95, $94, $52, $55, $8A, $AA
	.byte $BF, $5B, $53, $4A, $49, $AA, $6D, $AD, $55, $A5, $54, $AA, $55, $B5, $AA, $54, $55, $55, $D5, $6A
	.byte $95, $AA, $6A, $AA, $56, $55, $A9, $2A, $55, $55, $55, $52, $A9, $12, $A9, $FB, $56, $55, $35, $55
	.byte $69, $55, $55, $6B, $A9, $54, $55, $55, $AB, $96, $4A, $D5, $AA, $AA, $55, $55, $AA, $AA, $AA, $AA
	.byte $54, $55, $55, $A9, $AA, $52, $B5, $2C, $95, $AA, $5A, $B5, $55, $55, $55, $55, $55, $D5, $AA, $AA
	.byte $AA, $54, $B5, $AA, $AA, $AA, $AA, $AA, $54, $D5, $AA, $2A, $55, $55, $55, $55, $55, $55, $55, $55
	.byte $A5, $A6, $5A, $AA, $AA, $AA, $AA, $5A, $55, $55, $55, $55, $55, $55, $B5, $AA, $AA, $AA, $AA, $AA
	.byte $AA, $AA, $AA, $2A, $55, $55, $55, $55, $55, $55, $55, $55, $55, $95, $AA, $AA, $AA, $5A, $55, $55
	.byte $55, $55, $55, $55, $CB, $AA, $AA, $AA, $AA, $AA, $AA, $2A
DMC_SILENCE:
	.byte $55, $55, $55, $55, $55, $55, $55, $55
	.byte $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55
	.byte $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55
DMC_ORB_End

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; The following two LUTs are used together via Update_Request
	; See index values UPDATERASTER_*
IntNMI_UpdSel_Table:	
	.byte $a0	; UPDATERASTER_32PIXPART (opt. flag UPDATERASTER_32PIXSHOWSPR)
	.byte $40	; UPDATERASTER_SPADEGAME
	.byte $a0	; UPDATERASTER_WATERLINE

IntNMI_Raster_Table:	
	.byte $40	; UPDATERASTER_32PIXPART (opt. flag UPDATERASTER_32PIXSHOWSPR)
	.byte $60	; UPDATERASTER_SPADEGAME
	.byte $a0	; UPDATERASTER_WATERLINE

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; NMI INTERRUPT
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IntNMI:
	SEI		 ; Prevent further masked Interrupts

	; This pushes all the registers onto the stack
	PHP		 ; Push processor status onto stack
	PHA		 ; Push accumulator onto stack
	TXA		 ; Reg X -> A
	PHA		 ; Push A (X) onto stack
	TYA		 ; Reg Y -> A
	PHA		 ; Push A (Y) onto stack

	; Push the three temp vars onto the stack 
	LDA <Temp_Var1
	PHA
	LDA <Temp_Var2
	PHA
	LDA <Temp_Var3
	PHA

	JMP PRG030_SUB_9F40	 ; Jump to PRG030_SUB_9F40

PRG031_F499:
	BEQ PRG031_F4AB	 ; If Update_Request = 0, goto PRG031_F4AB (no request pending)

	; Since Update_Request must be >= 1, this converts it to a zero-based index
	AND #$7f	 ; Keep lower 7 bits
	TAY		 ; -> 'Y'
	DEY		 ; Y-- (zero base index)

	; Get which update path we're going to follow
	LDA IntNMI_UpdSel_Table,Y
	STA Update_Select

	; Apply Raster_Effect as requested
	LDA IntNMI_Raster_Table,Y
	STA Raster_Effect

PRG031_F4AB:
	LDA UpdSel_Disable
	BEQ PRG031_F4B3	 ; If UpdSel_Disable is not set, jump to PRG031_F4B3 (perform Update_Select activity)
	JMP PRG031_F567	 ; Otherwise, jump to PRG031_F567

PRG031_F4B3:
	; Update_Select activity begin...

	LDA Update_Select	 ; Get the Update_Select value
	CMP #$80	 ; 
	BNE PRG031_F4BD	 ; If Update_Select <> $80 (Purely vertical level), jump to PRG031_F4BD
	JMP UpdSel_Vertical	 ; Otherwise, jump to UpdSel_Vertical

PRG031_F4BD: 
	CMP #$40	 ; 
	BNE PRG031_F4C4	 ; If Update_Select <> $40 (Spade Game), jump to PRG031_F4C4
	JMP UpdSel_Roulette	 ; Otherwise, jump to UpdSel_Roulette

PRG031_F4C4:
	CMP #$00	 ; 
	BNE PRG031_F4D5	 ; If Update_Select <> $00 FIXME, jump to PRG031_F4D5

	; MMC3 event
	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #26	 			; Page 26
	STA MMC3_PAGE	 		; Set MMC3 page
	JMP PRG031_F610	 		; 

PRG031_F4D5:
	CMP #$a0	 ; 
	BNE PRG031_F4DC	 ; If Update_Select <> $A0 (32 pixel parition), jump to PRG031_F4DC

	JMP UpdSel_32PixPart	 ; Otherwise, jump to UpdSel_32PixPart

PRG031_F4DC:
	CMP #$20	 ;  
	BNE PRG031_F4E3	 ; If Update_Select <> $20 (Title Screen), jump to PRG031_F4E3
	JMP UpdSel_Title	 ; Otherwise, jump to UpdSel_Title

PRG031_F4E3:

	; "Normal" update ($C0)

	LDA #$00	 ; A = 0
	STA PPU_CTL2	 ; Hide sprites and bg (most importantly)
	STA PPU_SPR_ADDR ; Resets to sprite 0 in memory
	LDA #$02	 ; A = 2
	STA SPR_DMA	 ; DMA sprites from RAM @ $200 (probably trying to blank them out)
	JSR PT2_Full_CHRROM_Switch	 ; Set up PT2 (Sprites) CHRROM

	LDA <VBlank_Tick	
	BNE PRG031_F51D	 	; If VBlank_Tick <> 0, jump to PRG031_F51D

	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #26	 			; Page 26
	STA MMC3_PAGE	 		; Set MMC3 page

	JSR Scroll_Commit_Column ; Update nametable as screen scrolls (differs from call made in UpdSel_Vertical, UpdSel_32PixPart)
	JSR Video_Misc_Updates	 ; Various updates other than scrolling (palettes, status bar, etc.)
	JSR TileChng_VRAMCommit	 ; Commit 16x16 tile change to VRAM

	; Set pages at A000 and C000
	JSR PRGROM_Change_Both

	LDA <Graphics_Queue	
	BNE PRG031_F519	 	; If we don't need to reset the graphics buffer, jump to PRG031_F519

	LDA #$00	 	; Reset the graphics buffer
	STA Graphics_BufCnt	
	STA Graphics_Buffer	

PRG031_F519:
	LDA #$00	 
	STA <Graphics_Queue	 ; Buffer reset (if pending) not needed, we just did it ourselves

PRG031_F51D:

	LDA PPU_STAT	 	; read PPU status to reset the high/low latch

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$3f	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3Fxx
	LDA #$00	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3F00 (palettes?)
	STA PPU_VRAM_ADDR	; 
	STA PPU_VRAM_ADDR	; Now accessing $0000 (Pattern tables?)

	LDA <PPU_CTL2_Copy	; Get current PPU_CTL2 settings in RAM
	ORA #$18	; A | 18 (BG + SPR)
	STA PPU_CTL2	; Sprites/BG are forced to be visible regardless of PPU_CTL2_Copy

	LDA <PPU_CTL1_Mod	
	ORA #%10101000	; In addition to anything else specified by PPU_CTL1_Mod, Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings
	LDA PPU_STAT	; read PPU status to reset the high/low latch

	LDA <Horz_Scroll
	STA PPU_SCROLL	; Horizontal Scroll set
	LDA <Vert_Scroll
	ADD Vert_Scroll_Off	; Apply vertical offset (used for??)
	STA PPU_SCROLL		; Vertical scroll set

	; This sets the status bar scroll fix for everything after the title screen!
	; At scanline 192, the name table scroll is fixed to always display the status bar
	LDA #192		; A = 192
	STA MMC3_IRQCNT		; Store 192 into the IRQ count
	STA MMC3_IRQLATCH	; Store it into the latch (will be used later)
	STA MMC3_IRQENABLE	; Start the IRQ counter
	CLI		; Enable maskable interrupts

PRG031_F55B:
	; This is a common routine used by variants

	LDA <VBlank_TickEn		 ; Check if VBlank occurred
	BEQ PRG031_F567	 ; If A = 0, jump to PRG031_F567

	JSR Randomize	 	; Seed the random number generator
	JSR Read_Joypads	 ; Updates both joypads in RAM

	DEC <VBlank_Tick	 ; Decrement VBlank_Tick

PRG031_F567:
	; Some jump here instead of F55B

	; *** Bring the sound engine (page 28 and page 29) into ROM
	LDA #MMC3_8K_TO_PRG_C000	; Changing PRG ROM at C000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #29	 			; Page 29
	STA MMC3_PAGE	 		; Set MMC3 page

	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #28	 			; Page 28
	STA MMC3_PAGE	 		; Set MMC3 page

	; Jump to the sound engine, newly inserted at page A000!
	JSR Sound_Engine_Begin

	; Change A000/C000 back to whatever they were before the sound engine 
	JSR PRGROM_Change_Both

	INC <Counter_1	 ; Simply increments every frame, used for timing

	; Not sure what this is for
	LDA PAGE_CMD
	STA MMC3_COMMAND

	; Pull (pop) the three temp vars from the stack 
	PLA
	STA <Temp_Var3
	PLA
	STA <Temp_Var2
	PLA
	STA <Temp_Var1

	; This pulls (pops) all the registers from the stack...
	PLA
	TAY
	PLA
	TAX
	PLA
	PLP

	; Fully cleaned up "NMI" interrupt
	RTI

UpdSel_Vertical:

	; COMPARE TO PRG031_F4E3

	LDA #$00	 ; A = 0
	STA PPU_CTL2	 ; Hide sprites and bg (most importantly)
	STA PPU_SPR_ADDR ; Resets to sprite 0 in memory
	LDA #$02	 ; A = 2
	STA SPR_DMA	 ; DMA sprites from RAM @ $200 (probably trying to blank them out)
	JSR PT2_Full_CHRROM_Switch	 ; Set up PT2 (Sprites) CHRROM

	LDA <VBlank_Tick	 
	BNE PRG031_F5D3	 		; If VBlank_Tick <> 0, jump to PRG031_F5D3

	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #26	 			; Page 26
	STA MMC3_PAGE	 		; Set MMC3 page

	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates
	JSR Video_Misc_Updates	 ; Various updates other than scrolling (palettes, status bar, etc.)
	JSR TileChng_VRAMCommit	 ; Commit 16x16 tile change to VRAM

	; Set pages at A000 and C000
	JSR PRGROM_Change_Both

	LDA <Graphics_Queue	
	BNE PRG031_F5CF	 	; If we don't need to reset the buffer, jump to PRG031_F5CF

	; Reset graphics buffer
	LDA #$00
	STA Graphics_BufCnt
	STA Graphics_Buffer

PRG031_F5CF:
	LDA #$00	 
	STA <Graphics_Queue	 ; Graphics Buffer reset

PRG031_F5D3:
	LDA PPU_STAT	 	; read PPU status to reset the high/low latch

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$3f	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3Fxx
	LDA #$00	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3F00 (palettes?)
	STA PPU_VRAM_ADDR	; 
	STA PPU_VRAM_ADDR	; Now accessing $0000 (Pattern tables?)

	LDA <PPU_CTL2_Copy	; Get current PPU_CTL2 settings in RAM
	ORA #$18	; A | 18 (BG + SPR)
	STA PPU_CTL2	; Sprites/BG are forced to be visible regardless of PPU_CTL2_Copy

	LDA <Horz_Scroll_Hi	; ?? Can specify bits? (I think this is a mistake, and this will be zero on vertical level anyway)
	ORA #%10101000	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings
	LDA PPU_STAT	; read PPU status to reset the high/low latch

	LDA <Horz_Scroll
	STA PPU_SCROLL	 ; Horizontal Scroll set
	LDA <Vert_Scroll
	STA PPU_SCROLL	 ; Vertical Scroll set

	LDA #192	 ; A = 192
	STA MMC3_IRQCNT	 ; Store 192 into the IRQ count
	STA MMC3_IRQLATCH ; Store it into the latch (will be used later)
	STA MMC3_IRQENABLE ; Start the IRQ counter
	CLI		 ; Enable maskable interrupts
	JMP PRG031_F55B	 ; Jump to PRG031_F55B

PRG031_F610:

	; Following the "Normal" Update path...

	LDA #$00	 ; A = 0
	STA PPU_CTL2	 ; Hide sprites and bg (most importantly)
	STA PPU_SPR_ADDR ; Resets to sprite 0 in memory
	LDA #$02	 ; A = 2
	STA SPR_DMA	 ; DMA sprites from RAM @ $200 (probably trying to blank them out)
	JSR PT2_Full_CHRROM_Switch	 ; Set up PT2 (Sprites) CHRROM

	LDA <Map_EnterLevelFX	 
	BEQ PRG031_F631	 ; If Map_EnterLevelFX = 0 (not entering a level), jump to PRG031_F631
	CMP #$01	 ; 
	BNE PRG031_F62E	 ; If Map_EnterLevelFX <> 1 (only other value would be 2, during the level "opening" effect, not used in US version), jump to PRG031_F62E

	; This is being called while level is being entered...
	JSR Map_EnterLevel_Effect 	; World map "entering" effect on page 26

	JMP PRG031_F631	 ; Jump to PRG031_F631

PRG031_F62E:
	JSR Level_Opening_Effect	; Level "opening" effect on page 26 (unused on US release)

PRG031_F631:
	LDA PPU_STAT

	LDA <PPU_CTL1_Mod
	ORA #%10101000	; In addition to anything else specified by PPU_CTL1_Mod, Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings

	LDA <Horz_Scroll
	STA PPU_SCROLL	 ; Horizontal Scroll set
	LDA <Vert_Scroll
	STA PPU_SCROLL	 ; Vertical Scroll set

	LDA PPU_STAT	 	; read PPU status to reset the high/low latch

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$3f	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3Fxx
	LDA #$00	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3F00 (palettes?)
	STA PPU_VRAM_ADDR	; 
	STA PPU_VRAM_ADDR	; Now accessing $0000 (Pattern tables?)

	LDA <PPU_CTL2_Copy	; Get current PPU_CTL2 settings in RAM
	ORA #$18	; A | 18 (BG + SPR)
	STA PPU_CTL2	; Sprites/BG are forced to be visible regardless of PPU_CTL2_Copy

	LDA #%10101000	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings

	LDA PPU_STAT

	LDA <Horz_Scroll
	STA PPU_SCROLL	 ; Horizontal Scroll set
	LDA <Vert_Scroll
	STA PPU_SCROLL	 ; Vertical Scroll set

	LDA #192	 ; A = 192
	STA MMC3_IRQCNT	 ; Store 192 into the IRQ count
	STA MMC3_IRQLATCH ; Store it into the latch (will be used later)
	STA MMC3_IRQENABLE ; Start the IRQ counter
	CLI		 ; Enable maskable interrupts
	DEC <VBlank_Tick ; Decrement VBlank_Tick
	JMP PRG031_F567	 ; 

UpdSel_32PixPart:
	LDA #$00	 ; A = 0
	STA PPU_CTL2	 ; Hide sprites and bg (most importantly)
	STA PPU_SPR_ADDR ; Resets to sprite 0 in memory

	LDA #$02	 ; A = 2
	STA SPR_DMA	 ; DMA sprites from RAM @ $200 (probably trying to blank them out)
	JSR PT2_Full_CHRROM_Switch	 ; Set up PT2 (Sprites) CHRROM

	LDA <VBlank_Tick
	BNE PRG031_F6BC	 		; If VBlank_Tick <> 0, jump to PRG031_F6BC

	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #26	 			; Page 26
	STA MMC3_PAGE	 		; Set MMC3 page

	JSR Scroll_Commit_Column ; Update nametable as screen scrolls (differs from call made in UpdSel_Vertical, UpdSel_32PixPart)
	JSR Video_Misc_Updates	 ; Various updates other than scrolling (palettes, status bar, etc.)
	JSR TileChng_VRAMCommit	 ; Commit 16x16 tile change to VRAM

	; Set pages at A000 and C000
	JSR PRGROM_Change_Both

	LDA <Graphics_Queue
	BNE PRG031_F6B8	 ; If we don't need to reset the buffer, jump to PRG031_F6B8

	; Reset graphics buffer
	LDA #$00	 
	STA Graphics_BufCnt
	STA Graphics_Buffer

PRG031_F6B8:
	LDA #$00	 
	STA <Graphics_Queue	; Graphics Buffer reset

PRG031_F6BC:
	LDA PPU_STAT	 	; read PPU status to reset the high/low latch

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$3f	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3Fxx
	LDA #$00	 	; 
	STA PPU_VRAM_ADDR	; Access PPU address #3F00 (palettes?)
	STA PPU_VRAM_ADDR	; 
	STA PPU_VRAM_ADDR	; Now accessing $0000 (Pattern tables?)

	LDA <PPU_CTL2_Copy	; Get current PPU_CTL2 settings in RAM
	ORA #$18	; A | 18 (BG + SPR)
	STA PPU_CTL2	; Sprites/BG are forced to be visible regardless of PPU_CTL2_Copy

	LDA <PPU_CTL1_Mod	; A = PPU_CTL1_Mod
	ORA #%10101000	; In addition to anything else specified by PPU_CTL1_Mod, Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings
	LDA PPU_STAT	; read PPU status to reset the high/low latch

	LDA <Horz_Scroll
	STA PPU_SCROLL	; Horizontal Scroll set
	LDA <Vert_Scroll
	STA PPU_SCROLL	; Vertical scroll set

	; 32 pixel partition begins at line 160
	LDA #160
	STA MMC3_IRQCNT		; Store 160 into the IRQ count
	STA MMC3_IRQLATCH	; Store it into the latch (will be used later)
	STA MMC3_IRQENABLE	; Start the IRQ counter
	CLI		; Enable maskable interrupts
	JMP PRG031_F55B	 ; Jump to PRG031_F55B

UpdSel_Title:
	LDA #$00	 ; A = 0
	STA PPU_CTL2	 ; Hide sprites and bg (most importantly)
	STA PPU_SPR_ADDR ; Resets to sprite 0 in memory
	LDA #$02	 ; A = 2
	STA SPR_DMA	 ; DMA sprites from RAM @ $200 (probably trying to blank them out)
	JSR PT2_Full_CHRROM_Switch	 ; Set up PT2 (Sprites) CHRROM

	LDA <VBlank_Tick
	BNE PRG031_F748	 ; If VBlank_Tick <> 0, go to PRG031_F748

	LDA <Ending2_IntCmd
	BEQ PRG031_F72B	 ; If Ending2_IntCmd = 0, go to PRG031_F72B

	LDA #MMC3_8K_TO_PRG_C000	; Changing PRG ROM at C000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #25	 			; Page 25
	STA MMC3_PAGE	 		; Set MMC3 page

	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #24	 			; Page 24
	STA MMC3_PAGE	 		; Set MMC3 page

	JSR Do_Ending2_IntCmd	; Perform action of Ending2_IntCmd

	JMP PRG031_F748	 ; Jump to PRG031_F748

PRG031_F72B:
	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA #26	 			; Page 26
	STA MMC3_PAGE	 		; Set MMC3 page

	JSR Video_Misc_Updates	 ; Various updates other than scrolling (palettes, status bar, etc.)

	LDA <Graphics_Queue
	BNE PRG031_F744	 ; If we don't need to reset the graphics buffer, jump to PRG031_F744

	; Reset graphics buffer
	LDA #$00	 
	STA Graphics_BufCnt
	STA Graphics_Buffer

PRG031_F744:
	LDA #$00	 
	STA <Graphics_Queue	 ; Graphics Buffer reset

PRG031_F748:
	LDA PPU_STAT

	LDA #$00
	STA PPU_VRAM_ADDR	; 
	STA PPU_VRAM_ADDR	; Now accessing $0000 (Pattern tables?)

	LDA <PPU_CTL2_Copy	; Get current PPU_CTL2 settings in RAM
	ORA #$18	; A | 18 (BG + SPR)
	STA PPU_CTL2	; Sprites/BG are forced to be visible regardless of PPU_CTL2_Copy

	LDA <PPU_CTL1_Mod	; A = PPU_CTL1_Mod
	ORA #%10101000	; In addition to anything else specified by PPU_CTL1_Mod, Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings
	LDA PPU_STAT	; read PPU status to reset the high/low latch

	LDA <Horz_Scroll
	STA PPU_SCROLL	; Horizontal Scroll set
	LDA <Vert_Scroll
	STA PPU_SCROLL	; Vertical scroll set

	; NOTE: Different from the typical 192 scanline count!
	LDA #193		; A = 193
	STA MMC3_IRQCNT		; Store 193 into the IRQ count
	STA MMC3_IRQLATCH	; Store it into the latch (will be used later)
	STA MMC3_IRQENABLE	; Start the IRQ counter
	CLI		; Enable maskable interrupts

	LDA <VBlank_TickEn	 ; Check VBlank flag
	BEQ PRG031_F786	 	; If A = 0, jump to PRG031_F786
	JSR Randomize	 	; Shake up the randomizer!
	JSR Read_Joypads	 ; Updates both joypads in RAM

	DEC <VBlank_Tick	 ; Decrement VBlank_Tick

PRG031_F786:
	JMP PRG031_F567	 ; Jump to PRG031_F567

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Set of pages "normal" IRQ sets when tileset is 0 (World Map) or 7 (Toad House)
StatusBarMTCHR_0000:	.byte $5c	; Standard status bar part 1 ($5C and $5D are loaded)
StatusBarMTCHR_0800:	.byte $5e	; Standard status bar part 2 ($5E and $5F are loaded)
SpriteMTCHR_1000:	.byte $48
SpriteMTCHR_1400:	.byte $49
SpriteMTCHR_1800:	.byte $05	; Power-up and Toad sprites here
SpriteMTCHR_1C00:	.byte $4b

; Set of pages "normal" IRQ sets (for status bar I presume)
StatusBarCHR_0000:	.byte $5c	; Standard status bar part 1 ($5C and $5D are loaded)
StatusBarCHR_0800:	.byte $5e	; Standard status bar part 2 ($5E and $5F are loaded)
SpriteHideCHR_1000:	.byte $7e	; ALL BLANK TILES
SpriteHideCHR_1400:	.byte $7e	; ALL BLANK TILES
SpriteHideCHR_1800:	.byte $7e	; ALL BLANK TILES
SpriteHideCHR_1C00:	.byte $7e	; ALL BLANK TILES

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IntIRQ:	 ; $F795 IRQ Interrupt (scanline from MMC3)
	SEI		 ; Disable maskable interrupts

	; Save all registers
	PHP		 ; Push processor status onto stack
	PHA		 ; Push accumulator onto stack
	TXA		 ; Reg X -> A
	PHA		 ; Push A (X) onto stack
	TYA		 ; Reg Y -> A
	PHA		 ; Push A (Y) onto stack

	LDA Reset_Latch
	CMP #$5a
	BEQ PRG031_F7B0	 ; If Reset_Latch = $5A, go to PRG031_F7B0

	; Reset_Latch was something other than the magic $5A value... reset!!

	; This gets the address of the Reset entry point -> [Temp_Var2][Temp_Var1]
	LDA Vector_Table+2
	STA <Temp_Var1
	LDA Vector_Table+3
	STA <Temp_Var2

	; Jump to the Reset instead...
	JMP [Temp_Var1]

PRG031_F7B0:
	LDA PAPU_MODCTL_Copy
	PHA		 ; Save A
	AND #$7f	 ; Basically don't disturb DMC, but disable interrupt, if active
	STA PAPU_MODCTL	 ; 

	LDA Raster_Effect	 ; Get status bar mode

	CMP #$80	 ; Are we in "do nothing" mode?
	BNE PRG031_F7C3	 ; If not, go to PRG031_F7C3
	JMP IntIRQ_Finish	 ; Otherwise, jump to IntIRQ_Finish (nothing to do!)

PRG031_F7C3:
	CMP #$40	 ; Are we in "32 pixel partition" mode?
	BNE PRG031_F7CA ; If not, go to PRG031_F7CA
	JMP IntIRQ_32PixelPartition	 ; Otherwise, jump to IntIRQ_32PixelPartition

PRG031_F7CA:
	CMP #$20	 ; Are we in "title screen" mode? (used on title screen and ending sequence)
	BNE PRG031_F7D1	 ; If not, go to PRG031_F7D1
	JMP IntIRQ_TitleEnding	 ; Otherwise, jump to IntIRQ_TitleEnding

PRG031_F7D1: 
	CMP #$60	 ; Are we in "Spade Game" mode?
	BNE PRG031_F7D8	 ; If not, go to PRG031_F7D8
	JMP IntIRQ_SpadeGame	 ; Otherwise, jump to IntIRQ_SpadeGame

PRG031_F7D8:
	CMP #$A0	 ; Are we in "A0??? FIXME" mode? ()
	BNE PRG031_F7DF	 ; If not, go to PRG031_F7DF
	JMP IntIRQ_A0FIXME	 ; Otherwise, jump to IntIRQ_A0FIXME

PRG031_F7DF:

	; Flags for vertical World 7 speciality levels
	LDA Level_7Vertical
	BEQ IntIRQ_Standard	 ; The standard bar (status bar used in level and map)
	JMP IntIRQ_Vertical	 ; Otherwise, do the vertical thing

IntIRQ_Standard:
	STA MMC3_IRQENABLE ; Active IRQ
	NOP		 ; 
	NOP		 ; 
	NOP		 ; 
	LDY #$0b	 ; Y = $0B
	LDA Level_Tileset ; A = current tileset
	CMP #17
	BNE PRG031_F7F8	 ; If tileset <> 17 (N-Spade), jump to PRG031_F7F8
	LDY #$03	 ; Y = $03

PRG031_F7F8:
	LDX #$00	 ; X = 0

	CMP #$00	 ; 
	BEQ PRG031_F871	 ; If tileset = 0 (World map), go to PRG031_F871
	CMP #$07	 ; 
	BEQ PRG031_F871	 ; If tileset = 7 (Toad house), go to PRG031_F871
	CMP #17
	BEQ PRG031_F871	 ; If tileset = 17 (N-Spade), go to PRG031_F871

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$00
	STA PPU_VRAM_ADDR
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

	STX PPU_CTL2	 ; Sprites + BG invisible
	LDA PPU_STAT	 ; 

	; Because vertical scroll will not change after frame begins (second write to
	; PPU_SCROLL will always be unused until next frame), the hack for MMC3 split
	; vertical scrolling is to change the nametable address that the PPU is reading
	; at to where we would like it to be...
	; In this case, the location of the beginning of the status bar!
	STY PPU_VRAM_ADDR	 ; This is $0B unless tileset = $11, which it is then $03
	LDA #$00
	STA PPU_VRAM_ADDR	; ... so we're now reading at $0B00 or $0300
	LDA PPU_VRAM_DATA

	; Load status bar graphics and hide any sprites from appearing over the status bar

	; Load two parts of Status Bar
	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND
	LDA StatusBarCHR_0000
	STA MMC3_PAGE
	LDA #MMC3_2K_TO_PPU_0800
	STA MMC3_COMMAND
	LDA StatusBarCHR_0800
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND

	; Use blank tiles for all sprite graphics
	LDA SpriteHideCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1800
	STA MMC3_PAGE	
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND	
	LDA SpriteHideCHR_1C00
	STA MMC3_PAGE
	 
	LDA #$18	 ; 
	STA PPU_CTL2	 ; Sprites + BG now visible
	JMP PRG031_F8B3

PRG031_F871:
	; World map / Toad House / N-Spade

	; Load status bar graphics and hide any sprites from appearing over the status bar

	; Load two parts of Status Bar
	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND
	LDA StatusBarMTCHR_0000
	STA MMC3_PAGE
	LDA #MMC3_2K_TO_PPU_0800
	STA MMC3_COMMAND
	LDA StatusBarMTCHR_0800

	; Load sprite graphics appropriate for World Map / Toad House / N-Spade
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1800
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1C00
	STA MMC3_PAGE

PRG031_F8B3:
	LDA <PPU_CTL1_Copy
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Store result into actual register
	LDA PPU_STAT	 ; 

	LDA #$00	 ; 
	STA PPU_SCROLL	 ; Horizontal Scroll = 0
	LDA <Vert_Scroll ; 
	STA PPU_SCROLL	 ; Vertical Scroll updated

IntIRQ_Finish:
	STA MMC3_IRQDISABLE ; Disable the IRQ generation

IntIRQ_Finish_NoDis:
	LDA PAGE_CMD	 ; Get old page command
	STA MMC3_COMMAND ; Issue it
	PLA		 ; Restore A (PAPU_MODCTL_Copy)
	STA PAPU_MODCTL	 ; Set DMC back to normal

	; Restore the other registers
	PLA
	TAY
	PLA
	TAX
	PLA
	PLP

	RTI		 ; End of IRQ interrupt!

IntIRQ_Vertical:	; $F8DB
	STA MMC3_IRQENABLE ; Enable IRQ generation

	; Some kind of delay loop?
	LDX #$02	 ; X = 2
PRG031_F8E0:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG031_F8E0	 ; While X > 0, loop

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$00
	STA PPU_VRAM_ADDR
	LDX #$00
	STX PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR

	STX PPU_CTL2	 ; Hide BG + Sprites
	LDA PPU_STAT	 ; 

	; Because vertical scroll will not change after frame begins (second write to
	; PPU_SCROLL will always be unused until next frame), the hack for MMC3 split
	; vertical scrolling is to change the nametable address that the PPU is reading
	; at to where we would like it to be...
	LDY #$07
	STY PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR	; ... so we're now reading at $0700
	LDA PPU_VRAM_DATA

	; Couple of tilesets have slightly different effects 
	LDA Level_Tileset
	CMP #$00	 ; 
	BEQ PRG031_F955	 ; If A = 0 (On world map), go to PRG031_F955
	CMP #$07	 ; 
	BEQ PRG031_F955	 ; If A = 7 (Toad house), go to PRG031_F955 
	; But not N-Spade?

	; Load status bar graphics and hide any sprites from appearing over the status bar

	; Load two parts of Status Bar
	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND
	LDA StatusBarCHR_0000
	STA MMC3_PAGE	
 	LDA #MMC3_2K_TO_PPU_0800
	STA MMC3_COMMAND
	LDA StatusBarCHR_0800
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND

	; Use blank tiles for all sprite graphics
	LDA SpriteHideCHR_1000	
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1800	
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1C00	
	STA MMC3_PAGE

	JMP PRG031_F997	 ; Jump to PRG031_F997

PRG031_F955:
	; World Map and Toad House alternate (but not N-Spade?)

	; Load status bar graphics and hide any sprites from appearing over the status bar

	; Load two parts of Status Bar
	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND
	LDA StatusBarMTCHR_0000
	STA MMC3_PAGE
	LDA #MMC3_2K_TO_PPU_0800
	STA MMC3_COMMAND
	LDA StatusBarMTCHR_0800
	STA MMC3_PAGE

	; Load sprite graphics appropriate for World Map / Toad House / N-Spade
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1800
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND
	LDA SpriteMTCHR_1C00
	STA MMC3_PAGE

PRG031_F997:
	LDA #$18	 ; A | 18 (BG + SPR)
	STA PPU_CTL2	 ; Sprites/BG are visible
	LDA <PPU_CTL1_Copy	 ; PPU_CTL1 copy
	ORA #$01	 ; Force $2400 nametable address
	STA PPU_CTL1	 ; Set it in the register
	LDA PPU_STAT	 ; 
	LDA #$00	 ; 
	STA PPU_SCROLL	 ; Horizontal scroll = 0
	LDA <Vert_Scroll ; 
	STA PPU_SCROLL	 ; Vertical scroll update as-is
	JMP IntIRQ_Finish	 ; Clean up IRQ

IntIRQ_32PixelPartition:	; $F9B3 

	; Lotta no-ops??
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

	LDA Raster_State ; Get current state of the Raster op
	BEQ PRG031_F9C1	 ; If Raster_State = 0, go to PRG031_F9C1 (at the 32 pixel partition)
	JMP PRG031_FA3F	 ; Otherwise, jump to PRG031_FA3F (below the 32 pixel partition, status bar)

PRG031_F9C1:
	; At the 32 pixel partition

	; Some kind of delay loop?
	LDX #$15	 ; X = $15
PRG031_F9C3:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG031_F9C3 ; While X > 0, loop

	LDA #$10	 ; 
	STA PPU_CTL2	 ; Only show sprites (?)
	LDA PPU_STAT	 ; 

	; Because vertical scroll will not change after frame begins (second write to
	; PPU_SCROLL will always be unused until next frame), the hack for MMC3 split
	; vertical scrolling is to change the nametable address that the PPU is reading
	; at to where we would like it to be...
	LDY #$0a	 ; Y = $0A
	LDA #$80	 ; A = $80
	STY PPU_VRAM_ADDR	 ;
	STA PPU_VRAM_ADDR	 ; ... so we're now reading at $0A80, the top of the last two rows of tiles
	LDA PPU_VRAM_DATA	 ;

	JMP IntIRQ_32PixelPartition_Part2	; Jump to IntIRQ_32PixelPartition_Part2

	; Something removed?
	NOP
	NOP
	NOP
	NOP

IntIRQ_32PixPart_HideSprites:	; $F9E3

	; This part is skippable based on a flag; only loads
	; Pattern Table 2 in this case...
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1800
	STA MMC3_PAGE	
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND	
	LDA SpriteHideCHR_1C00
	STA MMC3_PAGE


IntIRQ_32PixelPartition_Part3:
	LDA PPU_STAT
	LDA <PPU_CTL1_Copy	
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Stored to the register!

	LDA <Horz_Scroll
	STA PPU_SCROLL	 ; Set horizontal scroll 
	LDA <Vert_Scroll
	STA PPU_SCROLL	 ; Set vertical scroll

	LDA #$18	 ; 
	STA PPU_CTL2	 ; BG + Sprites now visible

	INC Raster_State ; Raster_State = 1

	LDA #27		 ; 
	STA MMC3_IRQCNT	 ; Next interrupt in 27 lines
	STA MMC3_IRQDISABLE	 ; Disable IRQ...
	JMP IntIRQ_32PixelPartition_Part5	 ; Jump to IntIRQ_32PixelPartition_Part5

	; Dead code?  Or maybe timing/cycle filler
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

PRG031_FA3C:
	JMP IntIRQ_Finish_NoDis	 ; Jump to IntIRQ_Finish_NoDis

PRG031_FA3F:
	; The part we do when Raster_State = 1 (the 2nd IRQ interrupt split)

	; Some kind of delay loop?
	LDX #$05	 ; X = 5
PRG031_FA41:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG031_FA41 ; While X > 0, loop

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$00
	STA PPU_VRAM_ADDR
	LDX #$00
	STX PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR

	STX PPU_CTL2	 ; Sprites + BG hidden
	LDA PPU_STAT	 ; 

	; Because vertical scroll will not change after frame begins (second write to
	; PPU_SCROLL will always be unused until next frame), the hack for MMC3 split
	; vertical scrolling is to change the nametable address that the PPU is reading
	; at to where we would like it to be...
	LDY #$0b
	STY PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR	; ... so now we're reading at $0B00
	LDA PPU_VRAM_DATA

	; This loads graphics into the "BG" side (PT1)
	; I think the only reason they're using labeled constants
	; is so they could put this code in multiple spots, but it'd
	; stay in sync if they needed to change the CHRROM banks.
	; But that'd be the job of an assembler label, wouldn't it??
	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND
	LDA StatusBarCHR_0000
	STA MMC3_PAGE
	LDA #MMC3_2K_TO_PPU_0800
	STA MMC3_COMMAND
	LDA StatusBarCHR_0800
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1800
	STA MMC3_PAGE	
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND	
	LDA SpriteHideCHR_1C00
	STA MMC3_PAGE

	LDA #$18	 ; 
	STA PPU_CTL2	 ; Sprites + BG now visible
	LDA <PPU_CTL1_Copy
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Update the PPU_CTL1 register..
	LDA PPU_STAT	 ; 

	LDA #$00	 ; 
	STA PPU_SCROLL	 ; Horizontal scroll locked at zero
	LDA <Vert_Scroll	
	STA PPU_SCROLL	 ; Vertical scroll as-is
	LDA #$00	 ; 
	STA Raster_State ; Clear Raster_State (no more effects)
	JMP IntIRQ_Finish	 ; Clean up IRQ


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tables used by IntIRQ_SpadeGame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Roulette_RasterDelay:
	.byte $02, $02, $02, $06

	; This table tells how many lines to skip to the next row.
	; Apparently they didn't really take advantage of the potential
	; for this functionality, however, as all values are equal!
Roulette_RasterDiv:	; Raster_State = 0,1,2
	.byte $34, $34, $34

	.byte $00	; Not used, would be Raster_State = 3

IntIRQ_SpadeGame:

	; Disable then enable the IRQ??  Probably to make sure
	; last latch value gets pushed into counter...
	STA MMC3_IRQDISABLE
	STA MMC3_IRQENABLE

	LDY Raster_State ; Get current Raster_State
	CPY #$03	 ;
	BEQ PRG031_FAE7	 ; If Raster_State = 3, jump to PRG031_FAE7

	; Based on the current Raster_State, set next scanline delay
	LDA Roulette_RasterDiv,Y
	STA MMC3_IRQCNT
	STA MMC3_IRQENABLE

PRG031_FAE7:

	; Another of these common delay loops, this time dynamic...
	LDX Roulette_RasterDelay,Y	 ; Get value based on Raster_State
PRG031_FAEA:
	NOP		 ; ? 
	DEX		 ; X--
	BNE PRG031_FAEA	 ; While > 0, loop...

	CPY #$03	 ;
	BNE PRG031_FB34	 ; If Raster_State <> 3, jump to PRG031_FB34

	; Raster_State = 3 (load status bar graphics)

	; This loads graphics into the "BG" side (PT1)
	; I think the only reason they're using labeled constants
	; is so they could put this code in multiple spots, but it'd
	; stay in sync if they needed to change the CHRROM banks.
	; But that'd be the job of an assembler label, wouldn't it??
	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND
	LDA StatusBarCHR_0000
	STA MMC3_PAGE
	LDA #MMC3_2K_TO_PPU_0800
	STA MMC3_COMMAND
	LDA StatusBarCHR_0800
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1800
	STA MMC3_PAGE	
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND	
	LDA SpriteHideCHR_1C00
	STA MMC3_PAGE

PRG031_FB34:
	LDA PPU_STAT	 ; 

	CPY #$03	 ; 
	BEQ PRG031_FB57	 ; If Raster_State = 3, jump to PRG031_FB57

	; Raster_State < 3...

	LDA Roulette_PosHi,Y	 ; Get position for this row
	AND #$01	 ; Nametable swaps $2000 / $2400 every odd/even unit (??)
	ORA <PPU_CTL1_Copy	; Update PPU_CTL1_Copy
	STA PPU_CTL1	 	; .. and the actual PPU_CTL1 register
	LDA Roulette_Pos,Y	 ; Get horizontal scroll position for this row
	STA PPU_SCROLL	 ; Store the horizontal
	LDA #$00	 ; 
	STA PPU_SCROLL	 ; Vertical = 0
	INY		 ; 
	STY Raster_State ; Raster_State++
	JMP IntIRQ_Finish_NoDis	 ; Cleanup and finish (for THIS Raster_State)

PRG031_FB57:
	; Raster_State = 3 ...
	LDA <PPU_CTL1_Copy	
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Update actual register
	LDA #$00	 ; 
	STA PPU_SCROLL	 ; Horizontal Scroll = 0
	LDA <Vert_Scroll ; 
	STA PPU_SCROLL	 ; Vertical Scroll updated (should generally not be moving here :)
	LDA #$00	 ; 
	STA Raster_State	 ; Raster_State = 0
	JMP IntIRQ_Finish	 ; Clean up IRQ, we're done!


	; FIXME: What is this for??
IntIRQ_A0FIXME:
	; Disable then enable the IRQ??  Probably to make sure
	; last latch value gets pushed into counter...
	STA MMC3_IRQDISABLE
	STA MMC3_IRQENABLE

	LDA Raster_State
	BEQ PRG031_FB7E	; If Raster_State = 0, go to PRG031_FB7E
	JMP PRG031_FBE5	; Otherwise, jump to PRG031_FBE5

PRG031_FB7E:
	; Some kind of delay loop?
	LDX #$14	 ; X = $14
PRG031_FB80:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG031_FB80 ; While X > 0, loop

	LDA #$10	 ; 
	STA PPU_CTL2	 ; Only show sprites

	; Only loads Pattern Table 2 in this case...
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1800
	STA MMC3_PAGE	
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND	
	LDA SpriteHideCHR_1C00
	STA MMC3_PAGE

	LDA PPU_STAT
	LDA <PPU_CTL1_Copy
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Update the actual register

	LDA <Horz_Scroll
	STA PPU_SCROLL	 ; Update Horizontal Scroll
	LDA <Vert_Scroll
	STA PPU_SCROLL	 ; Update Vertical Scroll
	INC Raster_State ; Raster_State++

	LDA #27	 
	STA MMC3_IRQCNT	 ; Next IRQ in 27 lines

	; Some kind of delay loop?
	LDX #$02	 ; X = $14
PRG031_FBD3:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG031_FBD3 ; While X >= 0, loop

	LDA #$18	 ; 
	STA PPU_CTL2	 ; Sprites + BG now visible

	; Dead code?  Or timing/cycle filler
	NOP
	NOP
	NOP

	; The following JSR does a delay then updates the IRQ
	; counter latch and Resets it
	JSR PRG030_SUB_9F50
	JMP IntIRQ_Finish_NoDis	 ; Clean up for THIS Raster_State...

PRG031_FBE5:
	; Raster_State <> 0...

	; Some kind of delay loop?
	LDX #$03	 ; X = $14
PRG031_FBE7:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG031_FBE7 ; While X > 0, loop

	; Unknown hardware thing?  Is this for synchronization?
	LDA #$00
	STA PPU_VRAM_ADDR
	LDX #$00
	STX PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR

	STX PPU_CTL2	 ; Most importantly, hide BG + Sprites
	LDA PPU_STAT	 ; 

	; Because vertical scroll will not change after frame begins (second write to
	; PPU_SCROLL will always be unused until next frame), the hack for MMC3 split
	; vertical scrolling is to change the nametable address that the PPU is reading
	; at to where we would like it to be...
	LDY #$0b
	STY PPU_VRAM_ADDR
	STX PPU_VRAM_ADDR	; ... so now we're reading at $0B00
	LDA PPU_VRAM_DATA

	; This loads graphics into the "BG" side (PT1)
	; I think the only reason they're using labeled constants
	; is so they could put this code in multiple spots, but it'd
	; stay in sync if they needed to change the CHRROM banks.
	; But that'd be the job of an assembler label, wouldn't it??
	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND
	LDA StatusBarCHR_0000
	STA MMC3_PAGE
	LDA #MMC3_2K_TO_PPU_0800
	STA MMC3_COMMAND
	LDA StatusBarCHR_0800
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1000
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1000
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1400
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1400
	STA MMC3_PAGE
	LDA #MMC3_1K_TO_PPU_1800
	STA MMC3_COMMAND
	LDA SpriteHideCHR_1800
	STA MMC3_PAGE	
	LDA #MMC3_1K_TO_PPU_1C00
	STA MMC3_COMMAND	
	LDA SpriteHideCHR_1C00
	STA MMC3_PAGE

	LDA #$18	 ; 
	STA PPU_CTL2	 ; Sprites + BG now visible

	LDA <PPU_CTL1_Copy
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Update the actual register
	LDA PPU_STAT	 ; 

	LDA #$00	 ; 
	STA PPU_SCROLL	 ; Horizontal Scroll = 0
	LDA <Vert_Scroll ; 
	STA PPU_SCROLL	 ; Update Vertical Scroll
	LDA #$00	 ; 
	STA Raster_State	 ; Raster_State = 0
	JMP IntIRQ_Finish	 ; Clean up IRQ


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PRGROM_Change_Both
;
; This subroutine sets both PRG ROM pages A000 and C000 together.
;	C000 is set to the page value found at RAM location PAGE_C000
;	A000 is set to the page value found at RAM location PAGE_A000
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRGROM_Change_Both:	; $FC6F

	; Setting PRG ROM C000 to page specified in PAGE_C000
	LDA #MMC3_8K_TO_PRG_C000	; Changing PRG ROM at C000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA PAGE_C000	 		; Page @ PAGE_C000
	STA MMC3_PAGE	 		; Set MMC3 page
	
	; Setting PRG ROM A000 to page specified in PAGE_A000
	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA PAGE_A000	 		; Page @ PAGE_A000
	STA MMC3_PAGE	 		; Set MMC3 page

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Split arrays defining the vertical screen starting positions
	; (i.e. $000, $0F0, $1E0, $2D0, ...)
VertLevel_ScreenH:	.byte $00, $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E
VertLevel_ScreenL:	.byte $00, $F0, $E0, $D0, $C0, $B0, $A0, $90, $80, $70, $60, $50, $40, $30, $20, $10

; This stores the four tiles which make up a card (or absense of one)
;              -    M    F    S
CardUL:	.byte $FE, $E0, $E0, $E0
CardUR:	.byte $FE, $E1, $E1, $E1
CardLL:	.byte $FE, $E2, $E2, $E2
CardLR:	.byte $FE, $E3, $E3, $E3

; Each card's video start offset (lower byte)
CardVStartU:	.byte $36, $39, $3C	; Upper half of card
CardVStartL:	.byte $56, $59, $5C	; Lower half of card

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetCardAndUpdate
;
; This subroutine gives Player a card (see Player_GetCard)
; and updates their status bar (see StatusBar_Update_Cards)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetCardAndUpdate:
	JSR Player_GetCard

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; StatusBar_Update_Cards
;
; This subroutine prepares the three cards in the Player's
; inventory, storing them into the graphics buffer to be
; drawn when ready...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
StatusBar_Update_Cards:
	LDA Player_Current
	BEQ PRG031_FCC6	 ; If player = 0 (Mario), jump to PRG031_FCC6
	LDA #(Inventory_Cards2 - Inventory_Cards)

PRG031_FCC6:
	; A is 0 (Mario) or $23 (Luigi)

	STA <Temp_Var1	 ; Temp_Var1 = A

	LDA #$02	 
	STA <Temp_Var2	 ; Temp_Var2 = 2

PRG031_FCCC:
	LDY <Temp_Var1	 ; Y = Temp_Var1

	JSR StatusBar_FillDrawCardPiece_Orbs	 ; Draw part of the card into the status bar

	INC <Temp_Var1
	DEC <Temp_Var2
	BPL PRG031_FCCC	 ; While Temp_Var2 >= 0, loop!

	RTS		 ; Return

StatusBar_FillDrawCardPiece_Orbs:
	;;; [ORANGE] Just update the orb count
	JSR StatusBar_Fill_Orbs
StatusBar_DrawCardPiece_Orbs:
	LDX Graphics_BufCnt
	LDA #$2B
	STA Graphics_Buffer,X
	LDA #$79			; orbs are at $2B79
	STA Graphics_Buffer+1,X
	LDA #$02
	STA Graphics_Buffer+2,X
	LDA StatusBar_Orbs
	STA Graphics_Buffer+3,X
	LDA StatusBar_Orbs+1
	STA Graphics_Buffer+4,X
	LDA #$00
	STA Graphics_Buffer+5,X
	LDA Graphics_BufCnt
	ADD #5
	STA Graphics_BufCnt
	RTS

	.ds 0x3c


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetCard
;
; Gives the Player a card, specified in 'A'
; A = 0 (Mushroom), 1 = (Flower), 2 = (Star)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetCard:
	;;; [ORANGE] Now we do nothing when the card is retrieved. We have unused space for other stuff here if we need it.
	;;; We do have to place a temporary value in the Inventory_Cards to show the correct graphics
	LDA #$01		; Show the correct graphics in the "You got an orb" location
	STA Inventory_Cards
	RTS
	.ds 0x22


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetItem
;
; Gives Player an item specified in 'A'
; If Inventory is full, goes at the end.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; [ORANGE] We're replacing this with our GivePlayerTBoxOrb
;;;Player_GetItem:
GivePlayerTBoxOrb:
	; Treasure box orb was retrieved, check what level we're in and update the Level_Orbs
	JSR _FindLevelOrbOffset03
	CPX #12				; max offset is 11
	; If we didn't find it, there's an error somewhere, just bail out
	BCS _tbox_orb_rts
_clear_tbox_orb:
	; X is == level offset
	LDA Level_Orbs,X
	AND #$02
	BEQ _tbox_orb_rts		; if the bit is already cleared? go ahead and just return
	LDA Level_Orbs,X		; otherwise, just xor off the EndLevelCard orb bit (bit 1)
	EOR #$02
	STA Level_Orbs,X
_tbox_orb_rts:
	RTS

	.byte $FF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Sprite_RAM_Clear
;
; This subroutine clears the local copy of OAM by filling
; the X/Y values in with $F8 and $01, essentially making
; them all invisible until actually needed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Sprite_RAM_Clear:	; $FD84
	LDY #$00	 ; Y = 0

PRG031_FD86:
	LDA #$f8	 	; A = $F8 
	STA Sprite_RAM,  Y	; Next X value
	LDA #$01	 	; A = $01
	STA Sprite_RAM+1,Y	; Next Y value
	INY		 ; 
	INY		 ; 
	INY		 ; 
	INY		 ; Y += 4
	BNE PRG031_FD86	 ; While Y does not equal zero (covers all 256 bytes)

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_PPU_Reset
;
; This subroutine Resets the scroll position of the nametable
; and its associated variables back to zero, and also reasserts
; that the PPU is displaying sprites in PT2, but interestingly
; does not set them to 8x16 ??
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_PPU_Reset:	; $FD97
	LDA #$00	 ; 
	STA PPU_SCROLL	 ; Horizontal scroll = 0
	STA <Horz_Scroll ; Horz_Scroll = 0
	STA PPU_SCROLL	 ; Vertical scroll = 0
	STA <Vert_Scroll ; Vert_Scroll = 0
	LDA #$08	 ; 
	STA PPU_CTL1	 ; Sprites in PT2
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Reset_PPU_Clear_Nametables
;
; Resets PPU_CTL2 and clears both nametables and also resets
; the graphics buffer in case any updates were pending...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Reset_PPU_Clear_Nametables:	; $FDA9
	; Reset graphics buffer
	LDA #$00	  
	STA Graphics_BufCnt
	STA Graphics_Buffer	 

Reset_PPU_Clear_Nametables2:
	; NMI PPU_CTL2 and clear both nametables
	JSR Clear_PPU_CTL2_Copy	; Clear RAM copy and actual PPU_CTL2
	LDA #$20	 	; Select Nametable 0
	JSR Clear_Nametable	; Clear nametable to all $FC
	LDA #$28	 	; Select Nametable 2
	JSR Clear_Nametable	; Clear nametable to all $FC
	RTS		 	; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clear_PPU_CTL2_Copy
;
; Clears the PPU_CTL2_Copy variable and also the
; PPU_CTL2 register itself 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Clear_PPU_CTL2_Copy:	; $FDBF
	LDA #$00	 
	STA <PPU_CTL2_Copy	; Clears PPU_CTL2_Copy (though sprites/BG overridden as visible anyway)
	STA PPU_CTL2	 	; At this point, clearing PPU_CTL2 altogether, though likely it will shortly be updated
	RTS		 	; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clear_Nametable
;
; This subroutine clears an entire nametable, specified by
; the initial value of A ($20 for NT 0, $28 for NT2, and 
; technically the other two could be specified as well)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Clear_Nametable:	; $FDC7:
	STA <Temp_Var1		; Save A

	LDA PPU_STAT	 	; 
	LDA #$00	 	; 
	STA PPU_CTL1		; Most likely most importantly to prevent any more Resets

	LDA <Temp_Var1		; Restore A (from Reset_PPU_Clear_Nametables, this is $20 or $28, Nametable 0 or Nametable 2)
	STA PPU_VRAM_ADDR	; Write this as high byte VRAM address select
	LDA #$00 
	STA PPU_VRAM_ADDR	; $00 as low byte for VRAM address (Reset_PPU_Clear_Nametables selects nametable 1 or 2)

	; This writes over the entire selected name table and attribute table with $FC
	LDX #$04	 ; X = $04
	LDY #$00	 ; Y = $00
	LDA #$fc	 ; A = $FC
PRG031_FDE1:
	STA PPU_VRAM_DATA	 ; Write $FC to NT
	DEY		 ; Y--
	BNE PRG031_FDE1	 ; While <> 0, loop (will write 256 times)
	DEX		 ; X--
	BNE PRG031_FDE1	 ; While <> 0, loop (will write 4 times)

	LDA <Temp_Var1	 ; Retrieve initial A value again
	ADD #$03	 	; A += 3 (moving to attribute table)
	STA PPU_VRAM_ADDR	; Address high byte
	LDA #$c0		; Beginning of attribute table
	STA PPU_VRAM_ADDR	; Address low byte

	; This will write over the attribute table (technically the prior loop does an
	; unnecessary overrun... probably just a simpler loop to code.)
	LDY #$40	 ; Y = $40 
	LDA #$00	 ; A = 0
PRG031_FDFB:
	STA PPU_VRAM_DATA	 ; Write $00 to AT
	DEY		 ; Y--
	BNE PRG031_FDFB	 ; While Y <> 0, loop (will write 64 times)

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clear_Nametable_Short
;
; This subroutine sets ClearPattern over half a nametable, which
; is the initial value of A ($20 for NT 0, $28 for NT2)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Clear_Nametable_Short:	; $FE02
	LDA PPU_STAT	 	; 
	LDA #$00	 	; 
	STA PPU_CTL1		; Most likely most importantly to prevent any more Resets

	LDA <Temp_Var1		; Restore A (from Reset_PPU_Clear_Nametables, this is $20 or $28, Nametable 0 or Nametable 2)
	STA PPU_VRAM_ADDR	; Write this as high byte VRAM address select
	LDA #$00 
	STA PPU_VRAM_ADDR	; $00 as low byte for VRAM address (Reset_PPU_Clear_Nametables selects nametable 1 or 2)

	LDX #$03	 ; X = 3
	LDY #$c0	 ; Y = $C0
	LDA ClearPattern	 ; A = ClearPattern
PRG031_FE1B:
	STA PPU_VRAM_DATA	; Write this pattern

	DEY		 ; Y--
	BNE PRG031_FE1B	 ; While Y <> 0, loop

	DEX		 ; X--
	BNE PRG031_FE1B	 ; While X <> 0, loop!

	RTS		 ; Return

; FIXME: Anybody want to claim this?
; Seems to clear the screen based on specific Vert_Scroll values
PRG031_FE25:	.byte $00, $30, $70, $B0, $EF

	; High and Low VRAM Addresses
PRG031_FE2A:	.byte $20, $20, $21, $22, $28
PRG031_FE2F:	.byte $00, $C0, $C0, $C0, $00

; $FE34
	LDY #$04	; Y = 4
	LDA <Vert_Scroll
PRG031_FE38:
	CMP PRG031_FE25,Y
	BEQ PRG031_FE40	 ; If Vert_Scroll = this value, jump to PRG031_FE40

	DEY		 ; Y--
	BPL PRG031_FE38	 ; While Y >= 0, loop

PRG031_FE40:

	; Load FIXME values -> Temp_Var1/2
	LDA PRG031_FE2A,Y
	STA <Temp_Var1
	LDA PRG031_FE2F,Y
	STA <Temp_Var2

	LDY #$00	 ; Y = 0
	LDX #$03	 ; X = 3

	LDA <Vert_Scroll
	CMP #$ef
	BEQ PRG031_FE58	 ; If Vert_Scroll = $EF (bottom of horizontal scroll level), jump to PRG031_FE58

	LDY #$20	 ; Y = $20
	LDX #$04	 ; X = 4

PRG031_FE58:
	LDA PPU_STAT

	; Disable display
	LDA #$00
	STA PPU_CTL1
PRG031_FE60:
	; Set VRAM High/Low Addresses
	LDA <Temp_Var1
	STA PPU_VRAM_ADDR
	LDA <Temp_Var2
	STA PPU_VRAM_ADDR

PRG031_FE6A:
	LDA ClearPattern	 ; Get the clearing pattern
	STA PPU_VRAM_DATA	 ; Store it

	DEY		 ; Y--
	BNE PRG031_FE76	 ; If Y <> 0, jump to PRG031_FE76

	DEX		 ; X--
	BEQ PRG031_FE98	 ; If X = 0, jump to PRG031_FE98 (RTS)

PRG031_FE76:

	; Next VRAM byte
	LDA <Temp_Var2
	ADD #$01
	STA <Temp_Var2
	LDA <Temp_Var1
	ADC #$00
	STA <Temp_Var1

	CMP #$23
	BNE PRG031_FE6A	 ; If haven't possibly hit the end of the nametable, jump to PRG031_FE6A

	LDA <Temp_Var2
	CMP #$c0
	BNE PRG031_FE6A	 ; If haven't hit the end of the nametable, jump to PRG031_FE6A

	; Set address to second nametable
	LDA #$28
	STA <Temp_Var1
	LDA #$00
	STA <Temp_Var2

	JMP PRG031_FE60	; Loop!

PRG031_FE98:
	RTS		 ; Return
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DynJump
;
; A special subroutine for allowing a dynamic jump
; based on a LUT using the index specified by 'A'.
;
; To setup a dynamic call, the rules are fairly simple:
; Define a hook function which simply JSRs to this function,
; and immediately following that JSR put your LUT based on
; absolute addresses to all functions that should be called:
;
; My_DynJump:
;	JSR DynJump
;	.word $8123, $8456, $8789	; Based on 'A', jump to $8123 (0), $8456 (1), $8789 (2)
;
; This works since the return address is gobbled up by DynJump, so you will
; never return to the "JSR DynJump" line!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DynJump:	; $FE99
	ASL A		; A << 1 (turned into an index)
	TAY		; Y = A

	; The old return address to this call is pulled and stored
	; This will address the bytes that immediately followed the
	; JSR instruction that put us here...
	PLA			; Pull A
	STA <Temp_Var1		; Temp_Var1 = pulled A
	PLA			; Pull A
	STA <Temp_Var2		; Temp_Var2 = pulled A

	; REMEMBER: Since the return address was pulled, the next RTS that
	; we happen to encounter will put us back to the call before the
	; call that put us here at DynJump...

	INY			; Need to increment Y (because the return address is at the last byte of the JSR)
	LDA [Temp_Var1],Y	; Gets the byte here (address high)
	STA <Temp_Var3		; Stored into Temp_Var3
	INY		 	; Y++
	LDA [Temp_Var1],Y	; Gets the byte here (address low)
	STA <Temp_Var4		; Stores the byte into Temp_Var4
	JMP [Temp_Var3]	 	; Jump to [Temp_Var4][Temp_Var3]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read_Joypads
;
; This subroutine reads the status of both joypads 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Read_Joypads_UnkTable:
	.byte	$00, $01, $02, $00, $04, $05, $06, $04, $08, $09, $0A, $08, $00, $01, $02, $00

Read_Joypads:

	; Read joypads
	LDY #$01	 ; Joypad 2 then 1

PRG031_FEC0:
	JSR Read_Joypad	 ; Read Joypad Y

	; FIXME: I THINK this is for switch debouncing??
PRG031_FEC3:
	LDA <Temp_Var1	 ; Pull result out of $00 -> A
	PHA		 ; Push A
	JSR Read_Joypad	 ; Read Joypad
	PLA		 ; Pull A
	CMP <Temp_Var1	 ; Check if same
	BNE PRG031_FEC3	 ; If not, do it again

	ORA <Temp_Var2	 ; 
	PHA		 ; Push A
	AND #$0f	 ; A &= $0F
	TAX		 ; A -> X
	PLA		 ; Pull A
	AND #$f0	 ; A &= $F0

	ORA Read_Joypads_UnkTable,X	 ; FIXME: A |= Read_Joypads_UnkTable[X]
	PHA		 	; Save A
	STA <Temp_Var3	 	; Temp_Var3 = A
	EOR Controller1,Y	; 
	AND <Temp_Var3	 	; 
	STA Controller1Press,Y	; Figures which buttons have only been PRESSED this frame as opposed to those which are being held down
	STA <Pad_Input	 	; 
	PLA		 	; Restore A
	STA Controller1,Y	; 
	STA <Pad_Holding	 ; 
	DEY		 ; Y-- 
	BPL PRG031_FEC0	 ; If Y hasn't gone negative (it should just now be 0), Read other joypad

	; Done reading joypads
	LDY Player_Current	 
	BEQ PRG031_FF11	 ; If Player_Curren = 0 (Mario), jump to PRG031_FF11

	LDA <Controller1
	AND #$30
	STA <Temp_Var1
	LDA <Controller2
	AND #$cf
	ORA <Temp_Var1
	STA <Pad_Holding
	LDA <Controller1Press
	AND #$30
	STA <Temp_Var1
	LDA <Controller2Press
	AND #$cf
	ORA <Temp_Var1
	STA <Pad_Input

PRG031_FF11:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read_Joypad
;
; This subroutine does some tricky business to read out the joypad
; into Temp_Var1 / Temp_Var2
; Register Y should be 0 for Joypad 1 and 1 for Joypad 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Read_Joypad:	; $FF12

	; Joypad reading is weird, and actually requires 8 accesses to the joypad I/O to get all the buttons:
	; Read #1: A 
	;      #2: B 
	;      #3: Select
	;      #4: Start 
	;      #5: Up    
	;      #6: Down  
	;      #7: Left  
	;      #8: Right 

	; This Resets BOTH controllers
	LDA #$01	 ; A = 1 (strobe)
	STA JOYPAD	 ; Strobe joypad 1 (hi)
	LSR A		 ; A = 0 (clear), 1 -> Carry
	STA JOYPAD	 ; Clear strobe joypad 1

	; Needs cleanup and commentary, but basically this does 8 loops to
	; read all buttons and store the result for return
	LDX #$08	 ; X = 8
Read_Joypad_Loop:
	LDA JOYPAD,Y	 ; Get joypad data
	LSR A
	ROL <Temp_Var1
	LSR A
	ROL <Temp_Var2
	DEX
	BNE Read_Joypad_Loop	 ; Loop until 8 reads complete

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; IntReset
; Game begins here...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IntReset:
	SEI		 ; Disable maskable interrupts
	CLD		 ; Clear decimal (no BCD math, not there should be anyway)
	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most likely mainly to make BG and SPRITES invisible
	LDA #$08	 ; 
	STA PPU_CTL1	 ; Sprites in Pattern Table 2
	LDX #$02	 ; X = 2

VBlank_Wait_Loop:
	LDA PPU_STAT
	BPL VBlank_Wait_Loop	; If VBlank NOT reported as occuring, loop around and check again!

	DEX		 	; X--
	BNE VBlank_Wait_Loop	; X starts at 2, and goes to 1; so check once more?

	DEX		 ; Effectively, X = $FF
	TXS		 ; X -> Stack Pointer (NMI stack)

	LDA #MMC3_2K_TO_PPU_0000
	STA MMC3_COMMAND	; Command MMC3 to change out first 2K of PPU
	LDY #$00	 ; Y = 0
	STY PPU_SCROLL	 ; Horizontal scroll = 0
	STY PPU_SCROLL	 ; Vertical scroll = 0
	STY MMC3_SRAM_EN ; Disable MMC3 SRAM (?)
	STY MMC3_IRQDISABLE ; Disable MMC3 IRQ generation

	LDA #%00001111	 ; 
	STA PAPU_EN	 ; Enable rectangle wave 1 & 2, triangle, and noise channels
	LDA #$00	 ; 
	STA PAPU_MODCTL	 ; disable DMC IRQs

	; Any write to $4017 resets both the frame counter, and the clock divider. 
	; Sometimes, games will write to this register in order to synchronize the 
	; sound hardware's internal timing, to the sound routine's timing (usually 
	; tied into the Reset code). The frame IRQ frequency is slightly smaller than 
	; the PPU's vertical retrace frequency, so you can see why games would desire 
	; this syncronization.

	LDA #$40	 ; 
	STA FRAMECTR_CTL ; disable APU frame IRQ

	LDA PPU_STAT

	LDA #16		 ; A = 16
	TAX		 ; X = 16

	; The following writes 16 twice to PPU_VRAM_ADDR a total of 16 times
	; Not sure what the point of this is?  Must be some kind of hardware thing??
PRG031_FF80:
	STA PPU_VRAM_ADDR	 ; 
	STA PPU_VRAM_ADDR	 ; 
	EOR #$00	 ; Do nothing??
	DEX		 ; X--
	BNE PRG031_FF80	 ; While X > 0, loop

	LDA #$01	 ; 
	STA MMC3_MIRROR	 ; MMC3 command for Vertical mirroring
	LDA #$80	 ; 
	STA MMC3_SRAM_EN ; Re-enable MMC3 SRAM (?)

	; Clear $07FF - $0000, excluding $01xx
	LDY #$07		 
	JSR Clear_RAM_thru_ZeroPage

	LDA #25
	STA PAGE_C000	 
	LDA #24
	STA PAGE_A000	 
	JSR PRGROM_Change_Both2		; Change A000 to page 25 and C000 to page 24

	; NOPs?
	NOP
	NOP
	NOP

	JMP IntReset_Part2	; Rest of Reset continues in the $8000 bank...

PT2_Full_CHRROM_Switch:	 ; $FFAD
	; This subroutine does a full pattern table switchout
	LDY #$05	 ; Loop Y from 5 to 0, effecting all pattern selections

PT2_Full_CHRROM_Loop:
	TYA		 ; A = Y 
	ORA #$40	 ; A = 5 | $40 = $45 (When 5, MMC3_1K_TO_PPU_1C00; decrements thru other pages)
	STA MMC3_COMMAND ; Set MMC3 command
	LDA PatTable_BankSel,Y ; Offset into the Pattern Table 2 LUT for this page
	STA MMC3_PAGE	 ; Set MMC3 page
	DEY		 ; Y--
	BPL PT2_Full_CHRROM_Loop	 ; While Y >= 0, loop!

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PRGROM_Change_Both2
;
; This subroutine sets both PRG ROM pages A000 and C000 together.
; It also writes to $0721, apparently to allow where it returns to
; reissue the MMC3 command (FIXME reason yet unknown ???)
;	A000 is set to the page value found at RAM location PAGE_A000
;	C000 is set to the page value found at RAM location PAGE_C000
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRGROM_Change_Both2:	; $FFBF
	JSR PRGROM_Change_C000		; Change C000 first
	; Continues into PRGROM_Change_A000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PRGROM_Change_A000
;
; This subroutine sets the PRG ROM page at C000
;	C000 is set to the page value found at RAM location PAGE_A000
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRGROM_Change_A000:			; $FFC2
	LDA #MMC3_8K_TO_PRG_A000	; Changing PRG ROM at A000
	STA PAGE_CMD			; FIXME: Store @ PAGE_CMD
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA PAGE_A000			; Page @ PAGE_A000
	STA MMC3_PAGE	 		; Set MMC3 page
	RTS		 		; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PRGROM_Change_C000
;
; This subroutine sets the PRG ROM page at A000
;	A000 is set to the page value found at RAM location PAGE_C000
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRGROM_Change_C000:	; $FFD1
	LDA #MMC3_8K_TO_PRG_C000	; Changing PRG ROM at C000
	STA PAGE_CMD			; FIXME: Store @ PAGE_CMD
	STA MMC3_COMMAND 		; Set MMC3 command
	LDA PAGE_C000	 		; Page @ PAGE_C000
	STA MMC3_PAGE			; Set MMC3 page
	RTS				; Return


	;.byte $FF, $FF, $FF

	; A marker of some kind? :)
	;.byte "SUPER MARIO 3"

	; Signature?
	;.byte $00, $00, $6C, $56, $03, $00, $01, $0C, $01, $2D

	; ASSEMBLER BOUNDARY CHECK, END OF $FFFA
.Bound_FFFA:	BoundCheck .Bound_FFFA, $FFFA, PRG031: Vector space

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VECTORS
; Must appear at $FFFA
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	.org $FFFA
Vector_Table:
	.word IntNMI   	; $FFFA - NMI Interrupt (VBlank)
	.word IntReset	; $FFFC - Reset Interrupt (boot up)
	.word IntIRQ	; $FFFE - IRQ Interrupt (scanline from MMC3)

